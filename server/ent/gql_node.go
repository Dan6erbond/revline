// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/Dan6erbond/revline/ent/album"
	"github.com/Dan6erbond/revline/ent/car"
	"github.com/Dan6erbond/revline/ent/checkoutsession"
	"github.com/Dan6erbond/revline/ent/document"
	"github.com/Dan6erbond/revline/ent/dragresult"
	"github.com/Dan6erbond/revline/ent/dragsession"
	"github.com/Dan6erbond/revline/ent/dynoresult"
	"github.com/Dan6erbond/revline/ent/dynosession"
	"github.com/Dan6erbond/revline/ent/expense"
	"github.com/Dan6erbond/revline/ent/fuelup"
	"github.com/Dan6erbond/revline/ent/media"
	"github.com/Dan6erbond/revline/ent/mod"
	"github.com/Dan6erbond/revline/ent/modproductoption"
	"github.com/Dan6erbond/revline/ent/odometerreading"
	"github.com/Dan6erbond/revline/ent/profile"
	"github.com/Dan6erbond/revline/ent/serviceitem"
	"github.com/Dan6erbond/revline/ent/servicelog"
	"github.com/Dan6erbond/revline/ent/serviceschedule"
	"github.com/Dan6erbond/revline/ent/subscription"
	"github.com/Dan6erbond/revline/ent/task"
	"github.com/Dan6erbond/revline/ent/user"
	"github.com/Dan6erbond/revline/ent/usersettings"
	"github.com/google/uuid"
	"github.com/hashicorp/go-multierror"
)

// Noder wraps the basic Node method.
type Noder interface {
	IsNode()
}

var albumImplementors = []string{"Album", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Album) IsNode() {}

var carImplementors = []string{"Car", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Car) IsNode() {}

var checkoutsessionImplementors = []string{"CheckoutSession", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*CheckoutSession) IsNode() {}

var documentImplementors = []string{"Document", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Document) IsNode() {}

var dragresultImplementors = []string{"DragResult", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*DragResult) IsNode() {}

var dragsessionImplementors = []string{"DragSession", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*DragSession) IsNode() {}

var dynoresultImplementors = []string{"DynoResult", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*DynoResult) IsNode() {}

var dynosessionImplementors = []string{"DynoSession", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*DynoSession) IsNode() {}

var expenseImplementors = []string{"Expense", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Expense) IsNode() {}

var fuelupImplementors = []string{"FuelUp", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*FuelUp) IsNode() {}

var mediaImplementors = []string{"Media", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Media) IsNode() {}

var modImplementors = []string{"Mod", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Mod) IsNode() {}

var modproductoptionImplementors = []string{"ModProductOption", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*ModProductOption) IsNode() {}

var odometerreadingImplementors = []string{"OdometerReading", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*OdometerReading) IsNode() {}

var profileImplementors = []string{"Profile", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Profile) IsNode() {}

var serviceitemImplementors = []string{"ServiceItem", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*ServiceItem) IsNode() {}

var servicelogImplementors = []string{"ServiceLog", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*ServiceLog) IsNode() {}

var servicescheduleImplementors = []string{"ServiceSchedule", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*ServiceSchedule) IsNode() {}

var subscriptionImplementors = []string{"SubscriptionPlan", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Subscription) IsNode() {}

var taskImplementors = []string{"Task", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*Task) IsNode() {}

var userImplementors = []string{"User", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*User) IsNode() {}

var usersettingsImplementors = []string{"UserSettings", "Node"}

// IsNode implements the Node interface check for GQLGen.
func (*UserSettings) IsNode() {}

var errNodeInvalidID = &NotFoundError{"node"}

// NodeOption allows configuring the Noder execution using functional options.
type NodeOption func(*nodeOptions)

// WithNodeType sets the node Type resolver function (i.e. the table to query).
// If was not provided, the table will be derived from the universal-id
// configuration as described in: https://entgo.io/docs/migrate/#universal-ids.
func WithNodeType(f func(context.Context, uuid.UUID) (string, error)) NodeOption {
	return func(o *nodeOptions) {
		o.nodeType = f
	}
}

// WithFixedNodeType sets the Type of the node to a fixed value.
func WithFixedNodeType(t string) NodeOption {
	return WithNodeType(func(context.Context, uuid.UUID) (string, error) {
		return t, nil
	})
}

type nodeOptions struct {
	nodeType func(context.Context, uuid.UUID) (string, error)
}

func (c *Client) newNodeOpts(opts []NodeOption) *nodeOptions {
	nopts := &nodeOptions{}
	for _, opt := range opts {
		opt(nopts)
	}
	if nopts.nodeType == nil {
		nopts.nodeType = func(ctx context.Context, id uuid.UUID) (string, error) {
			return "", fmt.Errorf("cannot resolve noder (%v) without its type", id)
		}
	}
	return nopts
}

// Noder returns a Node by its id. If the NodeType was not provided, it will
// be derived from the id value according to the universal-id configuration.
//
//	c.Noder(ctx, id)
//	c.Noder(ctx, id, ent.WithNodeType(typeResolver))
func (c *Client) Noder(ctx context.Context, id uuid.UUID, opts ...NodeOption) (_ Noder, err error) {
	defer func() {
		if IsNotFound(err) {
			err = multierror.Append(err, entgql.ErrNodeNotFound(id))
		}
	}()
	table, err := c.newNodeOpts(opts).nodeType(ctx, id)
	if err != nil {
		return nil, err
	}
	return c.noder(ctx, table, id)
}

func (c *Client) noder(ctx context.Context, table string, id uuid.UUID) (Noder, error) {
	switch table {
	case album.Table:
		query := c.Album.Query().
			Where(album.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, albumImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case car.Table:
		query := c.Car.Query().
			Where(car.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, carImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case checkoutsession.Table:
		query := c.CheckoutSession.Query().
			Where(checkoutsession.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, checkoutsessionImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case document.Table:
		query := c.Document.Query().
			Where(document.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, documentImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case dragresult.Table:
		query := c.DragResult.Query().
			Where(dragresult.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, dragresultImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case dragsession.Table:
		query := c.DragSession.Query().
			Where(dragsession.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, dragsessionImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case dynoresult.Table:
		query := c.DynoResult.Query().
			Where(dynoresult.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, dynoresultImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case dynosession.Table:
		query := c.DynoSession.Query().
			Where(dynosession.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, dynosessionImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case expense.Table:
		query := c.Expense.Query().
			Where(expense.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, expenseImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case fuelup.Table:
		query := c.FuelUp.Query().
			Where(fuelup.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, fuelupImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case media.Table:
		query := c.Media.Query().
			Where(media.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, mediaImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case mod.Table:
		query := c.Mod.Query().
			Where(mod.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, modImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case modproductoption.Table:
		query := c.ModProductOption.Query().
			Where(modproductoption.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, modproductoptionImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case odometerreading.Table:
		query := c.OdometerReading.Query().
			Where(odometerreading.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, odometerreadingImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case profile.Table:
		query := c.Profile.Query().
			Where(profile.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, profileImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case serviceitem.Table:
		query := c.ServiceItem.Query().
			Where(serviceitem.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, serviceitemImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case servicelog.Table:
		query := c.ServiceLog.Query().
			Where(servicelog.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, servicelogImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case serviceschedule.Table:
		query := c.ServiceSchedule.Query().
			Where(serviceschedule.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, servicescheduleImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case subscription.Table:
		query := c.Subscription.Query().
			Where(subscription.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, subscriptionImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case task.Table:
		query := c.Task.Query().
			Where(task.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, taskImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case user.Table:
		query := c.User.Query().
			Where(user.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, userImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	case usersettings.Table:
		query := c.UserSettings.Query().
			Where(usersettings.ID(id))
		if fc := graphql.GetFieldContext(ctx); fc != nil {
			if err := query.collectField(ctx, true, graphql.GetOperationContext(ctx), fc.Field, nil, usersettingsImplementors...); err != nil {
				return nil, err
			}
		}
		return query.Only(ctx)
	default:
		return nil, fmt.Errorf("cannot resolve noder from table %q: %w", table, errNodeInvalidID)
	}
}

func (c *Client) Noders(ctx context.Context, ids []uuid.UUID, opts ...NodeOption) ([]Noder, error) {
	switch len(ids) {
	case 1:
		noder, err := c.Noder(ctx, ids[0], opts...)
		if err != nil {
			return nil, err
		}
		return []Noder{noder}, nil
	case 0:
		return []Noder{}, nil
	}

	noders := make([]Noder, len(ids))
	errors := make([]error, len(ids))
	tables := make(map[string][]uuid.UUID)
	id2idx := make(map[uuid.UUID][]int, len(ids))
	nopts := c.newNodeOpts(opts)
	for i, id := range ids {
		table, err := nopts.nodeType(ctx, id)
		if err != nil {
			errors[i] = err
			continue
		}
		tables[table] = append(tables[table], id)
		id2idx[id] = append(id2idx[id], i)
	}

	for table, ids := range tables {
		nodes, err := c.noders(ctx, table, ids)
		if err != nil {
			for _, id := range ids {
				for _, idx := range id2idx[id] {
					errors[idx] = err
				}
			}
		} else {
			for i, id := range ids {
				for _, idx := range id2idx[id] {
					noders[idx] = nodes[i]
				}
			}
		}
	}

	for i, id := range ids {
		if errors[i] == nil {
			if noders[i] != nil {
				continue
			}
			errors[i] = entgql.ErrNodeNotFound(id)
		} else if IsNotFound(errors[i]) {
			errors[i] = multierror.Append(errors[i], entgql.ErrNodeNotFound(id))
		}
		ctx := graphql.WithPathContext(ctx,
			graphql.NewPathWithIndex(i),
		)
		graphql.AddError(ctx, errors[i])
	}
	return noders, nil
}

func (c *Client) noders(ctx context.Context, table string, ids []uuid.UUID) ([]Noder, error) {
	noders := make([]Noder, len(ids))
	idmap := make(map[uuid.UUID][]*Noder, len(ids))
	for i, id := range ids {
		idmap[id] = append(idmap[id], &noders[i])
	}
	switch table {
	case album.Table:
		query := c.Album.Query().
			Where(album.IDIn(ids...))
		query, err := query.CollectFields(ctx, albumImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case car.Table:
		query := c.Car.Query().
			Where(car.IDIn(ids...))
		query, err := query.CollectFields(ctx, carImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case checkoutsession.Table:
		query := c.CheckoutSession.Query().
			Where(checkoutsession.IDIn(ids...))
		query, err := query.CollectFields(ctx, checkoutsessionImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case document.Table:
		query := c.Document.Query().
			Where(document.IDIn(ids...))
		query, err := query.CollectFields(ctx, documentImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case dragresult.Table:
		query := c.DragResult.Query().
			Where(dragresult.IDIn(ids...))
		query, err := query.CollectFields(ctx, dragresultImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case dragsession.Table:
		query := c.DragSession.Query().
			Where(dragsession.IDIn(ids...))
		query, err := query.CollectFields(ctx, dragsessionImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case dynoresult.Table:
		query := c.DynoResult.Query().
			Where(dynoresult.IDIn(ids...))
		query, err := query.CollectFields(ctx, dynoresultImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case dynosession.Table:
		query := c.DynoSession.Query().
			Where(dynosession.IDIn(ids...))
		query, err := query.CollectFields(ctx, dynosessionImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case expense.Table:
		query := c.Expense.Query().
			Where(expense.IDIn(ids...))
		query, err := query.CollectFields(ctx, expenseImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case fuelup.Table:
		query := c.FuelUp.Query().
			Where(fuelup.IDIn(ids...))
		query, err := query.CollectFields(ctx, fuelupImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case media.Table:
		query := c.Media.Query().
			Where(media.IDIn(ids...))
		query, err := query.CollectFields(ctx, mediaImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case mod.Table:
		query := c.Mod.Query().
			Where(mod.IDIn(ids...))
		query, err := query.CollectFields(ctx, modImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case modproductoption.Table:
		query := c.ModProductOption.Query().
			Where(modproductoption.IDIn(ids...))
		query, err := query.CollectFields(ctx, modproductoptionImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case odometerreading.Table:
		query := c.OdometerReading.Query().
			Where(odometerreading.IDIn(ids...))
		query, err := query.CollectFields(ctx, odometerreadingImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case profile.Table:
		query := c.Profile.Query().
			Where(profile.IDIn(ids...))
		query, err := query.CollectFields(ctx, profileImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case serviceitem.Table:
		query := c.ServiceItem.Query().
			Where(serviceitem.IDIn(ids...))
		query, err := query.CollectFields(ctx, serviceitemImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case servicelog.Table:
		query := c.ServiceLog.Query().
			Where(servicelog.IDIn(ids...))
		query, err := query.CollectFields(ctx, servicelogImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case serviceschedule.Table:
		query := c.ServiceSchedule.Query().
			Where(serviceschedule.IDIn(ids...))
		query, err := query.CollectFields(ctx, servicescheduleImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case subscription.Table:
		query := c.Subscription.Query().
			Where(subscription.IDIn(ids...))
		query, err := query.CollectFields(ctx, subscriptionImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case task.Table:
		query := c.Task.Query().
			Where(task.IDIn(ids...))
		query, err := query.CollectFields(ctx, taskImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case user.Table:
		query := c.User.Query().
			Where(user.IDIn(ids...))
		query, err := query.CollectFields(ctx, userImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case usersettings.Table:
		query := c.UserSettings.Query().
			Where(usersettings.IDIn(ids...))
		query, err := query.CollectFields(ctx, usersettingsImplementors...)
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	default:
		return nil, fmt.Errorf("cannot resolve noders from table %q: %w", table, errNodeInvalidID)
	}
	return noders, nil
}

// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/Dan6erbond/revline/ent/car"
	"github.com/Dan6erbond/revline/ent/expense"
	"github.com/Dan6erbond/revline/ent/fuelup"
	"github.com/Dan6erbond/revline/ent/odometerreading"
	"github.com/Dan6erbond/revline/ent/predicate"
	"github.com/google/uuid"
)

// FuelUpUpdate is the builder for updating FuelUp entities.
type FuelUpUpdate struct {
	config
	hooks    []Hook
	mutation *FuelUpMutation
}

// Where appends a list predicates to the FuelUpUpdate builder.
func (fuu *FuelUpUpdate) Where(ps ...predicate.FuelUp) *FuelUpUpdate {
	fuu.mutation.Where(ps...)
	return fuu
}

// SetUpdateTime sets the "update_time" field.
func (fuu *FuelUpUpdate) SetUpdateTime(t time.Time) *FuelUpUpdate {
	fuu.mutation.SetUpdateTime(t)
	return fuu
}

// SetOccurredAt sets the "occurred_at" field.
func (fuu *FuelUpUpdate) SetOccurredAt(t time.Time) *FuelUpUpdate {
	fuu.mutation.SetOccurredAt(t)
	return fuu
}

// SetNillableOccurredAt sets the "occurred_at" field if the given value is not nil.
func (fuu *FuelUpUpdate) SetNillableOccurredAt(t *time.Time) *FuelUpUpdate {
	if t != nil {
		fuu.SetOccurredAt(*t)
	}
	return fuu
}

// SetStation sets the "station" field.
func (fuu *FuelUpUpdate) SetStation(s string) *FuelUpUpdate {
	fuu.mutation.SetStation(s)
	return fuu
}

// SetNillableStation sets the "station" field if the given value is not nil.
func (fuu *FuelUpUpdate) SetNillableStation(s *string) *FuelUpUpdate {
	if s != nil {
		fuu.SetStation(*s)
	}
	return fuu
}

// SetAmountLiters sets the "amount_liters" field.
func (fuu *FuelUpUpdate) SetAmountLiters(f float64) *FuelUpUpdate {
	fuu.mutation.ResetAmountLiters()
	fuu.mutation.SetAmountLiters(f)
	return fuu
}

// SetNillableAmountLiters sets the "amount_liters" field if the given value is not nil.
func (fuu *FuelUpUpdate) SetNillableAmountLiters(f *float64) *FuelUpUpdate {
	if f != nil {
		fuu.SetAmountLiters(*f)
	}
	return fuu
}

// AddAmountLiters adds f to the "amount_liters" field.
func (fuu *FuelUpUpdate) AddAmountLiters(f float64) *FuelUpUpdate {
	fuu.mutation.AddAmountLiters(f)
	return fuu
}

// SetFuelCategory sets the "fuel_category" field.
func (fuu *FuelUpUpdate) SetFuelCategory(fc fuelup.FuelCategory) *FuelUpUpdate {
	fuu.mutation.SetFuelCategory(fc)
	return fuu
}

// SetNillableFuelCategory sets the "fuel_category" field if the given value is not nil.
func (fuu *FuelUpUpdate) SetNillableFuelCategory(fc *fuelup.FuelCategory) *FuelUpUpdate {
	if fc != nil {
		fuu.SetFuelCategory(*fc)
	}
	return fuu
}

// SetOctaneRating sets the "octane_rating" field.
func (fuu *FuelUpUpdate) SetOctaneRating(fr fuelup.OctaneRating) *FuelUpUpdate {
	fuu.mutation.SetOctaneRating(fr)
	return fuu
}

// SetNillableOctaneRating sets the "octane_rating" field if the given value is not nil.
func (fuu *FuelUpUpdate) SetNillableOctaneRating(fr *fuelup.OctaneRating) *FuelUpUpdate {
	if fr != nil {
		fuu.SetOctaneRating(*fr)
	}
	return fuu
}

// ClearOctaneRating clears the value of the "octane_rating" field.
func (fuu *FuelUpUpdate) ClearOctaneRating() *FuelUpUpdate {
	fuu.mutation.ClearOctaneRating()
	return fuu
}

// SetIsFullTank sets the "is_full_tank" field.
func (fuu *FuelUpUpdate) SetIsFullTank(b bool) *FuelUpUpdate {
	fuu.mutation.SetIsFullTank(b)
	return fuu
}

// SetNillableIsFullTank sets the "is_full_tank" field if the given value is not nil.
func (fuu *FuelUpUpdate) SetNillableIsFullTank(b *bool) *FuelUpUpdate {
	if b != nil {
		fuu.SetIsFullTank(*b)
	}
	return fuu
}

// SetNotes sets the "notes" field.
func (fuu *FuelUpUpdate) SetNotes(s string) *FuelUpUpdate {
	fuu.mutation.SetNotes(s)
	return fuu
}

// SetNillableNotes sets the "notes" field if the given value is not nil.
func (fuu *FuelUpUpdate) SetNillableNotes(s *string) *FuelUpUpdate {
	if s != nil {
		fuu.SetNotes(*s)
	}
	return fuu
}

// ClearNotes clears the value of the "notes" field.
func (fuu *FuelUpUpdate) ClearNotes() *FuelUpUpdate {
	fuu.mutation.ClearNotes()
	return fuu
}

// SetCarID sets the "car" edge to the Car entity by ID.
func (fuu *FuelUpUpdate) SetCarID(id uuid.UUID) *FuelUpUpdate {
	fuu.mutation.SetCarID(id)
	return fuu
}

// SetCar sets the "car" edge to the Car entity.
func (fuu *FuelUpUpdate) SetCar(c *Car) *FuelUpUpdate {
	return fuu.SetCarID(c.ID)
}

// SetOdometerReadingID sets the "odometer_reading" edge to the OdometerReading entity by ID.
func (fuu *FuelUpUpdate) SetOdometerReadingID(id uuid.UUID) *FuelUpUpdate {
	fuu.mutation.SetOdometerReadingID(id)
	return fuu
}

// SetNillableOdometerReadingID sets the "odometer_reading" edge to the OdometerReading entity by ID if the given value is not nil.
func (fuu *FuelUpUpdate) SetNillableOdometerReadingID(id *uuid.UUID) *FuelUpUpdate {
	if id != nil {
		fuu = fuu.SetOdometerReadingID(*id)
	}
	return fuu
}

// SetOdometerReading sets the "odometer_reading" edge to the OdometerReading entity.
func (fuu *FuelUpUpdate) SetOdometerReading(o *OdometerReading) *FuelUpUpdate {
	return fuu.SetOdometerReadingID(o.ID)
}

// SetExpenseID sets the "expense" edge to the Expense entity by ID.
func (fuu *FuelUpUpdate) SetExpenseID(id uuid.UUID) *FuelUpUpdate {
	fuu.mutation.SetExpenseID(id)
	return fuu
}

// SetNillableExpenseID sets the "expense" edge to the Expense entity by ID if the given value is not nil.
func (fuu *FuelUpUpdate) SetNillableExpenseID(id *uuid.UUID) *FuelUpUpdate {
	if id != nil {
		fuu = fuu.SetExpenseID(*id)
	}
	return fuu
}

// SetExpense sets the "expense" edge to the Expense entity.
func (fuu *FuelUpUpdate) SetExpense(e *Expense) *FuelUpUpdate {
	return fuu.SetExpenseID(e.ID)
}

// Mutation returns the FuelUpMutation object of the builder.
func (fuu *FuelUpUpdate) Mutation() *FuelUpMutation {
	return fuu.mutation
}

// ClearCar clears the "car" edge to the Car entity.
func (fuu *FuelUpUpdate) ClearCar() *FuelUpUpdate {
	fuu.mutation.ClearCar()
	return fuu
}

// ClearOdometerReading clears the "odometer_reading" edge to the OdometerReading entity.
func (fuu *FuelUpUpdate) ClearOdometerReading() *FuelUpUpdate {
	fuu.mutation.ClearOdometerReading()
	return fuu
}

// ClearExpense clears the "expense" edge to the Expense entity.
func (fuu *FuelUpUpdate) ClearExpense() *FuelUpUpdate {
	fuu.mutation.ClearExpense()
	return fuu
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (fuu *FuelUpUpdate) Save(ctx context.Context) (int, error) {
	fuu.defaults()
	return withHooks(ctx, fuu.sqlSave, fuu.mutation, fuu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (fuu *FuelUpUpdate) SaveX(ctx context.Context) int {
	affected, err := fuu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (fuu *FuelUpUpdate) Exec(ctx context.Context) error {
	_, err := fuu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (fuu *FuelUpUpdate) ExecX(ctx context.Context) {
	if err := fuu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (fuu *FuelUpUpdate) defaults() {
	if _, ok := fuu.mutation.UpdateTime(); !ok {
		v := fuelup.UpdateDefaultUpdateTime()
		fuu.mutation.SetUpdateTime(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (fuu *FuelUpUpdate) check() error {
	if v, ok := fuu.mutation.FuelCategory(); ok {
		if err := fuelup.FuelCategoryValidator(v); err != nil {
			return &ValidationError{Name: "fuel_category", err: fmt.Errorf(`ent: validator failed for field "FuelUp.fuel_category": %w`, err)}
		}
	}
	if v, ok := fuu.mutation.OctaneRating(); ok {
		if err := fuelup.OctaneRatingValidator(v); err != nil {
			return &ValidationError{Name: "octane_rating", err: fmt.Errorf(`ent: validator failed for field "FuelUp.octane_rating": %w`, err)}
		}
	}
	if fuu.mutation.CarCleared() && len(fuu.mutation.CarIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "FuelUp.car"`)
	}
	return nil
}

func (fuu *FuelUpUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := fuu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(fuelup.Table, fuelup.Columns, sqlgraph.NewFieldSpec(fuelup.FieldID, field.TypeUUID))
	if ps := fuu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := fuu.mutation.UpdateTime(); ok {
		_spec.SetField(fuelup.FieldUpdateTime, field.TypeTime, value)
	}
	if value, ok := fuu.mutation.OccurredAt(); ok {
		_spec.SetField(fuelup.FieldOccurredAt, field.TypeTime, value)
	}
	if value, ok := fuu.mutation.Station(); ok {
		_spec.SetField(fuelup.FieldStation, field.TypeString, value)
	}
	if value, ok := fuu.mutation.AmountLiters(); ok {
		_spec.SetField(fuelup.FieldAmountLiters, field.TypeFloat64, value)
	}
	if value, ok := fuu.mutation.AddedAmountLiters(); ok {
		_spec.AddField(fuelup.FieldAmountLiters, field.TypeFloat64, value)
	}
	if value, ok := fuu.mutation.FuelCategory(); ok {
		_spec.SetField(fuelup.FieldFuelCategory, field.TypeEnum, value)
	}
	if value, ok := fuu.mutation.OctaneRating(); ok {
		_spec.SetField(fuelup.FieldOctaneRating, field.TypeEnum, value)
	}
	if fuu.mutation.OctaneRatingCleared() {
		_spec.ClearField(fuelup.FieldOctaneRating, field.TypeEnum)
	}
	if value, ok := fuu.mutation.IsFullTank(); ok {
		_spec.SetField(fuelup.FieldIsFullTank, field.TypeBool, value)
	}
	if value, ok := fuu.mutation.Notes(); ok {
		_spec.SetField(fuelup.FieldNotes, field.TypeString, value)
	}
	if fuu.mutation.NotesCleared() {
		_spec.ClearField(fuelup.FieldNotes, field.TypeString)
	}
	if fuu.mutation.CarCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   fuelup.CarTable,
			Columns: []string{fuelup.CarColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(car.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := fuu.mutation.CarIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   fuelup.CarTable,
			Columns: []string{fuelup.CarColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(car.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if fuu.mutation.OdometerReadingCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   fuelup.OdometerReadingTable,
			Columns: []string{fuelup.OdometerReadingColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(odometerreading.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := fuu.mutation.OdometerReadingIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   fuelup.OdometerReadingTable,
			Columns: []string{fuelup.OdometerReadingColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(odometerreading.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if fuu.mutation.ExpenseCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   fuelup.ExpenseTable,
			Columns: []string{fuelup.ExpenseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(expense.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := fuu.mutation.ExpenseIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   fuelup.ExpenseTable,
			Columns: []string{fuelup.ExpenseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(expense.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, fuu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{fuelup.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	fuu.mutation.done = true
	return n, nil
}

// FuelUpUpdateOne is the builder for updating a single FuelUp entity.
type FuelUpUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *FuelUpMutation
}

// SetUpdateTime sets the "update_time" field.
func (fuuo *FuelUpUpdateOne) SetUpdateTime(t time.Time) *FuelUpUpdateOne {
	fuuo.mutation.SetUpdateTime(t)
	return fuuo
}

// SetOccurredAt sets the "occurred_at" field.
func (fuuo *FuelUpUpdateOne) SetOccurredAt(t time.Time) *FuelUpUpdateOne {
	fuuo.mutation.SetOccurredAt(t)
	return fuuo
}

// SetNillableOccurredAt sets the "occurred_at" field if the given value is not nil.
func (fuuo *FuelUpUpdateOne) SetNillableOccurredAt(t *time.Time) *FuelUpUpdateOne {
	if t != nil {
		fuuo.SetOccurredAt(*t)
	}
	return fuuo
}

// SetStation sets the "station" field.
func (fuuo *FuelUpUpdateOne) SetStation(s string) *FuelUpUpdateOne {
	fuuo.mutation.SetStation(s)
	return fuuo
}

// SetNillableStation sets the "station" field if the given value is not nil.
func (fuuo *FuelUpUpdateOne) SetNillableStation(s *string) *FuelUpUpdateOne {
	if s != nil {
		fuuo.SetStation(*s)
	}
	return fuuo
}

// SetAmountLiters sets the "amount_liters" field.
func (fuuo *FuelUpUpdateOne) SetAmountLiters(f float64) *FuelUpUpdateOne {
	fuuo.mutation.ResetAmountLiters()
	fuuo.mutation.SetAmountLiters(f)
	return fuuo
}

// SetNillableAmountLiters sets the "amount_liters" field if the given value is not nil.
func (fuuo *FuelUpUpdateOne) SetNillableAmountLiters(f *float64) *FuelUpUpdateOne {
	if f != nil {
		fuuo.SetAmountLiters(*f)
	}
	return fuuo
}

// AddAmountLiters adds f to the "amount_liters" field.
func (fuuo *FuelUpUpdateOne) AddAmountLiters(f float64) *FuelUpUpdateOne {
	fuuo.mutation.AddAmountLiters(f)
	return fuuo
}

// SetFuelCategory sets the "fuel_category" field.
func (fuuo *FuelUpUpdateOne) SetFuelCategory(fc fuelup.FuelCategory) *FuelUpUpdateOne {
	fuuo.mutation.SetFuelCategory(fc)
	return fuuo
}

// SetNillableFuelCategory sets the "fuel_category" field if the given value is not nil.
func (fuuo *FuelUpUpdateOne) SetNillableFuelCategory(fc *fuelup.FuelCategory) *FuelUpUpdateOne {
	if fc != nil {
		fuuo.SetFuelCategory(*fc)
	}
	return fuuo
}

// SetOctaneRating sets the "octane_rating" field.
func (fuuo *FuelUpUpdateOne) SetOctaneRating(fr fuelup.OctaneRating) *FuelUpUpdateOne {
	fuuo.mutation.SetOctaneRating(fr)
	return fuuo
}

// SetNillableOctaneRating sets the "octane_rating" field if the given value is not nil.
func (fuuo *FuelUpUpdateOne) SetNillableOctaneRating(fr *fuelup.OctaneRating) *FuelUpUpdateOne {
	if fr != nil {
		fuuo.SetOctaneRating(*fr)
	}
	return fuuo
}

// ClearOctaneRating clears the value of the "octane_rating" field.
func (fuuo *FuelUpUpdateOne) ClearOctaneRating() *FuelUpUpdateOne {
	fuuo.mutation.ClearOctaneRating()
	return fuuo
}

// SetIsFullTank sets the "is_full_tank" field.
func (fuuo *FuelUpUpdateOne) SetIsFullTank(b bool) *FuelUpUpdateOne {
	fuuo.mutation.SetIsFullTank(b)
	return fuuo
}

// SetNillableIsFullTank sets the "is_full_tank" field if the given value is not nil.
func (fuuo *FuelUpUpdateOne) SetNillableIsFullTank(b *bool) *FuelUpUpdateOne {
	if b != nil {
		fuuo.SetIsFullTank(*b)
	}
	return fuuo
}

// SetNotes sets the "notes" field.
func (fuuo *FuelUpUpdateOne) SetNotes(s string) *FuelUpUpdateOne {
	fuuo.mutation.SetNotes(s)
	return fuuo
}

// SetNillableNotes sets the "notes" field if the given value is not nil.
func (fuuo *FuelUpUpdateOne) SetNillableNotes(s *string) *FuelUpUpdateOne {
	if s != nil {
		fuuo.SetNotes(*s)
	}
	return fuuo
}

// ClearNotes clears the value of the "notes" field.
func (fuuo *FuelUpUpdateOne) ClearNotes() *FuelUpUpdateOne {
	fuuo.mutation.ClearNotes()
	return fuuo
}

// SetCarID sets the "car" edge to the Car entity by ID.
func (fuuo *FuelUpUpdateOne) SetCarID(id uuid.UUID) *FuelUpUpdateOne {
	fuuo.mutation.SetCarID(id)
	return fuuo
}

// SetCar sets the "car" edge to the Car entity.
func (fuuo *FuelUpUpdateOne) SetCar(c *Car) *FuelUpUpdateOne {
	return fuuo.SetCarID(c.ID)
}

// SetOdometerReadingID sets the "odometer_reading" edge to the OdometerReading entity by ID.
func (fuuo *FuelUpUpdateOne) SetOdometerReadingID(id uuid.UUID) *FuelUpUpdateOne {
	fuuo.mutation.SetOdometerReadingID(id)
	return fuuo
}

// SetNillableOdometerReadingID sets the "odometer_reading" edge to the OdometerReading entity by ID if the given value is not nil.
func (fuuo *FuelUpUpdateOne) SetNillableOdometerReadingID(id *uuid.UUID) *FuelUpUpdateOne {
	if id != nil {
		fuuo = fuuo.SetOdometerReadingID(*id)
	}
	return fuuo
}

// SetOdometerReading sets the "odometer_reading" edge to the OdometerReading entity.
func (fuuo *FuelUpUpdateOne) SetOdometerReading(o *OdometerReading) *FuelUpUpdateOne {
	return fuuo.SetOdometerReadingID(o.ID)
}

// SetExpenseID sets the "expense" edge to the Expense entity by ID.
func (fuuo *FuelUpUpdateOne) SetExpenseID(id uuid.UUID) *FuelUpUpdateOne {
	fuuo.mutation.SetExpenseID(id)
	return fuuo
}

// SetNillableExpenseID sets the "expense" edge to the Expense entity by ID if the given value is not nil.
func (fuuo *FuelUpUpdateOne) SetNillableExpenseID(id *uuid.UUID) *FuelUpUpdateOne {
	if id != nil {
		fuuo = fuuo.SetExpenseID(*id)
	}
	return fuuo
}

// SetExpense sets the "expense" edge to the Expense entity.
func (fuuo *FuelUpUpdateOne) SetExpense(e *Expense) *FuelUpUpdateOne {
	return fuuo.SetExpenseID(e.ID)
}

// Mutation returns the FuelUpMutation object of the builder.
func (fuuo *FuelUpUpdateOne) Mutation() *FuelUpMutation {
	return fuuo.mutation
}

// ClearCar clears the "car" edge to the Car entity.
func (fuuo *FuelUpUpdateOne) ClearCar() *FuelUpUpdateOne {
	fuuo.mutation.ClearCar()
	return fuuo
}

// ClearOdometerReading clears the "odometer_reading" edge to the OdometerReading entity.
func (fuuo *FuelUpUpdateOne) ClearOdometerReading() *FuelUpUpdateOne {
	fuuo.mutation.ClearOdometerReading()
	return fuuo
}

// ClearExpense clears the "expense" edge to the Expense entity.
func (fuuo *FuelUpUpdateOne) ClearExpense() *FuelUpUpdateOne {
	fuuo.mutation.ClearExpense()
	return fuuo
}

// Where appends a list predicates to the FuelUpUpdate builder.
func (fuuo *FuelUpUpdateOne) Where(ps ...predicate.FuelUp) *FuelUpUpdateOne {
	fuuo.mutation.Where(ps...)
	return fuuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (fuuo *FuelUpUpdateOne) Select(field string, fields ...string) *FuelUpUpdateOne {
	fuuo.fields = append([]string{field}, fields...)
	return fuuo
}

// Save executes the query and returns the updated FuelUp entity.
func (fuuo *FuelUpUpdateOne) Save(ctx context.Context) (*FuelUp, error) {
	fuuo.defaults()
	return withHooks(ctx, fuuo.sqlSave, fuuo.mutation, fuuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (fuuo *FuelUpUpdateOne) SaveX(ctx context.Context) *FuelUp {
	node, err := fuuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (fuuo *FuelUpUpdateOne) Exec(ctx context.Context) error {
	_, err := fuuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (fuuo *FuelUpUpdateOne) ExecX(ctx context.Context) {
	if err := fuuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (fuuo *FuelUpUpdateOne) defaults() {
	if _, ok := fuuo.mutation.UpdateTime(); !ok {
		v := fuelup.UpdateDefaultUpdateTime()
		fuuo.mutation.SetUpdateTime(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (fuuo *FuelUpUpdateOne) check() error {
	if v, ok := fuuo.mutation.FuelCategory(); ok {
		if err := fuelup.FuelCategoryValidator(v); err != nil {
			return &ValidationError{Name: "fuel_category", err: fmt.Errorf(`ent: validator failed for field "FuelUp.fuel_category": %w`, err)}
		}
	}
	if v, ok := fuuo.mutation.OctaneRating(); ok {
		if err := fuelup.OctaneRatingValidator(v); err != nil {
			return &ValidationError{Name: "octane_rating", err: fmt.Errorf(`ent: validator failed for field "FuelUp.octane_rating": %w`, err)}
		}
	}
	if fuuo.mutation.CarCleared() && len(fuuo.mutation.CarIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "FuelUp.car"`)
	}
	return nil
}

func (fuuo *FuelUpUpdateOne) sqlSave(ctx context.Context) (_node *FuelUp, err error) {
	if err := fuuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(fuelup.Table, fuelup.Columns, sqlgraph.NewFieldSpec(fuelup.FieldID, field.TypeUUID))
	id, ok := fuuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "FuelUp.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := fuuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, fuelup.FieldID)
		for _, f := range fields {
			if !fuelup.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != fuelup.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := fuuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := fuuo.mutation.UpdateTime(); ok {
		_spec.SetField(fuelup.FieldUpdateTime, field.TypeTime, value)
	}
	if value, ok := fuuo.mutation.OccurredAt(); ok {
		_spec.SetField(fuelup.FieldOccurredAt, field.TypeTime, value)
	}
	if value, ok := fuuo.mutation.Station(); ok {
		_spec.SetField(fuelup.FieldStation, field.TypeString, value)
	}
	if value, ok := fuuo.mutation.AmountLiters(); ok {
		_spec.SetField(fuelup.FieldAmountLiters, field.TypeFloat64, value)
	}
	if value, ok := fuuo.mutation.AddedAmountLiters(); ok {
		_spec.AddField(fuelup.FieldAmountLiters, field.TypeFloat64, value)
	}
	if value, ok := fuuo.mutation.FuelCategory(); ok {
		_spec.SetField(fuelup.FieldFuelCategory, field.TypeEnum, value)
	}
	if value, ok := fuuo.mutation.OctaneRating(); ok {
		_spec.SetField(fuelup.FieldOctaneRating, field.TypeEnum, value)
	}
	if fuuo.mutation.OctaneRatingCleared() {
		_spec.ClearField(fuelup.FieldOctaneRating, field.TypeEnum)
	}
	if value, ok := fuuo.mutation.IsFullTank(); ok {
		_spec.SetField(fuelup.FieldIsFullTank, field.TypeBool, value)
	}
	if value, ok := fuuo.mutation.Notes(); ok {
		_spec.SetField(fuelup.FieldNotes, field.TypeString, value)
	}
	if fuuo.mutation.NotesCleared() {
		_spec.ClearField(fuelup.FieldNotes, field.TypeString)
	}
	if fuuo.mutation.CarCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   fuelup.CarTable,
			Columns: []string{fuelup.CarColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(car.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := fuuo.mutation.CarIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   fuelup.CarTable,
			Columns: []string{fuelup.CarColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(car.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if fuuo.mutation.OdometerReadingCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   fuelup.OdometerReadingTable,
			Columns: []string{fuelup.OdometerReadingColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(odometerreading.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := fuuo.mutation.OdometerReadingIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   fuelup.OdometerReadingTable,
			Columns: []string{fuelup.OdometerReadingColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(odometerreading.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if fuuo.mutation.ExpenseCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   fuelup.ExpenseTable,
			Columns: []string{fuelup.ExpenseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(expense.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := fuuo.mutation.ExpenseIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   fuelup.ExpenseTable,
			Columns: []string{fuelup.ExpenseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(expense.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &FuelUp{config: fuuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, fuuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{fuelup.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	fuuo.mutation.done = true
	return _node, nil
}

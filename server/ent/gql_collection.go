// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"database/sql/driver"
	"fmt"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/Dan6erbond/revline/ent/album"
	"github.com/Dan6erbond/revline/ent/buildlog"
	"github.com/Dan6erbond/revline/ent/car"
	"github.com/Dan6erbond/revline/ent/checkoutsession"
	"github.com/Dan6erbond/revline/ent/document"
	"github.com/Dan6erbond/revline/ent/dragresult"
	"github.com/Dan6erbond/revline/ent/dragsession"
	"github.com/Dan6erbond/revline/ent/dynoresult"
	"github.com/Dan6erbond/revline/ent/dynosession"
	"github.com/Dan6erbond/revline/ent/expense"
	"github.com/Dan6erbond/revline/ent/fuelup"
	"github.com/Dan6erbond/revline/ent/media"
	"github.com/Dan6erbond/revline/ent/mod"
	"github.com/Dan6erbond/revline/ent/modproductoption"
	"github.com/Dan6erbond/revline/ent/odometerreading"
	"github.com/Dan6erbond/revline/ent/profile"
	"github.com/Dan6erbond/revline/ent/serviceitem"
	"github.com/Dan6erbond/revline/ent/servicelog"
	"github.com/Dan6erbond/revline/ent/serviceschedule"
	"github.com/Dan6erbond/revline/ent/subscription"
	"github.com/Dan6erbond/revline/ent/task"
	"github.com/Dan6erbond/revline/ent/user"
	"github.com/Dan6erbond/revline/ent/usersettings"
	"github.com/google/uuid"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (a *AlbumQuery) CollectFields(ctx context.Context, satisfies ...string) (*AlbumQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return a, nil
	}
	if err := a.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return a, nil
}

func (a *AlbumQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(album.Columns))
		selectedFields = []string{album.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "car":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carImplementors)...); err != nil {
				return err
			}
			a.withCar = query

		case "media":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MediaClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, mediaImplementors)...); err != nil {
				return err
			}
			a.WithNamedMedia(alias, func(wq *MediaQuery) {
				*wq = *query
			})
		case "createTime":
			if _, ok := fieldSeen[album.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, album.FieldCreateTime)
				fieldSeen[album.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[album.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, album.FieldUpdateTime)
				fieldSeen[album.FieldUpdateTime] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[album.FieldTitle]; !ok {
				selectedFields = append(selectedFields, album.FieldTitle)
				fieldSeen[album.FieldTitle] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		a.Select(selectedFields...)
	}
	return nil
}

type albumPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AlbumPaginateOption
}

func newAlbumPaginateArgs(rv map[string]any) *albumPaginateArgs {
	args := &albumPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*AlbumWhereInput); ok {
		args.opts = append(args.opts, WithAlbumFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (bl *BuildLogQuery) CollectFields(ctx context.Context, satisfies ...string) (*BuildLogQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return bl, nil
	}
	if err := bl.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return bl, nil
}

func (bl *BuildLogQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(buildlog.Columns))
		selectedFields = []string{buildlog.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "car":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarClient{config: bl.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carImplementors)...); err != nil {
				return err
			}
			bl.withCar = query

		case "mods":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ModClient{config: bl.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, modImplementors)...); err != nil {
				return err
			}
			bl.WithNamedMods(alias, func(wq *ModQuery) {
				*wq = *query
			})

		case "media":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MediaClient{config: bl.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, mediaImplementors)...); err != nil {
				return err
			}
			bl.WithNamedMedia(alias, func(wq *MediaQuery) {
				*wq = *query
			})
		case "createTime":
			if _, ok := fieldSeen[buildlog.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, buildlog.FieldCreateTime)
				fieldSeen[buildlog.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[buildlog.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, buildlog.FieldUpdateTime)
				fieldSeen[buildlog.FieldUpdateTime] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[buildlog.FieldTitle]; !ok {
				selectedFields = append(selectedFields, buildlog.FieldTitle)
				fieldSeen[buildlog.FieldTitle] = struct{}{}
			}
		case "notes":
			if _, ok := fieldSeen[buildlog.FieldNotes]; !ok {
				selectedFields = append(selectedFields, buildlog.FieldNotes)
				fieldSeen[buildlog.FieldNotes] = struct{}{}
			}
		case "logTime":
			if _, ok := fieldSeen[buildlog.FieldLogTime]; !ok {
				selectedFields = append(selectedFields, buildlog.FieldLogTime)
				fieldSeen[buildlog.FieldLogTime] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		bl.Select(selectedFields...)
	}
	return nil
}

type buildlogPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BuildLogPaginateOption
}

func newBuildLogPaginateArgs(rv map[string]any) *buildlogPaginateArgs {
	args := &buildlogPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*BuildLogOrder:
			args.opts = append(args.opts, WithBuildLogOrder(v))
		case []any:
			var orders []*BuildLogOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &BuildLogOrder{Field: &BuildLogOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithBuildLogOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*BuildLogWhereInput); ok {
		args.opts = append(args.opts, WithBuildLogFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CarQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CarQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(car.Columns))
		selectedFields = []string{car.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			c.withOwner = query

		case "dragSessions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DragSessionClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, dragsessionImplementors)...); err != nil {
				return err
			}
			c.WithNamedDragSessions(alias, func(wq *DragSessionQuery) {
				*wq = *query
			})

		case "fuelUps":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FuelUpClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, fuelupImplementors)...); err != nil {
				return err
			}
			c.WithNamedFuelUps(alias, func(wq *FuelUpQuery) {
				*wq = *query
			})

		case "odometerReadings":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OdometerReadingClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, odometerreadingImplementors)...); err != nil {
				return err
			}
			c.WithNamedOdometerReadings(alias, func(wq *OdometerReadingQuery) {
				*wq = *query
			})

		case "serviceItems":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServiceItemClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, serviceitemImplementors)...); err != nil {
				return err
			}
			c.WithNamedServiceItems(alias, func(wq *ServiceItemQuery) {
				*wq = *query
			})

		case "serviceLogs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServiceLogClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, servicelogImplementors)...); err != nil {
				return err
			}
			c.WithNamedServiceLogs(alias, func(wq *ServiceLogQuery) {
				*wq = *query
			})

		case "serviceSchedules":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServiceScheduleClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, servicescheduleImplementors)...); err != nil {
				return err
			}
			c.WithNamedServiceSchedules(alias, func(wq *ServiceScheduleQuery) {
				*wq = *query
			})

		case "media":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MediaClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, mediaImplementors)...); err != nil {
				return err
			}
			c.WithNamedMedia(alias, func(wq *MediaQuery) {
				*wq = *query
			})

		case "albums":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AlbumClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, albumImplementors)...); err != nil {
				return err
			}
			c.WithNamedAlbums(alias, func(wq *AlbumQuery) {
				*wq = *query
			})

		case "documents":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, documentImplementors)...); err != nil {
				return err
			}
			c.WithNamedDocuments(alias, func(wq *DocumentQuery) {
				*wq = *query
			})

		case "dynoSessions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DynoSessionClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, dynosessionImplementors)...); err != nil {
				return err
			}
			c.WithNamedDynoSessions(alias, func(wq *DynoSessionQuery) {
				*wq = *query
			})

		case "expenses":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ExpenseClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, expenseImplementors)...); err != nil {
				return err
			}
			c.WithNamedExpenses(alias, func(wq *ExpenseQuery) {
				*wq = *query
			})

		case "buildLogs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildLogClient{config: c.config}).Query()
			)
			args := newBuildLogPaginateArgs(fieldArgs(ctx, new(BuildLogWhereInput), path...))
			if err := validateFirstLast(args.first, args.last); err != nil {
				return fmt.Errorf("validate first and last in path %q: %w", path, err)
			}
			pager, err := newBuildLogPager(args.opts, args.last != nil)
			if err != nil {
				return fmt.Errorf("create new pager in path %q: %w", path, err)
			}
			if query, err = pager.applyFilter(query); err != nil {
				return err
			}
			ignoredEdges := !hasCollectedField(ctx, append(path, edgesField)...)
			if hasCollectedField(ctx, append(path, totalCountField)...) || hasCollectedField(ctx, append(path, pageInfoField)...) {
				hasPagination := args.after != nil || args.first != nil || args.before != nil || args.last != nil
				if hasPagination || ignoredEdges {
					query := query.Clone()
					c.loadTotal = append(c.loadTotal, func(ctx context.Context, nodes []*Car) error {
						ids := make([]driver.Value, len(nodes))
						for i := range nodes {
							ids[i] = nodes[i].ID
						}
						var v []struct {
							NodeID uuid.UUID `sql:"car_build_logs"`
							Count  int       `sql:"count"`
						}
						query.Where(func(s *sql.Selector) {
							s.Where(sql.InValues(s.C(car.BuildLogsColumn), ids...))
						})
						if err := query.GroupBy(car.BuildLogsColumn).Aggregate(Count()).Scan(ctx, &v); err != nil {
							return err
						}
						m := make(map[uuid.UUID]int, len(v))
						for i := range v {
							m[v[i].NodeID] = v[i].Count
						}
						for i := range nodes {
							n := m[nodes[i].ID]
							if nodes[i].Edges.totalCount[12] == nil {
								nodes[i].Edges.totalCount[12] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[12][alias] = n
						}
						return nil
					})
				} else {
					c.loadTotal = append(c.loadTotal, func(_ context.Context, nodes []*Car) error {
						for i := range nodes {
							n := len(nodes[i].Edges.BuildLogs)
							if nodes[i].Edges.totalCount[12] == nil {
								nodes[i].Edges.totalCount[12] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[12][alias] = n
						}
						return nil
					})
				}
			}
			if ignoredEdges || (args.first != nil && *args.first == 0) || (args.last != nil && *args.last == 0) {
				continue
			}
			if query, err = pager.applyCursors(query, args.after, args.before); err != nil {
				return err
			}
			path = append(path, edgesField, nodeField)
			if field := collectedField(ctx, path...); field != nil {
				if err := query.collectField(ctx, false, opCtx, *field, path, mayAddCondition(satisfies, buildlogImplementors)...); err != nil {
					return err
				}
			}
			if limit := paginateLimit(args.first, args.last); limit > 0 {
				if oneNode {
					pager.applyOrder(query.Limit(limit))
				} else {
					modify := entgql.LimitPerRow(car.BuildLogsColumn, limit, pager.orderExpr(query))
					query.modifiers = append(query.modifiers, modify)
				}
			} else {
				query = pager.applyOrder(query)
			}
			c.WithNamedBuildLogs(alias, func(wq *BuildLogQuery) {
				*wq = *query
			})

		case "bannerImage":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MediaClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, mediaImplementors)...); err != nil {
				return err
			}
			c.withBannerImage = query

		case "tasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TaskClient{config: c.config}).Query()
			)
			args := newTaskPaginateArgs(fieldArgs(ctx, new(TaskWhereInput), path...))
			if err := validateFirstLast(args.first, args.last); err != nil {
				return fmt.Errorf("validate first and last in path %q: %w", path, err)
			}
			pager, err := newTaskPager(args.opts, args.last != nil)
			if err != nil {
				return fmt.Errorf("create new pager in path %q: %w", path, err)
			}
			if query, err = pager.applyFilter(query); err != nil {
				return err
			}
			ignoredEdges := !hasCollectedField(ctx, append(path, edgesField)...)
			if hasCollectedField(ctx, append(path, totalCountField)...) || hasCollectedField(ctx, append(path, pageInfoField)...) {
				hasPagination := args.after != nil || args.first != nil || args.before != nil || args.last != nil
				if hasPagination || ignoredEdges {
					query := query.Clone()
					c.loadTotal = append(c.loadTotal, func(ctx context.Context, nodes []*Car) error {
						ids := make([]driver.Value, len(nodes))
						for i := range nodes {
							ids[i] = nodes[i].ID
						}
						var v []struct {
							NodeID uuid.UUID `sql:"car_tasks"`
							Count  int       `sql:"count"`
						}
						query.Where(func(s *sql.Selector) {
							s.Where(sql.InValues(s.C(car.TasksColumn), ids...))
						})
						if err := query.GroupBy(car.TasksColumn).Aggregate(Count()).Scan(ctx, &v); err != nil {
							return err
						}
						m := make(map[uuid.UUID]int, len(v))
						for i := range v {
							m[v[i].NodeID] = v[i].Count
						}
						for i := range nodes {
							n := m[nodes[i].ID]
							if nodes[i].Edges.totalCount[14] == nil {
								nodes[i].Edges.totalCount[14] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[14][alias] = n
						}
						return nil
					})
				} else {
					c.loadTotal = append(c.loadTotal, func(_ context.Context, nodes []*Car) error {
						for i := range nodes {
							n := len(nodes[i].Edges.Tasks)
							if nodes[i].Edges.totalCount[14] == nil {
								nodes[i].Edges.totalCount[14] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[14][alias] = n
						}
						return nil
					})
				}
			}
			if ignoredEdges || (args.first != nil && *args.first == 0) || (args.last != nil && *args.last == 0) {
				continue
			}
			if query, err = pager.applyCursors(query, args.after, args.before); err != nil {
				return err
			}
			path = append(path, edgesField, nodeField)
			if field := collectedField(ctx, path...); field != nil {
				if err := query.collectField(ctx, false, opCtx, *field, path, mayAddCondition(satisfies, taskImplementors)...); err != nil {
					return err
				}
			}
			if limit := paginateLimit(args.first, args.last); limit > 0 {
				if oneNode {
					pager.applyOrder(query.Limit(limit))
				} else {
					modify := entgql.LimitPerRow(car.TasksColumn, limit, pager.orderExpr(query))
					query.modifiers = append(query.modifiers, modify)
				}
			} else {
				query = pager.applyOrder(query)
			}
			c.WithNamedTasks(alias, func(wq *TaskQuery) {
				*wq = *query
			})

		case "mods":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ModClient{config: c.config}).Query()
			)
			args := newModPaginateArgs(fieldArgs(ctx, new(ModWhereInput), path...))
			if err := validateFirstLast(args.first, args.last); err != nil {
				return fmt.Errorf("validate first and last in path %q: %w", path, err)
			}
			pager, err := newModPager(args.opts, args.last != nil)
			if err != nil {
				return fmt.Errorf("create new pager in path %q: %w", path, err)
			}
			if query, err = pager.applyFilter(query); err != nil {
				return err
			}
			ignoredEdges := !hasCollectedField(ctx, append(path, edgesField)...)
			if hasCollectedField(ctx, append(path, totalCountField)...) || hasCollectedField(ctx, append(path, pageInfoField)...) {
				hasPagination := args.after != nil || args.first != nil || args.before != nil || args.last != nil
				if hasPagination || ignoredEdges {
					query := query.Clone()
					c.loadTotal = append(c.loadTotal, func(ctx context.Context, nodes []*Car) error {
						ids := make([]driver.Value, len(nodes))
						for i := range nodes {
							ids[i] = nodes[i].ID
						}
						var v []struct {
							NodeID uuid.UUID `sql:"car_mods"`
							Count  int       `sql:"count"`
						}
						query.Where(func(s *sql.Selector) {
							s.Where(sql.InValues(s.C(car.ModsColumn), ids...))
						})
						if err := query.GroupBy(car.ModsColumn).Aggregate(Count()).Scan(ctx, &v); err != nil {
							return err
						}
						m := make(map[uuid.UUID]int, len(v))
						for i := range v {
							m[v[i].NodeID] = v[i].Count
						}
						for i := range nodes {
							n := m[nodes[i].ID]
							if nodes[i].Edges.totalCount[15] == nil {
								nodes[i].Edges.totalCount[15] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[15][alias] = n
						}
						return nil
					})
				} else {
					c.loadTotal = append(c.loadTotal, func(_ context.Context, nodes []*Car) error {
						for i := range nodes {
							n := len(nodes[i].Edges.Mods)
							if nodes[i].Edges.totalCount[15] == nil {
								nodes[i].Edges.totalCount[15] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[15][alias] = n
						}
						return nil
					})
				}
			}
			if ignoredEdges || (args.first != nil && *args.first == 0) || (args.last != nil && *args.last == 0) {
				continue
			}
			if query, err = pager.applyCursors(query, args.after, args.before); err != nil {
				return err
			}
			path = append(path, edgesField, nodeField)
			if field := collectedField(ctx, path...); field != nil {
				if err := query.collectField(ctx, false, opCtx, *field, path, mayAddCondition(satisfies, modImplementors)...); err != nil {
					return err
				}
			}
			if limit := paginateLimit(args.first, args.last); limit > 0 {
				if oneNode {
					pager.applyOrder(query.Limit(limit))
				} else {
					modify := entgql.LimitPerRow(car.ModsColumn, limit, pager.orderExpr(query))
					query.modifiers = append(query.modifiers, modify)
				}
			} else {
				query = pager.applyOrder(query)
			}
			c.WithNamedMods(alias, func(wq *ModQuery) {
				*wq = *query
			})
		case "createTime":
			if _, ok := fieldSeen[car.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, car.FieldCreateTime)
				fieldSeen[car.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[car.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, car.FieldUpdateTime)
				fieldSeen[car.FieldUpdateTime] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[car.FieldName]; !ok {
				selectedFields = append(selectedFields, car.FieldName)
				fieldSeen[car.FieldName] = struct{}{}
			}
		case "make":
			if _, ok := fieldSeen[car.FieldMake]; !ok {
				selectedFields = append(selectedFields, car.FieldMake)
				fieldSeen[car.FieldMake] = struct{}{}
			}
		case "model":
			if _, ok := fieldSeen[car.FieldModel]; !ok {
				selectedFields = append(selectedFields, car.FieldModel)
				fieldSeen[car.FieldModel] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[car.FieldType]; !ok {
				selectedFields = append(selectedFields, car.FieldType)
				fieldSeen[car.FieldType] = struct{}{}
			}
		case "year":
			if _, ok := fieldSeen[car.FieldYear]; !ok {
				selectedFields = append(selectedFields, car.FieldYear)
				fieldSeen[car.FieldYear] = struct{}{}
			}
		case "trim":
			if _, ok := fieldSeen[car.FieldTrim]; !ok {
				selectedFields = append(selectedFields, car.FieldTrim)
				fieldSeen[car.FieldTrim] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type carPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarPaginateOption
}

func newCarPaginateArgs(rv map[string]any) *carPaginateArgs {
	args := &carPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarWhereInput); ok {
		args.opts = append(args.opts, WithCarFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cs *CheckoutSessionQuery) CollectFields(ctx context.Context, satisfies ...string) (*CheckoutSessionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cs, nil
	}
	if err := cs.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cs, nil
}

func (cs *CheckoutSessionQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(checkoutsession.Columns))
		selectedFields = []string{checkoutsession.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			cs.withUser = query

		case "subscription":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SubscriptionClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, subscriptionImplementors)...); err != nil {
				return err
			}
			cs.withSubscription = query
		case "createTime":
			if _, ok := fieldSeen[checkoutsession.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, checkoutsession.FieldCreateTime)
				fieldSeen[checkoutsession.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[checkoutsession.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, checkoutsession.FieldUpdateTime)
				fieldSeen[checkoutsession.FieldUpdateTime] = struct{}{}
			}
		case "stripeSessionID":
			if _, ok := fieldSeen[checkoutsession.FieldStripeSessionID]; !ok {
				selectedFields = append(selectedFields, checkoutsession.FieldStripeSessionID)
				fieldSeen[checkoutsession.FieldStripeSessionID] = struct{}{}
			}
		case "stripePriceID":
			if _, ok := fieldSeen[checkoutsession.FieldStripePriceID]; !ok {
				selectedFields = append(selectedFields, checkoutsession.FieldStripePriceID)
				fieldSeen[checkoutsession.FieldStripePriceID] = struct{}{}
			}
		case "mode":
			if _, ok := fieldSeen[checkoutsession.FieldMode]; !ok {
				selectedFields = append(selectedFields, checkoutsession.FieldMode)
				fieldSeen[checkoutsession.FieldMode] = struct{}{}
			}
		case "completed":
			if _, ok := fieldSeen[checkoutsession.FieldCompleted]; !ok {
				selectedFields = append(selectedFields, checkoutsession.FieldCompleted)
				fieldSeen[checkoutsession.FieldCompleted] = struct{}{}
			}
		case "completedAt":
			if _, ok := fieldSeen[checkoutsession.FieldCompletedAt]; !ok {
				selectedFields = append(selectedFields, checkoutsession.FieldCompletedAt)
				fieldSeen[checkoutsession.FieldCompletedAt] = struct{}{}
			}
		case "affiliate6moCode":
			if _, ok := fieldSeen[checkoutsession.FieldAffiliate6moCode]; !ok {
				selectedFields = append(selectedFields, checkoutsession.FieldAffiliate6moCode)
				fieldSeen[checkoutsession.FieldAffiliate6moCode] = struct{}{}
			}
		case "affiliate12moCode":
			if _, ok := fieldSeen[checkoutsession.FieldAffiliate12moCode]; !ok {
				selectedFields = append(selectedFields, checkoutsession.FieldAffiliate12moCode)
				fieldSeen[checkoutsession.FieldAffiliate12moCode] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cs.Select(selectedFields...)
	}
	return nil
}

type checkoutsessionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CheckoutSessionPaginateOption
}

func newCheckoutSessionPaginateArgs(rv map[string]any) *checkoutsessionPaginateArgs {
	args := &checkoutsessionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CheckoutSessionWhereInput); ok {
		args.opts = append(args.opts, WithCheckoutSessionFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (d *DocumentQuery) CollectFields(ctx context.Context, satisfies ...string) (*DocumentQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return d, nil
	}
	if err := d.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return d, nil
}

func (d *DocumentQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(document.Columns))
		selectedFields = []string{document.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "car":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carImplementors)...); err != nil {
				return err
			}
			d.withCar = query

		case "expense":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ExpenseClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, expenseImplementors)...); err != nil {
				return err
			}
			d.withExpense = query

		case "fuelUp":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FuelUpClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, fuelupImplementors)...); err != nil {
				return err
			}
			d.withFuelUp = query

		case "serviceLog":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServiceLogClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, servicelogImplementors)...); err != nil {
				return err
			}
			d.withServiceLog = query

		case "dragSession":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DragSessionClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, dragsessionImplementors)...); err != nil {
				return err
			}
			d.withDragSession = query

		case "dynoSession":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DynoSessionClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, dynosessionImplementors)...); err != nil {
				return err
			}
			d.withDynoSession = query
		case "createTime":
			if _, ok := fieldSeen[document.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, document.FieldCreateTime)
				fieldSeen[document.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[document.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, document.FieldUpdateTime)
				fieldSeen[document.FieldUpdateTime] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[document.FieldName]; !ok {
				selectedFields = append(selectedFields, document.FieldName)
				fieldSeen[document.FieldName] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[document.FieldTags]; !ok {
				selectedFields = append(selectedFields, document.FieldTags)
				fieldSeen[document.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		d.Select(selectedFields...)
	}
	return nil
}

type documentPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DocumentPaginateOption
}

func newDocumentPaginateArgs(rv map[string]any) *documentPaginateArgs {
	args := &documentPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DocumentWhereInput); ok {
		args.opts = append(args.opts, WithDocumentFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (dr *DragResultQuery) CollectFields(ctx context.Context, satisfies ...string) (*DragResultQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return dr, nil
	}
	if err := dr.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return dr, nil
}

func (dr *DragResultQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(dragresult.Columns))
		selectedFields = []string{dragresult.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "session":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DragSessionClient{config: dr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, dragsessionImplementors)...); err != nil {
				return err
			}
			dr.withSession = query
		case "createTime":
			if _, ok := fieldSeen[dragresult.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, dragresult.FieldCreateTime)
				fieldSeen[dragresult.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[dragresult.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, dragresult.FieldUpdateTime)
				fieldSeen[dragresult.FieldUpdateTime] = struct{}{}
			}
		case "unit":
			if _, ok := fieldSeen[dragresult.FieldUnit]; !ok {
				selectedFields = append(selectedFields, dragresult.FieldUnit)
				fieldSeen[dragresult.FieldUnit] = struct{}{}
			}
		case "value":
			if _, ok := fieldSeen[dragresult.FieldValue]; !ok {
				selectedFields = append(selectedFields, dragresult.FieldValue)
				fieldSeen[dragresult.FieldValue] = struct{}{}
			}
		case "result":
			if _, ok := fieldSeen[dragresult.FieldResult]; !ok {
				selectedFields = append(selectedFields, dragresult.FieldResult)
				fieldSeen[dragresult.FieldResult] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		dr.Select(selectedFields...)
	}
	return nil
}

type dragresultPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DragResultPaginateOption
}

func newDragResultPaginateArgs(rv map[string]any) *dragresultPaginateArgs {
	args := &dragresultPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DragResultWhereInput); ok {
		args.opts = append(args.opts, WithDragResultFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ds *DragSessionQuery) CollectFields(ctx context.Context, satisfies ...string) (*DragSessionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ds, nil
	}
	if err := ds.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ds, nil
}

func (ds *DragSessionQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(dragsession.Columns))
		selectedFields = []string{dragsession.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "car":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarClient{config: ds.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carImplementors)...); err != nil {
				return err
			}
			ds.withCar = query

		case "results":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DragResultClient{config: ds.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, dragresultImplementors)...); err != nil {
				return err
			}
			ds.WithNamedResults(alias, func(wq *DragResultQuery) {
				*wq = *query
			})

		case "documents":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentClient{config: ds.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, documentImplementors)...); err != nil {
				return err
			}
			ds.WithNamedDocuments(alias, func(wq *DocumentQuery) {
				*wq = *query
			})
		case "createTime":
			if _, ok := fieldSeen[dragsession.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, dragsession.FieldCreateTime)
				fieldSeen[dragsession.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[dragsession.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, dragsession.FieldUpdateTime)
				fieldSeen[dragsession.FieldUpdateTime] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[dragsession.FieldTitle]; !ok {
				selectedFields = append(selectedFields, dragsession.FieldTitle)
				fieldSeen[dragsession.FieldTitle] = struct{}{}
			}
		case "notes":
			if _, ok := fieldSeen[dragsession.FieldNotes]; !ok {
				selectedFields = append(selectedFields, dragsession.FieldNotes)
				fieldSeen[dragsession.FieldNotes] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ds.Select(selectedFields...)
	}
	return nil
}

type dragsessionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DragSessionPaginateOption
}

func newDragSessionPaginateArgs(rv map[string]any) *dragsessionPaginateArgs {
	args := &dragsessionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DragSessionWhereInput); ok {
		args.opts = append(args.opts, WithDragSessionFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (dr *DynoResultQuery) CollectFields(ctx context.Context, satisfies ...string) (*DynoResultQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return dr, nil
	}
	if err := dr.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return dr, nil
}

func (dr *DynoResultQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(dynoresult.Columns))
		selectedFields = []string{dynoresult.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "session":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DynoSessionClient{config: dr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, dynosessionImplementors)...); err != nil {
				return err
			}
			dr.withSession = query
		case "createTime":
			if _, ok := fieldSeen[dynoresult.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, dynoresult.FieldCreateTime)
				fieldSeen[dynoresult.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[dynoresult.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, dynoresult.FieldUpdateTime)
				fieldSeen[dynoresult.FieldUpdateTime] = struct{}{}
			}
		case "rpm":
			if _, ok := fieldSeen[dynoresult.FieldRpm]; !ok {
				selectedFields = append(selectedFields, dynoresult.FieldRpm)
				fieldSeen[dynoresult.FieldRpm] = struct{}{}
			}
		case "powerKw":
			if _, ok := fieldSeen[dynoresult.FieldPowerKw]; !ok {
				selectedFields = append(selectedFields, dynoresult.FieldPowerKw)
				fieldSeen[dynoresult.FieldPowerKw] = struct{}{}
			}
		case "torqueNm":
			if _, ok := fieldSeen[dynoresult.FieldTorqueNm]; !ok {
				selectedFields = append(selectedFields, dynoresult.FieldTorqueNm)
				fieldSeen[dynoresult.FieldTorqueNm] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		dr.Select(selectedFields...)
	}
	return nil
}

type dynoresultPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DynoResultPaginateOption
}

func newDynoResultPaginateArgs(rv map[string]any) *dynoresultPaginateArgs {
	args := &dynoresultPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DynoResultWhereInput); ok {
		args.opts = append(args.opts, WithDynoResultFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ds *DynoSessionQuery) CollectFields(ctx context.Context, satisfies ...string) (*DynoSessionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ds, nil
	}
	if err := ds.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ds, nil
}

func (ds *DynoSessionQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(dynosession.Columns))
		selectedFields = []string{dynosession.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "car":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarClient{config: ds.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carImplementors)...); err != nil {
				return err
			}
			ds.withCar = query

		case "results":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DynoResultClient{config: ds.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, dynoresultImplementors)...); err != nil {
				return err
			}
			ds.WithNamedResults(alias, func(wq *DynoResultQuery) {
				*wq = *query
			})

		case "documents":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentClient{config: ds.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, documentImplementors)...); err != nil {
				return err
			}
			ds.WithNamedDocuments(alias, func(wq *DocumentQuery) {
				*wq = *query
			})
		case "createTime":
			if _, ok := fieldSeen[dynosession.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, dynosession.FieldCreateTime)
				fieldSeen[dynosession.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[dynosession.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, dynosession.FieldUpdateTime)
				fieldSeen[dynosession.FieldUpdateTime] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[dynosession.FieldTitle]; !ok {
				selectedFields = append(selectedFields, dynosession.FieldTitle)
				fieldSeen[dynosession.FieldTitle] = struct{}{}
			}
		case "notes":
			if _, ok := fieldSeen[dynosession.FieldNotes]; !ok {
				selectedFields = append(selectedFields, dynosession.FieldNotes)
				fieldSeen[dynosession.FieldNotes] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ds.Select(selectedFields...)
	}
	return nil
}

type dynosessionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DynoSessionPaginateOption
}

func newDynoSessionPaginateArgs(rv map[string]any) *dynosessionPaginateArgs {
	args := &dynosessionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DynoSessionWhereInput); ok {
		args.opts = append(args.opts, WithDynoSessionFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (e *ExpenseQuery) CollectFields(ctx context.Context, satisfies ...string) (*ExpenseQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return e, nil
	}
	if err := e.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return e, nil
}

func (e *ExpenseQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(expense.Columns))
		selectedFields = []string{expense.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "car":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carImplementors)...); err != nil {
				return err
			}
			e.withCar = query

		case "fuelUp":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FuelUpClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, fuelupImplementors)...); err != nil {
				return err
			}
			e.withFuelUp = query

		case "serviceLog":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServiceLogClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, servicelogImplementors)...); err != nil {
				return err
			}
			e.withServiceLog = query

		case "documents":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, documentImplementors)...); err != nil {
				return err
			}
			e.WithNamedDocuments(alias, func(wq *DocumentQuery) {
				*wq = *query
			})
		case "createTime":
			if _, ok := fieldSeen[expense.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, expense.FieldCreateTime)
				fieldSeen[expense.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[expense.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, expense.FieldUpdateTime)
				fieldSeen[expense.FieldUpdateTime] = struct{}{}
			}
		case "occurredAt":
			if _, ok := fieldSeen[expense.FieldOccurredAt]; !ok {
				selectedFields = append(selectedFields, expense.FieldOccurredAt)
				fieldSeen[expense.FieldOccurredAt] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[expense.FieldType]; !ok {
				selectedFields = append(selectedFields, expense.FieldType)
				fieldSeen[expense.FieldType] = struct{}{}
			}
		case "amount":
			if _, ok := fieldSeen[expense.FieldAmount]; !ok {
				selectedFields = append(selectedFields, expense.FieldAmount)
				fieldSeen[expense.FieldAmount] = struct{}{}
			}
		case "notes":
			if _, ok := fieldSeen[expense.FieldNotes]; !ok {
				selectedFields = append(selectedFields, expense.FieldNotes)
				fieldSeen[expense.FieldNotes] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		e.Select(selectedFields...)
	}
	return nil
}

type expensePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ExpensePaginateOption
}

func newExpensePaginateArgs(rv map[string]any) *expensePaginateArgs {
	args := &expensePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ExpenseWhereInput); ok {
		args.opts = append(args.opts, WithExpenseFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (fu *FuelUpQuery) CollectFields(ctx context.Context, satisfies ...string) (*FuelUpQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return fu, nil
	}
	if err := fu.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return fu, nil
}

func (fu *FuelUpQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(fuelup.Columns))
		selectedFields = []string{fuelup.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "car":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarClient{config: fu.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carImplementors)...); err != nil {
				return err
			}
			fu.withCar = query

		case "odometerReading":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OdometerReadingClient{config: fu.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, odometerreadingImplementors)...); err != nil {
				return err
			}
			fu.withOdometerReading = query

		case "expense":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ExpenseClient{config: fu.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, expenseImplementors)...); err != nil {
				return err
			}
			fu.withExpense = query

		case "documents":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentClient{config: fu.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, documentImplementors)...); err != nil {
				return err
			}
			fu.WithNamedDocuments(alias, func(wq *DocumentQuery) {
				*wq = *query
			})
		case "createTime":
			if _, ok := fieldSeen[fuelup.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, fuelup.FieldCreateTime)
				fieldSeen[fuelup.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[fuelup.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, fuelup.FieldUpdateTime)
				fieldSeen[fuelup.FieldUpdateTime] = struct{}{}
			}
		case "occurredAt":
			if _, ok := fieldSeen[fuelup.FieldOccurredAt]; !ok {
				selectedFields = append(selectedFields, fuelup.FieldOccurredAt)
				fieldSeen[fuelup.FieldOccurredAt] = struct{}{}
			}
		case "station":
			if _, ok := fieldSeen[fuelup.FieldStation]; !ok {
				selectedFields = append(selectedFields, fuelup.FieldStation)
				fieldSeen[fuelup.FieldStation] = struct{}{}
			}
		case "amountLiters":
			if _, ok := fieldSeen[fuelup.FieldAmountLiters]; !ok {
				selectedFields = append(selectedFields, fuelup.FieldAmountLiters)
				fieldSeen[fuelup.FieldAmountLiters] = struct{}{}
			}
		case "fuelCategory":
			if _, ok := fieldSeen[fuelup.FieldFuelCategory]; !ok {
				selectedFields = append(selectedFields, fuelup.FieldFuelCategory)
				fieldSeen[fuelup.FieldFuelCategory] = struct{}{}
			}
		case "octaneRating":
			if _, ok := fieldSeen[fuelup.FieldOctaneRating]; !ok {
				selectedFields = append(selectedFields, fuelup.FieldOctaneRating)
				fieldSeen[fuelup.FieldOctaneRating] = struct{}{}
			}
		case "isFullTank":
			if _, ok := fieldSeen[fuelup.FieldIsFullTank]; !ok {
				selectedFields = append(selectedFields, fuelup.FieldIsFullTank)
				fieldSeen[fuelup.FieldIsFullTank] = struct{}{}
			}
		case "notes":
			if _, ok := fieldSeen[fuelup.FieldNotes]; !ok {
				selectedFields = append(selectedFields, fuelup.FieldNotes)
				fieldSeen[fuelup.FieldNotes] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		fu.Select(selectedFields...)
	}
	return nil
}

type fuelupPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []FuelUpPaginateOption
}

func newFuelUpPaginateArgs(rv map[string]any) *fuelupPaginateArgs {
	args := &fuelupPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*FuelUpWhereInput); ok {
		args.opts = append(args.opts, WithFuelUpFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (m *MediaQuery) CollectFields(ctx context.Context, satisfies ...string) (*MediaQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return m, nil
	}
	if err := m.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *MediaQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(media.Columns))
		selectedFields = []string{media.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			m.withUser = query

		case "car":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carImplementors)...); err != nil {
				return err
			}
			m.withCar = query

		case "modProductOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ModProductOptionClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, modproductoptionImplementors)...); err != nil {
				return err
			}
			m.withModProductOption = query

		case "buildLog":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildLogClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, buildlogImplementors)...); err != nil {
				return err
			}
			m.WithNamedBuildLog(alias, func(wq *BuildLogQuery) {
				*wq = *query
			})

		case "albums":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AlbumClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, albumImplementors)...); err != nil {
				return err
			}
			m.WithNamedAlbums(alias, func(wq *AlbumQuery) {
				*wq = *query
			})
		case "createTime":
			if _, ok := fieldSeen[media.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, media.FieldCreateTime)
				fieldSeen[media.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[media.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, media.FieldUpdateTime)
				fieldSeen[media.FieldUpdateTime] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[media.FieldTitle]; !ok {
				selectedFields = append(selectedFields, media.FieldTitle)
				fieldSeen[media.FieldTitle] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[media.FieldDescription]; !ok {
				selectedFields = append(selectedFields, media.FieldDescription)
				fieldSeen[media.FieldDescription] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		m.Select(selectedFields...)
	}
	return nil
}

type mediaPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []MediaPaginateOption
}

func newMediaPaginateArgs(rv map[string]any) *mediaPaginateArgs {
	args := &mediaPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*MediaWhereInput); ok {
		args.opts = append(args.opts, WithMediaFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (m *ModQuery) CollectFields(ctx context.Context, satisfies ...string) (*ModQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return m, nil
	}
	if err := m.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *ModQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(mod.Columns))
		selectedFields = []string{mod.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "car":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carImplementors)...); err != nil {
				return err
			}
			m.withCar = query

		case "tasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TaskClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, taskImplementors)...); err != nil {
				return err
			}
			m.WithNamedTasks(alias, func(wq *TaskQuery) {
				*wq = *query
			})

		case "productOptions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ModProductOptionClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, modproductoptionImplementors)...); err != nil {
				return err
			}
			m.WithNamedProductOptions(alias, func(wq *ModProductOptionQuery) {
				*wq = *query
			})

		case "buildLogs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildLogClient{config: m.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, buildlogImplementors)...); err != nil {
				return err
			}
			m.WithNamedBuildLogs(alias, func(wq *BuildLogQuery) {
				*wq = *query
			})
		case "createTime":
			if _, ok := fieldSeen[mod.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, mod.FieldCreateTime)
				fieldSeen[mod.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[mod.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, mod.FieldUpdateTime)
				fieldSeen[mod.FieldUpdateTime] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[mod.FieldTitle]; !ok {
				selectedFields = append(selectedFields, mod.FieldTitle)
				fieldSeen[mod.FieldTitle] = struct{}{}
			}
		case "category":
			if _, ok := fieldSeen[mod.FieldCategory]; !ok {
				selectedFields = append(selectedFields, mod.FieldCategory)
				fieldSeen[mod.FieldCategory] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[mod.FieldStatus]; !ok {
				selectedFields = append(selectedFields, mod.FieldStatus)
				fieldSeen[mod.FieldStatus] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[mod.FieldDescription]; !ok {
				selectedFields = append(selectedFields, mod.FieldDescription)
				fieldSeen[mod.FieldDescription] = struct{}{}
			}
		case "stage":
			if _, ok := fieldSeen[mod.FieldStage]; !ok {
				selectedFields = append(selectedFields, mod.FieldStage)
				fieldSeen[mod.FieldStage] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		m.Select(selectedFields...)
	}
	return nil
}

type modPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ModPaginateOption
}

func newModPaginateArgs(rv map[string]any) *modPaginateArgs {
	args := &modPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ModWhereInput); ok {
		args.opts = append(args.opts, WithModFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (mpo *ModProductOptionQuery) CollectFields(ctx context.Context, satisfies ...string) (*ModProductOptionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return mpo, nil
	}
	if err := mpo.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return mpo, nil
}

func (mpo *ModProductOptionQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(modproductoption.Columns))
		selectedFields = []string{modproductoption.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "mod":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ModClient{config: mpo.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, modImplementors)...); err != nil {
				return err
			}
			mpo.withMod = query

		case "media":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MediaClient{config: mpo.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, mediaImplementors)...); err != nil {
				return err
			}
			mpo.WithNamedMedia(alias, func(wq *MediaQuery) {
				*wq = *query
			})
		case "createTime":
			if _, ok := fieldSeen[modproductoption.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, modproductoption.FieldCreateTime)
				fieldSeen[modproductoption.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[modproductoption.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, modproductoption.FieldUpdateTime)
				fieldSeen[modproductoption.FieldUpdateTime] = struct{}{}
			}
		case "vendor":
			if _, ok := fieldSeen[modproductoption.FieldVendor]; !ok {
				selectedFields = append(selectedFields, modproductoption.FieldVendor)
				fieldSeen[modproductoption.FieldVendor] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[modproductoption.FieldName]; !ok {
				selectedFields = append(selectedFields, modproductoption.FieldName)
				fieldSeen[modproductoption.FieldName] = struct{}{}
			}
		case "link":
			if _, ok := fieldSeen[modproductoption.FieldLink]; !ok {
				selectedFields = append(selectedFields, modproductoption.FieldLink)
				fieldSeen[modproductoption.FieldLink] = struct{}{}
			}
		case "price":
			if _, ok := fieldSeen[modproductoption.FieldPrice]; !ok {
				selectedFields = append(selectedFields, modproductoption.FieldPrice)
				fieldSeen[modproductoption.FieldPrice] = struct{}{}
			}
		case "notes":
			if _, ok := fieldSeen[modproductoption.FieldNotes]; !ok {
				selectedFields = append(selectedFields, modproductoption.FieldNotes)
				fieldSeen[modproductoption.FieldNotes] = struct{}{}
			}
		case "pros":
			if _, ok := fieldSeen[modproductoption.FieldPros]; !ok {
				selectedFields = append(selectedFields, modproductoption.FieldPros)
				fieldSeen[modproductoption.FieldPros] = struct{}{}
			}
		case "cons":
			if _, ok := fieldSeen[modproductoption.FieldCons]; !ok {
				selectedFields = append(selectedFields, modproductoption.FieldCons)
				fieldSeen[modproductoption.FieldCons] = struct{}{}
			}
		case "specs":
			if _, ok := fieldSeen[modproductoption.FieldSpecs]; !ok {
				selectedFields = append(selectedFields, modproductoption.FieldSpecs)
				fieldSeen[modproductoption.FieldSpecs] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		mpo.Select(selectedFields...)
	}
	return nil
}

type modproductoptionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ModProductOptionPaginateOption
}

func newModProductOptionPaginateArgs(rv map[string]any) *modproductoptionPaginateArgs {
	args := &modproductoptionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ModProductOptionWhereInput); ok {
		args.opts = append(args.opts, WithModProductOptionFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (or *OdometerReadingQuery) CollectFields(ctx context.Context, satisfies ...string) (*OdometerReadingQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return or, nil
	}
	if err := or.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return or, nil
}

func (or *OdometerReadingQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(odometerreading.Columns))
		selectedFields = []string{odometerreading.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "car":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarClient{config: or.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carImplementors)...); err != nil {
				return err
			}
			or.withCar = query

		case "fuelUp":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FuelUpClient{config: or.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, fuelupImplementors)...); err != nil {
				return err
			}
			or.withFuelUp = query

		case "serviceLog":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServiceLogClient{config: or.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, servicelogImplementors)...); err != nil {
				return err
			}
			or.withServiceLog = query
		case "createTime":
			if _, ok := fieldSeen[odometerreading.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, odometerreading.FieldCreateTime)
				fieldSeen[odometerreading.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[odometerreading.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, odometerreading.FieldUpdateTime)
				fieldSeen[odometerreading.FieldUpdateTime] = struct{}{}
			}
		case "readingKm":
			if _, ok := fieldSeen[odometerreading.FieldReadingKm]; !ok {
				selectedFields = append(selectedFields, odometerreading.FieldReadingKm)
				fieldSeen[odometerreading.FieldReadingKm] = struct{}{}
			}
		case "readingTime":
			if _, ok := fieldSeen[odometerreading.FieldReadingTime]; !ok {
				selectedFields = append(selectedFields, odometerreading.FieldReadingTime)
				fieldSeen[odometerreading.FieldReadingTime] = struct{}{}
			}
		case "notes":
			if _, ok := fieldSeen[odometerreading.FieldNotes]; !ok {
				selectedFields = append(selectedFields, odometerreading.FieldNotes)
				fieldSeen[odometerreading.FieldNotes] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		or.Select(selectedFields...)
	}
	return nil
}

type odometerreadingPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OdometerReadingPaginateOption
}

func newOdometerReadingPaginateArgs(rv map[string]any) *odometerreadingPaginateArgs {
	args := &odometerreadingPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OdometerReadingWhereInput); ok {
		args.opts = append(args.opts, WithOdometerReadingFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pr *ProfileQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProfileQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pr, nil
	}
	if err := pr.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pr, nil
}

func (pr *ProfileQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(profile.Columns))
		selectedFields = []string{profile.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			pr.withUser = query
		case "createTime":
			if _, ok := fieldSeen[profile.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, profile.FieldCreateTime)
				fieldSeen[profile.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[profile.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, profile.FieldUpdateTime)
				fieldSeen[profile.FieldUpdateTime] = struct{}{}
			}
		case "username":
			if _, ok := fieldSeen[profile.FieldUsername]; !ok {
				selectedFields = append(selectedFields, profile.FieldUsername)
				fieldSeen[profile.FieldUsername] = struct{}{}
			}
		case "firstName":
			if _, ok := fieldSeen[profile.FieldFirstName]; !ok {
				selectedFields = append(selectedFields, profile.FieldFirstName)
				fieldSeen[profile.FieldFirstName] = struct{}{}
			}
		case "lastName":
			if _, ok := fieldSeen[profile.FieldLastName]; !ok {
				selectedFields = append(selectedFields, profile.FieldLastName)
				fieldSeen[profile.FieldLastName] = struct{}{}
			}
		case "visibility":
			if _, ok := fieldSeen[profile.FieldVisibility]; !ok {
				selectedFields = append(selectedFields, profile.FieldVisibility)
				fieldSeen[profile.FieldVisibility] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pr.Select(selectedFields...)
	}
	return nil
}

type profilePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProfilePaginateOption
}

func newProfilePaginateArgs(rv map[string]any) *profilePaginateArgs {
	args := &profilePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ProfileWhereInput); ok {
		args.opts = append(args.opts, WithProfileFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (si *ServiceItemQuery) CollectFields(ctx context.Context, satisfies ...string) (*ServiceItemQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return si, nil
	}
	if err := si.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return si, nil
}

func (si *ServiceItemQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(serviceitem.Columns))
		selectedFields = []string{serviceitem.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "car":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarClient{config: si.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carImplementors)...); err != nil {
				return err
			}
			si.withCar = query

		case "schedules":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServiceScheduleClient{config: si.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, servicescheduleImplementors)...); err != nil {
				return err
			}
			si.WithNamedSchedules(alias, func(wq *ServiceScheduleQuery) {
				*wq = *query
			})

		case "logs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServiceLogClient{config: si.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, servicelogImplementors)...); err != nil {
				return err
			}
			si.WithNamedLogs(alias, func(wq *ServiceLogQuery) {
				*wq = *query
			})
		case "createTime":
			if _, ok := fieldSeen[serviceitem.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, serviceitem.FieldCreateTime)
				fieldSeen[serviceitem.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[serviceitem.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, serviceitem.FieldUpdateTime)
				fieldSeen[serviceitem.FieldUpdateTime] = struct{}{}
			}
		case "label":
			if _, ok := fieldSeen[serviceitem.FieldLabel]; !ok {
				selectedFields = append(selectedFields, serviceitem.FieldLabel)
				fieldSeen[serviceitem.FieldLabel] = struct{}{}
			}
		case "estimatedMinutes":
			if _, ok := fieldSeen[serviceitem.FieldEstimatedMinutes]; !ok {
				selectedFields = append(selectedFields, serviceitem.FieldEstimatedMinutes)
				fieldSeen[serviceitem.FieldEstimatedMinutes] = struct{}{}
			}
		case "defaultIntervalKm":
			if _, ok := fieldSeen[serviceitem.FieldDefaultIntervalKm]; !ok {
				selectedFields = append(selectedFields, serviceitem.FieldDefaultIntervalKm)
				fieldSeen[serviceitem.FieldDefaultIntervalKm] = struct{}{}
			}
		case "defaultIntervalMonths":
			if _, ok := fieldSeen[serviceitem.FieldDefaultIntervalMonths]; !ok {
				selectedFields = append(selectedFields, serviceitem.FieldDefaultIntervalMonths)
				fieldSeen[serviceitem.FieldDefaultIntervalMonths] = struct{}{}
			}
		case "notes":
			if _, ok := fieldSeen[serviceitem.FieldNotes]; !ok {
				selectedFields = append(selectedFields, serviceitem.FieldNotes)
				fieldSeen[serviceitem.FieldNotes] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[serviceitem.FieldTags]; !ok {
				selectedFields = append(selectedFields, serviceitem.FieldTags)
				fieldSeen[serviceitem.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		si.Select(selectedFields...)
	}
	return nil
}

type serviceitemPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ServiceItemPaginateOption
}

func newServiceItemPaginateArgs(rv map[string]any) *serviceitemPaginateArgs {
	args := &serviceitemPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ServiceItemWhereInput); ok {
		args.opts = append(args.opts, WithServiceItemFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sl *ServiceLogQuery) CollectFields(ctx context.Context, satisfies ...string) (*ServiceLogQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sl, nil
	}
	if err := sl.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sl, nil
}

func (sl *ServiceLogQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(servicelog.Columns))
		selectedFields = []string{servicelog.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "car":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarClient{config: sl.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carImplementors)...); err != nil {
				return err
			}
			sl.withCar = query

		case "items":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServiceItemClient{config: sl.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, serviceitemImplementors)...); err != nil {
				return err
			}
			sl.WithNamedItems(alias, func(wq *ServiceItemQuery) {
				*wq = *query
			})

		case "schedule":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServiceScheduleClient{config: sl.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, servicescheduleImplementors)...); err != nil {
				return err
			}
			sl.withSchedule = query

		case "odometerReading":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OdometerReadingClient{config: sl.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, odometerreadingImplementors)...); err != nil {
				return err
			}
			sl.withOdometerReading = query

		case "expense":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ExpenseClient{config: sl.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, expenseImplementors)...); err != nil {
				return err
			}
			sl.withExpense = query

		case "documents":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentClient{config: sl.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, documentImplementors)...); err != nil {
				return err
			}
			sl.WithNamedDocuments(alias, func(wq *DocumentQuery) {
				*wq = *query
			})
		case "createTime":
			if _, ok := fieldSeen[servicelog.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, servicelog.FieldCreateTime)
				fieldSeen[servicelog.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[servicelog.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, servicelog.FieldUpdateTime)
				fieldSeen[servicelog.FieldUpdateTime] = struct{}{}
			}
		case "datePerformed":
			if _, ok := fieldSeen[servicelog.FieldDatePerformed]; !ok {
				selectedFields = append(selectedFields, servicelog.FieldDatePerformed)
				fieldSeen[servicelog.FieldDatePerformed] = struct{}{}
			}
		case "performedBy":
			if _, ok := fieldSeen[servicelog.FieldPerformedBy]; !ok {
				selectedFields = append(selectedFields, servicelog.FieldPerformedBy)
				fieldSeen[servicelog.FieldPerformedBy] = struct{}{}
			}
		case "notes":
			if _, ok := fieldSeen[servicelog.FieldNotes]; !ok {
				selectedFields = append(selectedFields, servicelog.FieldNotes)
				fieldSeen[servicelog.FieldNotes] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[servicelog.FieldTags]; !ok {
				selectedFields = append(selectedFields, servicelog.FieldTags)
				fieldSeen[servicelog.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sl.Select(selectedFields...)
	}
	return nil
}

type servicelogPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ServiceLogPaginateOption
}

func newServiceLogPaginateArgs(rv map[string]any) *servicelogPaginateArgs {
	args := &servicelogPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ServiceLogWhereInput); ok {
		args.opts = append(args.opts, WithServiceLogFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ss *ServiceScheduleQuery) CollectFields(ctx context.Context, satisfies ...string) (*ServiceScheduleQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ss, nil
	}
	if err := ss.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ss, nil
}

func (ss *ServiceScheduleQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(serviceschedule.Columns))
		selectedFields = []string{serviceschedule.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "car":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarClient{config: ss.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carImplementors)...); err != nil {
				return err
			}
			ss.withCar = query

		case "items":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServiceItemClient{config: ss.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, serviceitemImplementors)...); err != nil {
				return err
			}
			ss.WithNamedItems(alias, func(wq *ServiceItemQuery) {
				*wq = *query
			})

		case "logs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServiceLogClient{config: ss.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, servicelogImplementors)...); err != nil {
				return err
			}
			ss.WithNamedLogs(alias, func(wq *ServiceLogQuery) {
				*wq = *query
			})
		case "createTime":
			if _, ok := fieldSeen[serviceschedule.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, serviceschedule.FieldCreateTime)
				fieldSeen[serviceschedule.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[serviceschedule.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, serviceschedule.FieldUpdateTime)
				fieldSeen[serviceschedule.FieldUpdateTime] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[serviceschedule.FieldTitle]; !ok {
				selectedFields = append(selectedFields, serviceschedule.FieldTitle)
				fieldSeen[serviceschedule.FieldTitle] = struct{}{}
			}
		case "repeatEveryKm":
			if _, ok := fieldSeen[serviceschedule.FieldRepeatEveryKm]; !ok {
				selectedFields = append(selectedFields, serviceschedule.FieldRepeatEveryKm)
				fieldSeen[serviceschedule.FieldRepeatEveryKm] = struct{}{}
			}
		case "startsAtKm":
			if _, ok := fieldSeen[serviceschedule.FieldStartsAtKm]; !ok {
				selectedFields = append(selectedFields, serviceschedule.FieldStartsAtKm)
				fieldSeen[serviceschedule.FieldStartsAtKm] = struct{}{}
			}
		case "repeatEveryMonths":
			if _, ok := fieldSeen[serviceschedule.FieldRepeatEveryMonths]; !ok {
				selectedFields = append(selectedFields, serviceschedule.FieldRepeatEveryMonths)
				fieldSeen[serviceschedule.FieldRepeatEveryMonths] = struct{}{}
			}
		case "startsAtMonths":
			if _, ok := fieldSeen[serviceschedule.FieldStartsAtMonths]; !ok {
				selectedFields = append(selectedFields, serviceschedule.FieldStartsAtMonths)
				fieldSeen[serviceschedule.FieldStartsAtMonths] = struct{}{}
			}
		case "notes":
			if _, ok := fieldSeen[serviceschedule.FieldNotes]; !ok {
				selectedFields = append(selectedFields, serviceschedule.FieldNotes)
				fieldSeen[serviceschedule.FieldNotes] = struct{}{}
			}
		case "archived":
			if _, ok := fieldSeen[serviceschedule.FieldArchived]; !ok {
				selectedFields = append(selectedFields, serviceschedule.FieldArchived)
				fieldSeen[serviceschedule.FieldArchived] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ss.Select(selectedFields...)
	}
	return nil
}

type serviceschedulePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ServiceSchedulePaginateOption
}

func newServiceSchedulePaginateArgs(rv map[string]any) *serviceschedulePaginateArgs {
	args := &serviceschedulePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ServiceScheduleWhereInput); ok {
		args.opts = append(args.opts, WithServiceScheduleFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *SubscriptionQuery) CollectFields(ctx context.Context, satisfies ...string) (*SubscriptionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *SubscriptionQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(subscription.Columns))
		selectedFields = []string{subscription.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			s.withUser = query

		case "checkoutSession":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CheckoutSessionClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, checkoutsessionImplementors)...); err != nil {
				return err
			}
			s.withCheckoutSession = query
		case "createTime":
			if _, ok := fieldSeen[subscription.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, subscription.FieldCreateTime)
				fieldSeen[subscription.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[subscription.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, subscription.FieldUpdateTime)
				fieldSeen[subscription.FieldUpdateTime] = struct{}{}
			}
		case "stripeSubscriptionID":
			if _, ok := fieldSeen[subscription.FieldStripeSubscriptionID]; !ok {
				selectedFields = append(selectedFields, subscription.FieldStripeSubscriptionID)
				fieldSeen[subscription.FieldStripeSubscriptionID] = struct{}{}
			}
		case "tier":
			if _, ok := fieldSeen[subscription.FieldTier]; !ok {
				selectedFields = append(selectedFields, subscription.FieldTier)
				fieldSeen[subscription.FieldTier] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[subscription.FieldStatus]; !ok {
				selectedFields = append(selectedFields, subscription.FieldStatus)
				fieldSeen[subscription.FieldStatus] = struct{}{}
			}
		case "canceledAt":
			if _, ok := fieldSeen[subscription.FieldCanceledAt]; !ok {
				selectedFields = append(selectedFields, subscription.FieldCanceledAt)
				fieldSeen[subscription.FieldCanceledAt] = struct{}{}
			}
		case "cancelAtPeriodEnd":
			if _, ok := fieldSeen[subscription.FieldCancelAtPeriodEnd]; !ok {
				selectedFields = append(selectedFields, subscription.FieldCancelAtPeriodEnd)
				fieldSeen[subscription.FieldCancelAtPeriodEnd] = struct{}{}
			}
		case "trialEnd":
			if _, ok := fieldSeen[subscription.FieldTrialEnd]; !ok {
				selectedFields = append(selectedFields, subscription.FieldTrialEnd)
				fieldSeen[subscription.FieldTrialEnd] = struct{}{}
			}
		case "affiliate6moCode":
			if _, ok := fieldSeen[subscription.FieldAffiliate6moCode]; !ok {
				selectedFields = append(selectedFields, subscription.FieldAffiliate6moCode)
				fieldSeen[subscription.FieldAffiliate6moCode] = struct{}{}
			}
		case "affiliate12moCode":
			if _, ok := fieldSeen[subscription.FieldAffiliate12moCode]; !ok {
				selectedFields = append(selectedFields, subscription.FieldAffiliate12moCode)
				fieldSeen[subscription.FieldAffiliate12moCode] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type subscriptionplanPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SubscriptionPlanPaginateOption
}

func newSubscriptionPlanPaginateArgs(rv map[string]any) *subscriptionplanPaginateArgs {
	args := &subscriptionplanPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*SubscriptionPlanWhereInput); ok {
		args.opts = append(args.opts, WithSubscriptionPlanFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TaskQuery) CollectFields(ctx context.Context, satisfies ...string) (*TaskQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TaskQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(task.Columns))
		selectedFields = []string{task.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "car":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carImplementors)...); err != nil {
				return err
			}
			t.withCar = query

		case "parent":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TaskClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, taskImplementors)...); err != nil {
				return err
			}
			t.withParent = query

		case "subtasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TaskClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, taskImplementors)...); err != nil {
				return err
			}
			t.WithNamedSubtasks(alias, func(wq *TaskQuery) {
				*wq = *query
			})

		case "mods":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ModClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, modImplementors)...); err != nil {
				return err
			}
			t.WithNamedMods(alias, func(wq *ModQuery) {
				*wq = *query
			})
		case "createTime":
			if _, ok := fieldSeen[task.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, task.FieldCreateTime)
				fieldSeen[task.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[task.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, task.FieldUpdateTime)
				fieldSeen[task.FieldUpdateTime] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[task.FieldStatus]; !ok {
				selectedFields = append(selectedFields, task.FieldStatus)
				fieldSeen[task.FieldStatus] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[task.FieldTitle]; !ok {
				selectedFields = append(selectedFields, task.FieldTitle)
				fieldSeen[task.FieldTitle] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[task.FieldDescription]; !ok {
				selectedFields = append(selectedFields, task.FieldDescription)
				fieldSeen[task.FieldDescription] = struct{}{}
			}
		case "rank":
			if _, ok := fieldSeen[task.FieldRank]; !ok {
				selectedFields = append(selectedFields, task.FieldRank)
				fieldSeen[task.FieldRank] = struct{}{}
			}
		case "estimate":
			if _, ok := fieldSeen[task.FieldEstimate]; !ok {
				selectedFields = append(selectedFields, task.FieldEstimate)
				fieldSeen[task.FieldEstimate] = struct{}{}
			}
		case "priority":
			if _, ok := fieldSeen[task.FieldPriority]; !ok {
				selectedFields = append(selectedFields, task.FieldPriority)
				fieldSeen[task.FieldPriority] = struct{}{}
			}
		case "effort":
			if _, ok := fieldSeen[task.FieldEffort]; !ok {
				selectedFields = append(selectedFields, task.FieldEffort)
				fieldSeen[task.FieldEffort] = struct{}{}
			}
		case "difficulty":
			if _, ok := fieldSeen[task.FieldDifficulty]; !ok {
				selectedFields = append(selectedFields, task.FieldDifficulty)
				fieldSeen[task.FieldDifficulty] = struct{}{}
			}
		case "category":
			if _, ok := fieldSeen[task.FieldCategory]; !ok {
				selectedFields = append(selectedFields, task.FieldCategory)
				fieldSeen[task.FieldCategory] = struct{}{}
			}
		case "budget":
			if _, ok := fieldSeen[task.FieldBudget]; !ok {
				selectedFields = append(selectedFields, task.FieldBudget)
				fieldSeen[task.FieldBudget] = struct{}{}
			}
		case "partsNeeded":
			if _, ok := fieldSeen[task.FieldPartsNeeded]; !ok {
				selectedFields = append(selectedFields, task.FieldPartsNeeded)
				fieldSeen[task.FieldPartsNeeded] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type taskPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TaskPaginateOption
}

func newTaskPaginateArgs(rv map[string]any) *taskPaginateArgs {
	args := &taskPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*TaskOrder:
			args.opts = append(args.opts, WithTaskOrder(v))
		case []any:
			var orders []*TaskOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &TaskOrder{Field: &TaskOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithTaskOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*TaskWhereInput); ok {
		args.opts = append(args.opts, WithTaskFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if err := u.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return u, nil
}

func (u *UserQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(user.Columns))
		selectedFields = []string{user.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "cars":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carImplementors)...); err != nil {
				return err
			}
			u.WithNamedCars(alias, func(wq *CarQuery) {
				*wq = *query
			})

		case "profile":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProfileClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, profileImplementors)...); err != nil {
				return err
			}
			u.withProfile = query

		case "settings":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserSettingsClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, usersettingsImplementors)...); err != nil {
				return err
			}
			u.withSettings = query

		case "subscriptions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SubscriptionClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, subscriptionImplementors)...); err != nil {
				return err
			}
			u.WithNamedSubscriptions(alias, func(wq *SubscriptionQuery) {
				*wq = *query
			})

		case "checkoutSessions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CheckoutSessionClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, checkoutsessionImplementors)...); err != nil {
				return err
			}
			u.WithNamedCheckoutSessions(alias, func(wq *CheckoutSessionQuery) {
				*wq = *query
			})

		case "media":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&MediaClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, mediaImplementors)...); err != nil {
				return err
			}
			u.WithNamedMedia(alias, func(wq *MediaQuery) {
				*wq = *query
			})
		case "createTime":
			if _, ok := fieldSeen[user.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, user.FieldCreateTime)
				fieldSeen[user.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[user.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, user.FieldUpdateTime)
				fieldSeen[user.FieldUpdateTime] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[user.FieldEmail]; !ok {
				selectedFields = append(selectedFields, user.FieldEmail)
				fieldSeen[user.FieldEmail] = struct{}{}
			}
		case "stripeCustomerID":
			if _, ok := fieldSeen[user.FieldStripeCustomerID]; !ok {
				selectedFields = append(selectedFields, user.FieldStripeCustomerID)
				fieldSeen[user.FieldStripeCustomerID] = struct{}{}
			}
		case "stripeAccountID":
			if _, ok := fieldSeen[user.FieldStripeAccountID]; !ok {
				selectedFields = append(selectedFields, user.FieldStripeAccountID)
				fieldSeen[user.FieldStripeAccountID] = struct{}{}
			}
		case "stripeAccountCapabilities":
			if _, ok := fieldSeen[user.FieldStripeAccountCapabilities]; !ok {
				selectedFields = append(selectedFields, user.FieldStripeAccountCapabilities)
				fieldSeen[user.FieldStripeAccountCapabilities] = struct{}{}
			}
		case "affiliate6moCode":
			if _, ok := fieldSeen[user.FieldAffiliate6moCode]; !ok {
				selectedFields = append(selectedFields, user.FieldAffiliate6moCode)
				fieldSeen[user.FieldAffiliate6moCode] = struct{}{}
			}
		case "affiliate12moCode":
			if _, ok := fieldSeen[user.FieldAffiliate12moCode]; !ok {
				selectedFields = append(selectedFields, user.FieldAffiliate12moCode)
				fieldSeen[user.FieldAffiliate12moCode] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		u.Select(selectedFields...)
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]any) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*UserWhereInput); ok {
		args.opts = append(args.opts, WithUserFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (us *UserSettingsQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserSettingsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return us, nil
	}
	if err := us.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return us, nil
}

func (us *UserSettingsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(usersettings.Columns))
		selectedFields = []string{usersettings.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: us.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			us.withUser = query
		case "createTime":
			if _, ok := fieldSeen[usersettings.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, usersettings.FieldCreateTime)
				fieldSeen[usersettings.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[usersettings.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, usersettings.FieldUpdateTime)
				fieldSeen[usersettings.FieldUpdateTime] = struct{}{}
			}
		case "currencyCode":
			if _, ok := fieldSeen[usersettings.FieldCurrencyCode]; !ok {
				selectedFields = append(selectedFields, usersettings.FieldCurrencyCode)
				fieldSeen[usersettings.FieldCurrencyCode] = struct{}{}
			}
		case "fuelVolumeUnit":
			if _, ok := fieldSeen[usersettings.FieldFuelVolumeUnit]; !ok {
				selectedFields = append(selectedFields, usersettings.FieldFuelVolumeUnit)
				fieldSeen[usersettings.FieldFuelVolumeUnit] = struct{}{}
			}
		case "distanceUnit":
			if _, ok := fieldSeen[usersettings.FieldDistanceUnit]; !ok {
				selectedFields = append(selectedFields, usersettings.FieldDistanceUnit)
				fieldSeen[usersettings.FieldDistanceUnit] = struct{}{}
			}
		case "fuelConsumptionUnit":
			if _, ok := fieldSeen[usersettings.FieldFuelConsumptionUnit]; !ok {
				selectedFields = append(selectedFields, usersettings.FieldFuelConsumptionUnit)
				fieldSeen[usersettings.FieldFuelConsumptionUnit] = struct{}{}
			}
		case "temperatureUnit":
			if _, ok := fieldSeen[usersettings.FieldTemperatureUnit]; !ok {
				selectedFields = append(selectedFields, usersettings.FieldTemperatureUnit)
				fieldSeen[usersettings.FieldTemperatureUnit] = struct{}{}
			}
		case "powerUnit":
			if _, ok := fieldSeen[usersettings.FieldPowerUnit]; !ok {
				selectedFields = append(selectedFields, usersettings.FieldPowerUnit)
				fieldSeen[usersettings.FieldPowerUnit] = struct{}{}
			}
		case "torqueUnit":
			if _, ok := fieldSeen[usersettings.FieldTorqueUnit]; !ok {
				selectedFields = append(selectedFields, usersettings.FieldTorqueUnit)
				fieldSeen[usersettings.FieldTorqueUnit] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		us.Select(selectedFields...)
	}
	return nil
}

type usersettingsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserSettingsPaginateOption
}

func newUserSettingsPaginateArgs(rv map[string]any) *usersettingsPaginateArgs {
	args := &usersettingsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*UserSettingsWhereInput); ok {
		args.opts = append(args.opts, WithUserSettingsFilter(v.Filter))
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

// mayAddCondition appends another type condition to the satisfies list
// if it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond []string) []string {
Cond:
	for _, c := range typeCond {
		for _, s := range satisfies {
			if c == s {
				continue Cond
			}
		}
		satisfies = append(satisfies, c)
	}
	return satisfies
}

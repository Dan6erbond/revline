// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/Dan6erbond/revline/ent/album"
	"github.com/Dan6erbond/revline/ent/car"
	"github.com/Dan6erbond/revline/ent/checkoutsession"
	"github.com/Dan6erbond/revline/ent/document"
	"github.com/Dan6erbond/revline/ent/dragresult"
	"github.com/Dan6erbond/revline/ent/dragsession"
	"github.com/Dan6erbond/revline/ent/dynoresult"
	"github.com/Dan6erbond/revline/ent/dynosession"
	"github.com/Dan6erbond/revline/ent/expense"
	"github.com/Dan6erbond/revline/ent/fuelup"
	"github.com/Dan6erbond/revline/ent/media"
	"github.com/Dan6erbond/revline/ent/modidea"
	"github.com/Dan6erbond/revline/ent/modproductoption"
	"github.com/Dan6erbond/revline/ent/odometerreading"
	"github.com/Dan6erbond/revline/ent/predicate"
	"github.com/Dan6erbond/revline/ent/profile"
	"github.com/Dan6erbond/revline/ent/serviceitem"
	"github.com/Dan6erbond/revline/ent/servicelog"
	"github.com/Dan6erbond/revline/ent/serviceschedule"
	"github.com/Dan6erbond/revline/ent/subscription"
	"github.com/Dan6erbond/revline/ent/task"
	"github.com/Dan6erbond/revline/ent/user"
	"github.com/Dan6erbond/revline/ent/usersettings"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAlbum            = "Album"
	TypeCar              = "Car"
	TypeCheckoutSession  = "CheckoutSession"
	TypeDocument         = "Document"
	TypeDragResult       = "DragResult"
	TypeDragSession      = "DragSession"
	TypeDynoResult       = "DynoResult"
	TypeDynoSession      = "DynoSession"
	TypeExpense          = "Expense"
	TypeFuelUp           = "FuelUp"
	TypeMedia            = "Media"
	TypeModIdea          = "ModIdea"
	TypeModProductOption = "ModProductOption"
	TypeOdometerReading  = "OdometerReading"
	TypeProfile          = "Profile"
	TypeServiceItem      = "ServiceItem"
	TypeServiceLog       = "ServiceLog"
	TypeServiceSchedule  = "ServiceSchedule"
	TypeSubscription     = "Subscription"
	TypeTask             = "Task"
	TypeUser             = "User"
	TypeUserSettings     = "UserSettings"
)

// AlbumMutation represents an operation that mutates the Album nodes in the graph.
type AlbumMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	title         *string
	clearedFields map[string]struct{}
	car           *uuid.UUID
	clearedcar    bool
	media         map[uuid.UUID]struct{}
	removedmedia  map[uuid.UUID]struct{}
	clearedmedia  bool
	done          bool
	oldValue      func(context.Context) (*Album, error)
	predicates    []predicate.Album
}

var _ ent.Mutation = (*AlbumMutation)(nil)

// albumOption allows management of the mutation configuration using functional options.
type albumOption func(*AlbumMutation)

// newAlbumMutation creates new mutation for the Album entity.
func newAlbumMutation(c config, op Op, opts ...albumOption) *AlbumMutation {
	m := &AlbumMutation{
		config:        c,
		op:            op,
		typ:           TypeAlbum,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlbumID sets the ID field of the mutation.
func withAlbumID(id uuid.UUID) albumOption {
	return func(m *AlbumMutation) {
		var (
			err   error
			once  sync.Once
			value *Album
		)
		m.oldValue = func(ctx context.Context) (*Album, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Album.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlbum sets the old Album of the mutation.
func withAlbum(node *Album) albumOption {
	return func(m *AlbumMutation) {
		m.oldValue = func(context.Context) (*Album, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlbumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlbumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Album entities.
func (m *AlbumMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlbumMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlbumMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Album.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *AlbumMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AlbumMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AlbumMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AlbumMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AlbumMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AlbumMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTitle sets the "title" field.
func (m *AlbumMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AlbumMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AlbumMutation) ResetTitle() {
	m.title = nil
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *AlbumMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *AlbumMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *AlbumMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *AlbumMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *AlbumMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *AlbumMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// AddMediumIDs adds the "media" edge to the Media entity by ids.
func (m *AlbumMutation) AddMediumIDs(ids ...uuid.UUID) {
	if m.media == nil {
		m.media = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.media[ids[i]] = struct{}{}
	}
}

// ClearMedia clears the "media" edge to the Media entity.
func (m *AlbumMutation) ClearMedia() {
	m.clearedmedia = true
}

// MediaCleared reports if the "media" edge to the Media entity was cleared.
func (m *AlbumMutation) MediaCleared() bool {
	return m.clearedmedia
}

// RemoveMediumIDs removes the "media" edge to the Media entity by IDs.
func (m *AlbumMutation) RemoveMediumIDs(ids ...uuid.UUID) {
	if m.removedmedia == nil {
		m.removedmedia = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.media, ids[i])
		m.removedmedia[ids[i]] = struct{}{}
	}
}

// RemovedMedia returns the removed IDs of the "media" edge to the Media entity.
func (m *AlbumMutation) RemovedMediaIDs() (ids []uuid.UUID) {
	for id := range m.removedmedia {
		ids = append(ids, id)
	}
	return
}

// MediaIDs returns the "media" edge IDs in the mutation.
func (m *AlbumMutation) MediaIDs() (ids []uuid.UUID) {
	for id := range m.media {
		ids = append(ids, id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *AlbumMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
	m.removedmedia = nil
}

// Where appends a list predicates to the AlbumMutation builder.
func (m *AlbumMutation) Where(ps ...predicate.Album) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlbumMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlbumMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Album, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlbumMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlbumMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Album).
func (m *AlbumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlbumMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, album.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, album.FieldUpdateTime)
	}
	if m.title != nil {
		fields = append(fields, album.FieldTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlbumMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case album.FieldCreateTime:
		return m.CreateTime()
	case album.FieldUpdateTime:
		return m.UpdateTime()
	case album.FieldTitle:
		return m.Title()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlbumMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case album.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case album.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case album.FieldTitle:
		return m.OldTitle(ctx)
	}
	return nil, fmt.Errorf("unknown Album field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumMutation) SetField(name string, value ent.Value) error {
	switch name {
	case album.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case album.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case album.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	}
	return fmt.Errorf("unknown Album field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlbumMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlbumMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Album numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlbumMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlbumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlbumMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Album nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlbumMutation) ResetField(name string) error {
	switch name {
	case album.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case album.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case album.FieldTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown Album field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlbumMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.car != nil {
		edges = append(edges, album.EdgeCar)
	}
	if m.media != nil {
		edges = append(edges, album.EdgeMedia)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlbumMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case album.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case album.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.media))
		for id := range m.media {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlbumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmedia != nil {
		edges = append(edges, album.EdgeMedia)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlbumMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case album.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.removedmedia))
		for id := range m.removedmedia {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlbumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcar {
		edges = append(edges, album.EdgeCar)
	}
	if m.clearedmedia {
		edges = append(edges, album.EdgeMedia)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlbumMutation) EdgeCleared(name string) bool {
	switch name {
	case album.EdgeCar:
		return m.clearedcar
	case album.EdgeMedia:
		return m.clearedmedia
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlbumMutation) ClearEdge(name string) error {
	switch name {
	case album.EdgeCar:
		m.ClearCar()
		return nil
	}
	return fmt.Errorf("unknown Album unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlbumMutation) ResetEdge(name string) error {
	switch name {
	case album.EdgeCar:
		m.ResetCar()
		return nil
	case album.EdgeMedia:
		m.ResetMedia()
		return nil
	}
	return fmt.Errorf("unknown Album edge %s", name)
}

// CarMutation represents an operation that mutates the Car nodes in the graph.
type CarMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	create_time              *time.Time
	update_time              *time.Time
	name                     *string
	make                     *string
	model                    *string
	_type                    *string
	year                     *int
	addyear                  *int
	trim                     *string
	clearedFields            map[string]struct{}
	owner                    *uuid.UUID
	clearedowner             bool
	drag_sessions            map[uuid.UUID]struct{}
	removeddrag_sessions     map[uuid.UUID]struct{}
	cleareddrag_sessions     bool
	fuel_ups                 map[uuid.UUID]struct{}
	removedfuel_ups          map[uuid.UUID]struct{}
	clearedfuel_ups          bool
	odometer_readings        map[uuid.UUID]struct{}
	removedodometer_readings map[uuid.UUID]struct{}
	clearedodometer_readings bool
	service_items            map[uuid.UUID]struct{}
	removedservice_items     map[uuid.UUID]struct{}
	clearedservice_items     bool
	service_logs             map[uuid.UUID]struct{}
	removedservice_logs      map[uuid.UUID]struct{}
	clearedservice_logs      bool
	service_schedules        map[uuid.UUID]struct{}
	removedservice_schedules map[uuid.UUID]struct{}
	clearedservice_schedules bool
	media                    map[uuid.UUID]struct{}
	removedmedia             map[uuid.UUID]struct{}
	clearedmedia             bool
	albums                   map[uuid.UUID]struct{}
	removedalbums            map[uuid.UUID]struct{}
	clearedalbums            bool
	documents                map[uuid.UUID]struct{}
	removeddocuments         map[uuid.UUID]struct{}
	cleareddocuments         bool
	dyno_sessions            map[uuid.UUID]struct{}
	removeddyno_sessions     map[uuid.UUID]struct{}
	cleareddyno_sessions     bool
	expenses                 map[uuid.UUID]struct{}
	removedexpenses          map[uuid.UUID]struct{}
	clearedexpenses          bool
	banner_image             *uuid.UUID
	clearedbanner_image      bool
	tasks                    map[uuid.UUID]struct{}
	removedtasks             map[uuid.UUID]struct{}
	clearedtasks             bool
	mod_ideas                map[uuid.UUID]struct{}
	removedmod_ideas         map[uuid.UUID]struct{}
	clearedmod_ideas         bool
	done                     bool
	oldValue                 func(context.Context) (*Car, error)
	predicates               []predicate.Car
}

var _ ent.Mutation = (*CarMutation)(nil)

// carOption allows management of the mutation configuration using functional options.
type carOption func(*CarMutation)

// newCarMutation creates new mutation for the Car entity.
func newCarMutation(c config, op Op, opts ...carOption) *CarMutation {
	m := &CarMutation{
		config:        c,
		op:            op,
		typ:           TypeCar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarID sets the ID field of the mutation.
func withCarID(id uuid.UUID) carOption {
	return func(m *CarMutation) {
		var (
			err   error
			once  sync.Once
			value *Car
		)
		m.oldValue = func(ctx context.Context) (*Car, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Car.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCar sets the old Car of the mutation.
func withCar(node *Car) carOption {
	return func(m *CarMutation) {
		m.oldValue = func(context.Context) (*Car, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Car entities.
func (m *CarMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Car.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CarMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CarMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CarMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CarMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CarMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CarMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *CarMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CarMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CarMutation) ResetName() {
	m.name = nil
}

// SetMake sets the "make" field.
func (m *CarMutation) SetMake(s string) {
	m.make = &s
}

// Make returns the value of the "make" field in the mutation.
func (m *CarMutation) Make() (r string, exists bool) {
	v := m.make
	if v == nil {
		return
	}
	return *v, true
}

// OldMake returns the old "make" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldMake(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMake is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMake requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMake: %w", err)
	}
	return oldValue.Make, nil
}

// ClearMake clears the value of the "make" field.
func (m *CarMutation) ClearMake() {
	m.make = nil
	m.clearedFields[car.FieldMake] = struct{}{}
}

// MakeCleared returns if the "make" field was cleared in this mutation.
func (m *CarMutation) MakeCleared() bool {
	_, ok := m.clearedFields[car.FieldMake]
	return ok
}

// ResetMake resets all changes to the "make" field.
func (m *CarMutation) ResetMake() {
	m.make = nil
	delete(m.clearedFields, car.FieldMake)
}

// SetModel sets the "model" field.
func (m *CarMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *CarMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldModel(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *CarMutation) ClearModel() {
	m.model = nil
	m.clearedFields[car.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *CarMutation) ModelCleared() bool {
	_, ok := m.clearedFields[car.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *CarMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, car.FieldModel)
}

// SetType sets the "type" field.
func (m *CarMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *CarMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *CarMutation) ClearType() {
	m._type = nil
	m.clearedFields[car.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *CarMutation) TypeCleared() bool {
	_, ok := m.clearedFields[car.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *CarMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, car.FieldType)
}

// SetYear sets the "year" field.
func (m *CarMutation) SetYear(i int) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *CarMutation) Year() (r int, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldYear(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *CarMutation) AddYear(i int) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *CarMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ClearYear clears the value of the "year" field.
func (m *CarMutation) ClearYear() {
	m.year = nil
	m.addyear = nil
	m.clearedFields[car.FieldYear] = struct{}{}
}

// YearCleared returns if the "year" field was cleared in this mutation.
func (m *CarMutation) YearCleared() bool {
	_, ok := m.clearedFields[car.FieldYear]
	return ok
}

// ResetYear resets all changes to the "year" field.
func (m *CarMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
	delete(m.clearedFields, car.FieldYear)
}

// SetTrim sets the "trim" field.
func (m *CarMutation) SetTrim(s string) {
	m.trim = &s
}

// Trim returns the value of the "trim" field in the mutation.
func (m *CarMutation) Trim() (r string, exists bool) {
	v := m.trim
	if v == nil {
		return
	}
	return *v, true
}

// OldTrim returns the old "trim" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldTrim(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrim is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrim requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrim: %w", err)
	}
	return oldValue.Trim, nil
}

// ClearTrim clears the value of the "trim" field.
func (m *CarMutation) ClearTrim() {
	m.trim = nil
	m.clearedFields[car.FieldTrim] = struct{}{}
}

// TrimCleared returns if the "trim" field was cleared in this mutation.
func (m *CarMutation) TrimCleared() bool {
	_, ok := m.clearedFields[car.FieldTrim]
	return ok
}

// ResetTrim resets all changes to the "trim" field.
func (m *CarMutation) ResetTrim() {
	m.trim = nil
	delete(m.clearedFields, car.FieldTrim)
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *CarMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *CarMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *CarMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *CarMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CarMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *CarMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddDragSessionIDs adds the "drag_sessions" edge to the DragSession entity by ids.
func (m *CarMutation) AddDragSessionIDs(ids ...uuid.UUID) {
	if m.drag_sessions == nil {
		m.drag_sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.drag_sessions[ids[i]] = struct{}{}
	}
}

// ClearDragSessions clears the "drag_sessions" edge to the DragSession entity.
func (m *CarMutation) ClearDragSessions() {
	m.cleareddrag_sessions = true
}

// DragSessionsCleared reports if the "drag_sessions" edge to the DragSession entity was cleared.
func (m *CarMutation) DragSessionsCleared() bool {
	return m.cleareddrag_sessions
}

// RemoveDragSessionIDs removes the "drag_sessions" edge to the DragSession entity by IDs.
func (m *CarMutation) RemoveDragSessionIDs(ids ...uuid.UUID) {
	if m.removeddrag_sessions == nil {
		m.removeddrag_sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.drag_sessions, ids[i])
		m.removeddrag_sessions[ids[i]] = struct{}{}
	}
}

// RemovedDragSessions returns the removed IDs of the "drag_sessions" edge to the DragSession entity.
func (m *CarMutation) RemovedDragSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removeddrag_sessions {
		ids = append(ids, id)
	}
	return
}

// DragSessionsIDs returns the "drag_sessions" edge IDs in the mutation.
func (m *CarMutation) DragSessionsIDs() (ids []uuid.UUID) {
	for id := range m.drag_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetDragSessions resets all changes to the "drag_sessions" edge.
func (m *CarMutation) ResetDragSessions() {
	m.drag_sessions = nil
	m.cleareddrag_sessions = false
	m.removeddrag_sessions = nil
}

// AddFuelUpIDs adds the "fuel_ups" edge to the FuelUp entity by ids.
func (m *CarMutation) AddFuelUpIDs(ids ...uuid.UUID) {
	if m.fuel_ups == nil {
		m.fuel_ups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.fuel_ups[ids[i]] = struct{}{}
	}
}

// ClearFuelUps clears the "fuel_ups" edge to the FuelUp entity.
func (m *CarMutation) ClearFuelUps() {
	m.clearedfuel_ups = true
}

// FuelUpsCleared reports if the "fuel_ups" edge to the FuelUp entity was cleared.
func (m *CarMutation) FuelUpsCleared() bool {
	return m.clearedfuel_ups
}

// RemoveFuelUpIDs removes the "fuel_ups" edge to the FuelUp entity by IDs.
func (m *CarMutation) RemoveFuelUpIDs(ids ...uuid.UUID) {
	if m.removedfuel_ups == nil {
		m.removedfuel_ups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.fuel_ups, ids[i])
		m.removedfuel_ups[ids[i]] = struct{}{}
	}
}

// RemovedFuelUps returns the removed IDs of the "fuel_ups" edge to the FuelUp entity.
func (m *CarMutation) RemovedFuelUpsIDs() (ids []uuid.UUID) {
	for id := range m.removedfuel_ups {
		ids = append(ids, id)
	}
	return
}

// FuelUpsIDs returns the "fuel_ups" edge IDs in the mutation.
func (m *CarMutation) FuelUpsIDs() (ids []uuid.UUID) {
	for id := range m.fuel_ups {
		ids = append(ids, id)
	}
	return
}

// ResetFuelUps resets all changes to the "fuel_ups" edge.
func (m *CarMutation) ResetFuelUps() {
	m.fuel_ups = nil
	m.clearedfuel_ups = false
	m.removedfuel_ups = nil
}

// AddOdometerReadingIDs adds the "odometer_readings" edge to the OdometerReading entity by ids.
func (m *CarMutation) AddOdometerReadingIDs(ids ...uuid.UUID) {
	if m.odometer_readings == nil {
		m.odometer_readings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.odometer_readings[ids[i]] = struct{}{}
	}
}

// ClearOdometerReadings clears the "odometer_readings" edge to the OdometerReading entity.
func (m *CarMutation) ClearOdometerReadings() {
	m.clearedodometer_readings = true
}

// OdometerReadingsCleared reports if the "odometer_readings" edge to the OdometerReading entity was cleared.
func (m *CarMutation) OdometerReadingsCleared() bool {
	return m.clearedodometer_readings
}

// RemoveOdometerReadingIDs removes the "odometer_readings" edge to the OdometerReading entity by IDs.
func (m *CarMutation) RemoveOdometerReadingIDs(ids ...uuid.UUID) {
	if m.removedodometer_readings == nil {
		m.removedodometer_readings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.odometer_readings, ids[i])
		m.removedodometer_readings[ids[i]] = struct{}{}
	}
}

// RemovedOdometerReadings returns the removed IDs of the "odometer_readings" edge to the OdometerReading entity.
func (m *CarMutation) RemovedOdometerReadingsIDs() (ids []uuid.UUID) {
	for id := range m.removedodometer_readings {
		ids = append(ids, id)
	}
	return
}

// OdometerReadingsIDs returns the "odometer_readings" edge IDs in the mutation.
func (m *CarMutation) OdometerReadingsIDs() (ids []uuid.UUID) {
	for id := range m.odometer_readings {
		ids = append(ids, id)
	}
	return
}

// ResetOdometerReadings resets all changes to the "odometer_readings" edge.
func (m *CarMutation) ResetOdometerReadings() {
	m.odometer_readings = nil
	m.clearedodometer_readings = false
	m.removedodometer_readings = nil
}

// AddServiceItemIDs adds the "service_items" edge to the ServiceItem entity by ids.
func (m *CarMutation) AddServiceItemIDs(ids ...uuid.UUID) {
	if m.service_items == nil {
		m.service_items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.service_items[ids[i]] = struct{}{}
	}
}

// ClearServiceItems clears the "service_items" edge to the ServiceItem entity.
func (m *CarMutation) ClearServiceItems() {
	m.clearedservice_items = true
}

// ServiceItemsCleared reports if the "service_items" edge to the ServiceItem entity was cleared.
func (m *CarMutation) ServiceItemsCleared() bool {
	return m.clearedservice_items
}

// RemoveServiceItemIDs removes the "service_items" edge to the ServiceItem entity by IDs.
func (m *CarMutation) RemoveServiceItemIDs(ids ...uuid.UUID) {
	if m.removedservice_items == nil {
		m.removedservice_items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.service_items, ids[i])
		m.removedservice_items[ids[i]] = struct{}{}
	}
}

// RemovedServiceItems returns the removed IDs of the "service_items" edge to the ServiceItem entity.
func (m *CarMutation) RemovedServiceItemsIDs() (ids []uuid.UUID) {
	for id := range m.removedservice_items {
		ids = append(ids, id)
	}
	return
}

// ServiceItemsIDs returns the "service_items" edge IDs in the mutation.
func (m *CarMutation) ServiceItemsIDs() (ids []uuid.UUID) {
	for id := range m.service_items {
		ids = append(ids, id)
	}
	return
}

// ResetServiceItems resets all changes to the "service_items" edge.
func (m *CarMutation) ResetServiceItems() {
	m.service_items = nil
	m.clearedservice_items = false
	m.removedservice_items = nil
}

// AddServiceLogIDs adds the "service_logs" edge to the ServiceLog entity by ids.
func (m *CarMutation) AddServiceLogIDs(ids ...uuid.UUID) {
	if m.service_logs == nil {
		m.service_logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.service_logs[ids[i]] = struct{}{}
	}
}

// ClearServiceLogs clears the "service_logs" edge to the ServiceLog entity.
func (m *CarMutation) ClearServiceLogs() {
	m.clearedservice_logs = true
}

// ServiceLogsCleared reports if the "service_logs" edge to the ServiceLog entity was cleared.
func (m *CarMutation) ServiceLogsCleared() bool {
	return m.clearedservice_logs
}

// RemoveServiceLogIDs removes the "service_logs" edge to the ServiceLog entity by IDs.
func (m *CarMutation) RemoveServiceLogIDs(ids ...uuid.UUID) {
	if m.removedservice_logs == nil {
		m.removedservice_logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.service_logs, ids[i])
		m.removedservice_logs[ids[i]] = struct{}{}
	}
}

// RemovedServiceLogs returns the removed IDs of the "service_logs" edge to the ServiceLog entity.
func (m *CarMutation) RemovedServiceLogsIDs() (ids []uuid.UUID) {
	for id := range m.removedservice_logs {
		ids = append(ids, id)
	}
	return
}

// ServiceLogsIDs returns the "service_logs" edge IDs in the mutation.
func (m *CarMutation) ServiceLogsIDs() (ids []uuid.UUID) {
	for id := range m.service_logs {
		ids = append(ids, id)
	}
	return
}

// ResetServiceLogs resets all changes to the "service_logs" edge.
func (m *CarMutation) ResetServiceLogs() {
	m.service_logs = nil
	m.clearedservice_logs = false
	m.removedservice_logs = nil
}

// AddServiceScheduleIDs adds the "service_schedules" edge to the ServiceSchedule entity by ids.
func (m *CarMutation) AddServiceScheduleIDs(ids ...uuid.UUID) {
	if m.service_schedules == nil {
		m.service_schedules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.service_schedules[ids[i]] = struct{}{}
	}
}

// ClearServiceSchedules clears the "service_schedules" edge to the ServiceSchedule entity.
func (m *CarMutation) ClearServiceSchedules() {
	m.clearedservice_schedules = true
}

// ServiceSchedulesCleared reports if the "service_schedules" edge to the ServiceSchedule entity was cleared.
func (m *CarMutation) ServiceSchedulesCleared() bool {
	return m.clearedservice_schedules
}

// RemoveServiceScheduleIDs removes the "service_schedules" edge to the ServiceSchedule entity by IDs.
func (m *CarMutation) RemoveServiceScheduleIDs(ids ...uuid.UUID) {
	if m.removedservice_schedules == nil {
		m.removedservice_schedules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.service_schedules, ids[i])
		m.removedservice_schedules[ids[i]] = struct{}{}
	}
}

// RemovedServiceSchedules returns the removed IDs of the "service_schedules" edge to the ServiceSchedule entity.
func (m *CarMutation) RemovedServiceSchedulesIDs() (ids []uuid.UUID) {
	for id := range m.removedservice_schedules {
		ids = append(ids, id)
	}
	return
}

// ServiceSchedulesIDs returns the "service_schedules" edge IDs in the mutation.
func (m *CarMutation) ServiceSchedulesIDs() (ids []uuid.UUID) {
	for id := range m.service_schedules {
		ids = append(ids, id)
	}
	return
}

// ResetServiceSchedules resets all changes to the "service_schedules" edge.
func (m *CarMutation) ResetServiceSchedules() {
	m.service_schedules = nil
	m.clearedservice_schedules = false
	m.removedservice_schedules = nil
}

// AddMediumIDs adds the "media" edge to the Media entity by ids.
func (m *CarMutation) AddMediumIDs(ids ...uuid.UUID) {
	if m.media == nil {
		m.media = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.media[ids[i]] = struct{}{}
	}
}

// ClearMedia clears the "media" edge to the Media entity.
func (m *CarMutation) ClearMedia() {
	m.clearedmedia = true
}

// MediaCleared reports if the "media" edge to the Media entity was cleared.
func (m *CarMutation) MediaCleared() bool {
	return m.clearedmedia
}

// RemoveMediumIDs removes the "media" edge to the Media entity by IDs.
func (m *CarMutation) RemoveMediumIDs(ids ...uuid.UUID) {
	if m.removedmedia == nil {
		m.removedmedia = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.media, ids[i])
		m.removedmedia[ids[i]] = struct{}{}
	}
}

// RemovedMedia returns the removed IDs of the "media" edge to the Media entity.
func (m *CarMutation) RemovedMediaIDs() (ids []uuid.UUID) {
	for id := range m.removedmedia {
		ids = append(ids, id)
	}
	return
}

// MediaIDs returns the "media" edge IDs in the mutation.
func (m *CarMutation) MediaIDs() (ids []uuid.UUID) {
	for id := range m.media {
		ids = append(ids, id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *CarMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
	m.removedmedia = nil
}

// AddAlbumIDs adds the "albums" edge to the Album entity by ids.
func (m *CarMutation) AddAlbumIDs(ids ...uuid.UUID) {
	if m.albums == nil {
		m.albums = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.albums[ids[i]] = struct{}{}
	}
}

// ClearAlbums clears the "albums" edge to the Album entity.
func (m *CarMutation) ClearAlbums() {
	m.clearedalbums = true
}

// AlbumsCleared reports if the "albums" edge to the Album entity was cleared.
func (m *CarMutation) AlbumsCleared() bool {
	return m.clearedalbums
}

// RemoveAlbumIDs removes the "albums" edge to the Album entity by IDs.
func (m *CarMutation) RemoveAlbumIDs(ids ...uuid.UUID) {
	if m.removedalbums == nil {
		m.removedalbums = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.albums, ids[i])
		m.removedalbums[ids[i]] = struct{}{}
	}
}

// RemovedAlbums returns the removed IDs of the "albums" edge to the Album entity.
func (m *CarMutation) RemovedAlbumsIDs() (ids []uuid.UUID) {
	for id := range m.removedalbums {
		ids = append(ids, id)
	}
	return
}

// AlbumsIDs returns the "albums" edge IDs in the mutation.
func (m *CarMutation) AlbumsIDs() (ids []uuid.UUID) {
	for id := range m.albums {
		ids = append(ids, id)
	}
	return
}

// ResetAlbums resets all changes to the "albums" edge.
func (m *CarMutation) ResetAlbums() {
	m.albums = nil
	m.clearedalbums = false
	m.removedalbums = nil
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *CarMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *CarMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *CarMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *CarMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *CarMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *CarMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *CarMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// AddDynoSessionIDs adds the "dyno_sessions" edge to the DynoSession entity by ids.
func (m *CarMutation) AddDynoSessionIDs(ids ...uuid.UUID) {
	if m.dyno_sessions == nil {
		m.dyno_sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.dyno_sessions[ids[i]] = struct{}{}
	}
}

// ClearDynoSessions clears the "dyno_sessions" edge to the DynoSession entity.
func (m *CarMutation) ClearDynoSessions() {
	m.cleareddyno_sessions = true
}

// DynoSessionsCleared reports if the "dyno_sessions" edge to the DynoSession entity was cleared.
func (m *CarMutation) DynoSessionsCleared() bool {
	return m.cleareddyno_sessions
}

// RemoveDynoSessionIDs removes the "dyno_sessions" edge to the DynoSession entity by IDs.
func (m *CarMutation) RemoveDynoSessionIDs(ids ...uuid.UUID) {
	if m.removeddyno_sessions == nil {
		m.removeddyno_sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.dyno_sessions, ids[i])
		m.removeddyno_sessions[ids[i]] = struct{}{}
	}
}

// RemovedDynoSessions returns the removed IDs of the "dyno_sessions" edge to the DynoSession entity.
func (m *CarMutation) RemovedDynoSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removeddyno_sessions {
		ids = append(ids, id)
	}
	return
}

// DynoSessionsIDs returns the "dyno_sessions" edge IDs in the mutation.
func (m *CarMutation) DynoSessionsIDs() (ids []uuid.UUID) {
	for id := range m.dyno_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetDynoSessions resets all changes to the "dyno_sessions" edge.
func (m *CarMutation) ResetDynoSessions() {
	m.dyno_sessions = nil
	m.cleareddyno_sessions = false
	m.removeddyno_sessions = nil
}

// AddExpenseIDs adds the "expenses" edge to the Expense entity by ids.
func (m *CarMutation) AddExpenseIDs(ids ...uuid.UUID) {
	if m.expenses == nil {
		m.expenses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.expenses[ids[i]] = struct{}{}
	}
}

// ClearExpenses clears the "expenses" edge to the Expense entity.
func (m *CarMutation) ClearExpenses() {
	m.clearedexpenses = true
}

// ExpensesCleared reports if the "expenses" edge to the Expense entity was cleared.
func (m *CarMutation) ExpensesCleared() bool {
	return m.clearedexpenses
}

// RemoveExpenseIDs removes the "expenses" edge to the Expense entity by IDs.
func (m *CarMutation) RemoveExpenseIDs(ids ...uuid.UUID) {
	if m.removedexpenses == nil {
		m.removedexpenses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.expenses, ids[i])
		m.removedexpenses[ids[i]] = struct{}{}
	}
}

// RemovedExpenses returns the removed IDs of the "expenses" edge to the Expense entity.
func (m *CarMutation) RemovedExpensesIDs() (ids []uuid.UUID) {
	for id := range m.removedexpenses {
		ids = append(ids, id)
	}
	return
}

// ExpensesIDs returns the "expenses" edge IDs in the mutation.
func (m *CarMutation) ExpensesIDs() (ids []uuid.UUID) {
	for id := range m.expenses {
		ids = append(ids, id)
	}
	return
}

// ResetExpenses resets all changes to the "expenses" edge.
func (m *CarMutation) ResetExpenses() {
	m.expenses = nil
	m.clearedexpenses = false
	m.removedexpenses = nil
}

// SetBannerImageID sets the "banner_image" edge to the Media entity by id.
func (m *CarMutation) SetBannerImageID(id uuid.UUID) {
	m.banner_image = &id
}

// ClearBannerImage clears the "banner_image" edge to the Media entity.
func (m *CarMutation) ClearBannerImage() {
	m.clearedbanner_image = true
}

// BannerImageCleared reports if the "banner_image" edge to the Media entity was cleared.
func (m *CarMutation) BannerImageCleared() bool {
	return m.clearedbanner_image
}

// BannerImageID returns the "banner_image" edge ID in the mutation.
func (m *CarMutation) BannerImageID() (id uuid.UUID, exists bool) {
	if m.banner_image != nil {
		return *m.banner_image, true
	}
	return
}

// BannerImageIDs returns the "banner_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BannerImageID instead. It exists only for internal usage by the builders.
func (m *CarMutation) BannerImageIDs() (ids []uuid.UUID) {
	if id := m.banner_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBannerImage resets all changes to the "banner_image" edge.
func (m *CarMutation) ResetBannerImage() {
	m.banner_image = nil
	m.clearedbanner_image = false
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *CarMutation) AddTaskIDs(ids ...uuid.UUID) {
	if m.tasks == nil {
		m.tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *CarMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *CarMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *CarMutation) RemoveTaskIDs(ids ...uuid.UUID) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *CarMutation) RemovedTasksIDs() (ids []uuid.UUID) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *CarMutation) TasksIDs() (ids []uuid.UUID) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *CarMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddModIdeaIDs adds the "mod_ideas" edge to the ModIdea entity by ids.
func (m *CarMutation) AddModIdeaIDs(ids ...uuid.UUID) {
	if m.mod_ideas == nil {
		m.mod_ideas = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.mod_ideas[ids[i]] = struct{}{}
	}
}

// ClearModIdeas clears the "mod_ideas" edge to the ModIdea entity.
func (m *CarMutation) ClearModIdeas() {
	m.clearedmod_ideas = true
}

// ModIdeasCleared reports if the "mod_ideas" edge to the ModIdea entity was cleared.
func (m *CarMutation) ModIdeasCleared() bool {
	return m.clearedmod_ideas
}

// RemoveModIdeaIDs removes the "mod_ideas" edge to the ModIdea entity by IDs.
func (m *CarMutation) RemoveModIdeaIDs(ids ...uuid.UUID) {
	if m.removedmod_ideas == nil {
		m.removedmod_ideas = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.mod_ideas, ids[i])
		m.removedmod_ideas[ids[i]] = struct{}{}
	}
}

// RemovedModIdeas returns the removed IDs of the "mod_ideas" edge to the ModIdea entity.
func (m *CarMutation) RemovedModIdeasIDs() (ids []uuid.UUID) {
	for id := range m.removedmod_ideas {
		ids = append(ids, id)
	}
	return
}

// ModIdeasIDs returns the "mod_ideas" edge IDs in the mutation.
func (m *CarMutation) ModIdeasIDs() (ids []uuid.UUID) {
	for id := range m.mod_ideas {
		ids = append(ids, id)
	}
	return
}

// ResetModIdeas resets all changes to the "mod_ideas" edge.
func (m *CarMutation) ResetModIdeas() {
	m.mod_ideas = nil
	m.clearedmod_ideas = false
	m.removedmod_ideas = nil
}

// Where appends a list predicates to the CarMutation builder.
func (m *CarMutation) Where(ps ...predicate.Car) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Car, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Car).
func (m *CarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, car.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, car.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, car.FieldName)
	}
	if m.make != nil {
		fields = append(fields, car.FieldMake)
	}
	if m.model != nil {
		fields = append(fields, car.FieldModel)
	}
	if m._type != nil {
		fields = append(fields, car.FieldType)
	}
	if m.year != nil {
		fields = append(fields, car.FieldYear)
	}
	if m.trim != nil {
		fields = append(fields, car.FieldTrim)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case car.FieldCreateTime:
		return m.CreateTime()
	case car.FieldUpdateTime:
		return m.UpdateTime()
	case car.FieldName:
		return m.Name()
	case car.FieldMake:
		return m.Make()
	case car.FieldModel:
		return m.Model()
	case car.FieldType:
		return m.GetType()
	case car.FieldYear:
		return m.Year()
	case car.FieldTrim:
		return m.Trim()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case car.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case car.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case car.FieldName:
		return m.OldName(ctx)
	case car.FieldMake:
		return m.OldMake(ctx)
	case car.FieldModel:
		return m.OldModel(ctx)
	case car.FieldType:
		return m.OldType(ctx)
	case car.FieldYear:
		return m.OldYear(ctx)
	case car.FieldTrim:
		return m.OldTrim(ctx)
	}
	return nil, fmt.Errorf("unknown Car field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case car.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case car.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case car.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case car.FieldMake:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMake(v)
		return nil
	case car.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case car.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case car.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case car.FieldTrim:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrim(v)
		return nil
	}
	return fmt.Errorf("unknown Car field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, car.FieldYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case car.FieldYear:
		return m.AddedYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarMutation) AddField(name string, value ent.Value) error {
	switch name {
	case car.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	}
	return fmt.Errorf("unknown Car numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(car.FieldMake) {
		fields = append(fields, car.FieldMake)
	}
	if m.FieldCleared(car.FieldModel) {
		fields = append(fields, car.FieldModel)
	}
	if m.FieldCleared(car.FieldType) {
		fields = append(fields, car.FieldType)
	}
	if m.FieldCleared(car.FieldYear) {
		fields = append(fields, car.FieldYear)
	}
	if m.FieldCleared(car.FieldTrim) {
		fields = append(fields, car.FieldTrim)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarMutation) ClearField(name string) error {
	switch name {
	case car.FieldMake:
		m.ClearMake()
		return nil
	case car.FieldModel:
		m.ClearModel()
		return nil
	case car.FieldType:
		m.ClearType()
		return nil
	case car.FieldYear:
		m.ClearYear()
		return nil
	case car.FieldTrim:
		m.ClearTrim()
		return nil
	}
	return fmt.Errorf("unknown Car nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarMutation) ResetField(name string) error {
	switch name {
	case car.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case car.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case car.FieldName:
		m.ResetName()
		return nil
	case car.FieldMake:
		m.ResetMake()
		return nil
	case car.FieldModel:
		m.ResetModel()
		return nil
	case car.FieldType:
		m.ResetType()
		return nil
	case car.FieldYear:
		m.ResetYear()
		return nil
	case car.FieldTrim:
		m.ResetTrim()
		return nil
	}
	return fmt.Errorf("unknown Car field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarMutation) AddedEdges() []string {
	edges := make([]string, 0, 15)
	if m.owner != nil {
		edges = append(edges, car.EdgeOwner)
	}
	if m.drag_sessions != nil {
		edges = append(edges, car.EdgeDragSessions)
	}
	if m.fuel_ups != nil {
		edges = append(edges, car.EdgeFuelUps)
	}
	if m.odometer_readings != nil {
		edges = append(edges, car.EdgeOdometerReadings)
	}
	if m.service_items != nil {
		edges = append(edges, car.EdgeServiceItems)
	}
	if m.service_logs != nil {
		edges = append(edges, car.EdgeServiceLogs)
	}
	if m.service_schedules != nil {
		edges = append(edges, car.EdgeServiceSchedules)
	}
	if m.media != nil {
		edges = append(edges, car.EdgeMedia)
	}
	if m.albums != nil {
		edges = append(edges, car.EdgeAlbums)
	}
	if m.documents != nil {
		edges = append(edges, car.EdgeDocuments)
	}
	if m.dyno_sessions != nil {
		edges = append(edges, car.EdgeDynoSessions)
	}
	if m.expenses != nil {
		edges = append(edges, car.EdgeExpenses)
	}
	if m.banner_image != nil {
		edges = append(edges, car.EdgeBannerImage)
	}
	if m.tasks != nil {
		edges = append(edges, car.EdgeTasks)
	}
	if m.mod_ideas != nil {
		edges = append(edges, car.EdgeModIdeas)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case car.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case car.EdgeDragSessions:
		ids := make([]ent.Value, 0, len(m.drag_sessions))
		for id := range m.drag_sessions {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeFuelUps:
		ids := make([]ent.Value, 0, len(m.fuel_ups))
		for id := range m.fuel_ups {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeOdometerReadings:
		ids := make([]ent.Value, 0, len(m.odometer_readings))
		for id := range m.odometer_readings {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeServiceItems:
		ids := make([]ent.Value, 0, len(m.service_items))
		for id := range m.service_items {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeServiceLogs:
		ids := make([]ent.Value, 0, len(m.service_logs))
		for id := range m.service_logs {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeServiceSchedules:
		ids := make([]ent.Value, 0, len(m.service_schedules))
		for id := range m.service_schedules {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.media))
		for id := range m.media {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeAlbums:
		ids := make([]ent.Value, 0, len(m.albums))
		for id := range m.albums {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeDynoSessions:
		ids := make([]ent.Value, 0, len(m.dyno_sessions))
		for id := range m.dyno_sessions {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeExpenses:
		ids := make([]ent.Value, 0, len(m.expenses))
		for id := range m.expenses {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeBannerImage:
		if id := m.banner_image; id != nil {
			return []ent.Value{*id}
		}
	case car.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeModIdeas:
		ids := make([]ent.Value, 0, len(m.mod_ideas))
		for id := range m.mod_ideas {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 15)
	if m.removeddrag_sessions != nil {
		edges = append(edges, car.EdgeDragSessions)
	}
	if m.removedfuel_ups != nil {
		edges = append(edges, car.EdgeFuelUps)
	}
	if m.removedodometer_readings != nil {
		edges = append(edges, car.EdgeOdometerReadings)
	}
	if m.removedservice_items != nil {
		edges = append(edges, car.EdgeServiceItems)
	}
	if m.removedservice_logs != nil {
		edges = append(edges, car.EdgeServiceLogs)
	}
	if m.removedservice_schedules != nil {
		edges = append(edges, car.EdgeServiceSchedules)
	}
	if m.removedmedia != nil {
		edges = append(edges, car.EdgeMedia)
	}
	if m.removedalbums != nil {
		edges = append(edges, car.EdgeAlbums)
	}
	if m.removeddocuments != nil {
		edges = append(edges, car.EdgeDocuments)
	}
	if m.removeddyno_sessions != nil {
		edges = append(edges, car.EdgeDynoSessions)
	}
	if m.removedexpenses != nil {
		edges = append(edges, car.EdgeExpenses)
	}
	if m.removedtasks != nil {
		edges = append(edges, car.EdgeTasks)
	}
	if m.removedmod_ideas != nil {
		edges = append(edges, car.EdgeModIdeas)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case car.EdgeDragSessions:
		ids := make([]ent.Value, 0, len(m.removeddrag_sessions))
		for id := range m.removeddrag_sessions {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeFuelUps:
		ids := make([]ent.Value, 0, len(m.removedfuel_ups))
		for id := range m.removedfuel_ups {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeOdometerReadings:
		ids := make([]ent.Value, 0, len(m.removedodometer_readings))
		for id := range m.removedodometer_readings {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeServiceItems:
		ids := make([]ent.Value, 0, len(m.removedservice_items))
		for id := range m.removedservice_items {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeServiceLogs:
		ids := make([]ent.Value, 0, len(m.removedservice_logs))
		for id := range m.removedservice_logs {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeServiceSchedules:
		ids := make([]ent.Value, 0, len(m.removedservice_schedules))
		for id := range m.removedservice_schedules {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.removedmedia))
		for id := range m.removedmedia {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeAlbums:
		ids := make([]ent.Value, 0, len(m.removedalbums))
		for id := range m.removedalbums {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeDynoSessions:
		ids := make([]ent.Value, 0, len(m.removeddyno_sessions))
		for id := range m.removeddyno_sessions {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeExpenses:
		ids := make([]ent.Value, 0, len(m.removedexpenses))
		for id := range m.removedexpenses {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeModIdeas:
		ids := make([]ent.Value, 0, len(m.removedmod_ideas))
		for id := range m.removedmod_ideas {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 15)
	if m.clearedowner {
		edges = append(edges, car.EdgeOwner)
	}
	if m.cleareddrag_sessions {
		edges = append(edges, car.EdgeDragSessions)
	}
	if m.clearedfuel_ups {
		edges = append(edges, car.EdgeFuelUps)
	}
	if m.clearedodometer_readings {
		edges = append(edges, car.EdgeOdometerReadings)
	}
	if m.clearedservice_items {
		edges = append(edges, car.EdgeServiceItems)
	}
	if m.clearedservice_logs {
		edges = append(edges, car.EdgeServiceLogs)
	}
	if m.clearedservice_schedules {
		edges = append(edges, car.EdgeServiceSchedules)
	}
	if m.clearedmedia {
		edges = append(edges, car.EdgeMedia)
	}
	if m.clearedalbums {
		edges = append(edges, car.EdgeAlbums)
	}
	if m.cleareddocuments {
		edges = append(edges, car.EdgeDocuments)
	}
	if m.cleareddyno_sessions {
		edges = append(edges, car.EdgeDynoSessions)
	}
	if m.clearedexpenses {
		edges = append(edges, car.EdgeExpenses)
	}
	if m.clearedbanner_image {
		edges = append(edges, car.EdgeBannerImage)
	}
	if m.clearedtasks {
		edges = append(edges, car.EdgeTasks)
	}
	if m.clearedmod_ideas {
		edges = append(edges, car.EdgeModIdeas)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarMutation) EdgeCleared(name string) bool {
	switch name {
	case car.EdgeOwner:
		return m.clearedowner
	case car.EdgeDragSessions:
		return m.cleareddrag_sessions
	case car.EdgeFuelUps:
		return m.clearedfuel_ups
	case car.EdgeOdometerReadings:
		return m.clearedodometer_readings
	case car.EdgeServiceItems:
		return m.clearedservice_items
	case car.EdgeServiceLogs:
		return m.clearedservice_logs
	case car.EdgeServiceSchedules:
		return m.clearedservice_schedules
	case car.EdgeMedia:
		return m.clearedmedia
	case car.EdgeAlbums:
		return m.clearedalbums
	case car.EdgeDocuments:
		return m.cleareddocuments
	case car.EdgeDynoSessions:
		return m.cleareddyno_sessions
	case car.EdgeExpenses:
		return m.clearedexpenses
	case car.EdgeBannerImage:
		return m.clearedbanner_image
	case car.EdgeTasks:
		return m.clearedtasks
	case car.EdgeModIdeas:
		return m.clearedmod_ideas
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarMutation) ClearEdge(name string) error {
	switch name {
	case car.EdgeOwner:
		m.ClearOwner()
		return nil
	case car.EdgeBannerImage:
		m.ClearBannerImage()
		return nil
	}
	return fmt.Errorf("unknown Car unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarMutation) ResetEdge(name string) error {
	switch name {
	case car.EdgeOwner:
		m.ResetOwner()
		return nil
	case car.EdgeDragSessions:
		m.ResetDragSessions()
		return nil
	case car.EdgeFuelUps:
		m.ResetFuelUps()
		return nil
	case car.EdgeOdometerReadings:
		m.ResetOdometerReadings()
		return nil
	case car.EdgeServiceItems:
		m.ResetServiceItems()
		return nil
	case car.EdgeServiceLogs:
		m.ResetServiceLogs()
		return nil
	case car.EdgeServiceSchedules:
		m.ResetServiceSchedules()
		return nil
	case car.EdgeMedia:
		m.ResetMedia()
		return nil
	case car.EdgeAlbums:
		m.ResetAlbums()
		return nil
	case car.EdgeDocuments:
		m.ResetDocuments()
		return nil
	case car.EdgeDynoSessions:
		m.ResetDynoSessions()
		return nil
	case car.EdgeExpenses:
		m.ResetExpenses()
		return nil
	case car.EdgeBannerImage:
		m.ResetBannerImage()
		return nil
	case car.EdgeTasks:
		m.ResetTasks()
		return nil
	case car.EdgeModIdeas:
		m.ResetModIdeas()
		return nil
	}
	return fmt.Errorf("unknown Car edge %s", name)
}

// CheckoutSessionMutation represents an operation that mutates the CheckoutSession nodes in the graph.
type CheckoutSessionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	create_time         *time.Time
	update_time         *time.Time
	stripe_session_id   *string
	stripe_price_id     *string
	mode                *checkoutsession.Mode
	completed           *bool
	completed_at        *time.Time
	affiliate_6mo_code  *string
	affiliate_12mo_code *string
	clearedFields       map[string]struct{}
	user                *uuid.UUID
	cleareduser         bool
	subscription        *uuid.UUID
	clearedsubscription bool
	done                bool
	oldValue            func(context.Context) (*CheckoutSession, error)
	predicates          []predicate.CheckoutSession
}

var _ ent.Mutation = (*CheckoutSessionMutation)(nil)

// checkoutsessionOption allows management of the mutation configuration using functional options.
type checkoutsessionOption func(*CheckoutSessionMutation)

// newCheckoutSessionMutation creates new mutation for the CheckoutSession entity.
func newCheckoutSessionMutation(c config, op Op, opts ...checkoutsessionOption) *CheckoutSessionMutation {
	m := &CheckoutSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeCheckoutSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCheckoutSessionID sets the ID field of the mutation.
func withCheckoutSessionID(id uuid.UUID) checkoutsessionOption {
	return func(m *CheckoutSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *CheckoutSession
		)
		m.oldValue = func(ctx context.Context) (*CheckoutSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CheckoutSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCheckoutSession sets the old CheckoutSession of the mutation.
func withCheckoutSession(node *CheckoutSession) checkoutsessionOption {
	return func(m *CheckoutSessionMutation) {
		m.oldValue = func(context.Context) (*CheckoutSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CheckoutSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CheckoutSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CheckoutSession entities.
func (m *CheckoutSessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CheckoutSessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CheckoutSessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CheckoutSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CheckoutSessionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CheckoutSessionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CheckoutSession entity.
// If the CheckoutSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutSessionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CheckoutSessionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CheckoutSessionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CheckoutSessionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CheckoutSession entity.
// If the CheckoutSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutSessionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CheckoutSessionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStripeSessionID sets the "stripe_session_id" field.
func (m *CheckoutSessionMutation) SetStripeSessionID(s string) {
	m.stripe_session_id = &s
}

// StripeSessionID returns the value of the "stripe_session_id" field in the mutation.
func (m *CheckoutSessionMutation) StripeSessionID() (r string, exists bool) {
	v := m.stripe_session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeSessionID returns the old "stripe_session_id" field's value of the CheckoutSession entity.
// If the CheckoutSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutSessionMutation) OldStripeSessionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeSessionID: %w", err)
	}
	return oldValue.StripeSessionID, nil
}

// ClearStripeSessionID clears the value of the "stripe_session_id" field.
func (m *CheckoutSessionMutation) ClearStripeSessionID() {
	m.stripe_session_id = nil
	m.clearedFields[checkoutsession.FieldStripeSessionID] = struct{}{}
}

// StripeSessionIDCleared returns if the "stripe_session_id" field was cleared in this mutation.
func (m *CheckoutSessionMutation) StripeSessionIDCleared() bool {
	_, ok := m.clearedFields[checkoutsession.FieldStripeSessionID]
	return ok
}

// ResetStripeSessionID resets all changes to the "stripe_session_id" field.
func (m *CheckoutSessionMutation) ResetStripeSessionID() {
	m.stripe_session_id = nil
	delete(m.clearedFields, checkoutsession.FieldStripeSessionID)
}

// SetStripePriceID sets the "stripe_price_id" field.
func (m *CheckoutSessionMutation) SetStripePriceID(s string) {
	m.stripe_price_id = &s
}

// StripePriceID returns the value of the "stripe_price_id" field in the mutation.
func (m *CheckoutSessionMutation) StripePriceID() (r string, exists bool) {
	v := m.stripe_price_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripePriceID returns the old "stripe_price_id" field's value of the CheckoutSession entity.
// If the CheckoutSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutSessionMutation) OldStripePriceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripePriceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripePriceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripePriceID: %w", err)
	}
	return oldValue.StripePriceID, nil
}

// ResetStripePriceID resets all changes to the "stripe_price_id" field.
func (m *CheckoutSessionMutation) ResetStripePriceID() {
	m.stripe_price_id = nil
}

// SetMode sets the "mode" field.
func (m *CheckoutSessionMutation) SetMode(c checkoutsession.Mode) {
	m.mode = &c
}

// Mode returns the value of the "mode" field in the mutation.
func (m *CheckoutSessionMutation) Mode() (r checkoutsession.Mode, exists bool) {
	v := m.mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMode returns the old "mode" field's value of the CheckoutSession entity.
// If the CheckoutSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutSessionMutation) OldMode(ctx context.Context) (v checkoutsession.Mode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMode: %w", err)
	}
	return oldValue.Mode, nil
}

// ResetMode resets all changes to the "mode" field.
func (m *CheckoutSessionMutation) ResetMode() {
	m.mode = nil
}

// SetCompleted sets the "completed" field.
func (m *CheckoutSessionMutation) SetCompleted(b bool) {
	m.completed = &b
}

// Completed returns the value of the "completed" field in the mutation.
func (m *CheckoutSessionMutation) Completed() (r bool, exists bool) {
	v := m.completed
	if v == nil {
		return
	}
	return *v, true
}

// OldCompleted returns the old "completed" field's value of the CheckoutSession entity.
// If the CheckoutSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutSessionMutation) OldCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompleted: %w", err)
	}
	return oldValue.Completed, nil
}

// ResetCompleted resets all changes to the "completed" field.
func (m *CheckoutSessionMutation) ResetCompleted() {
	m.completed = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *CheckoutSessionMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *CheckoutSessionMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the CheckoutSession entity.
// If the CheckoutSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutSessionMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *CheckoutSessionMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[checkoutsession.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *CheckoutSessionMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[checkoutsession.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *CheckoutSessionMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, checkoutsession.FieldCompletedAt)
}

// SetAffiliate6moCode sets the "affiliate_6mo_code" field.
func (m *CheckoutSessionMutation) SetAffiliate6moCode(s string) {
	m.affiliate_6mo_code = &s
}

// Affiliate6moCode returns the value of the "affiliate_6mo_code" field in the mutation.
func (m *CheckoutSessionMutation) Affiliate6moCode() (r string, exists bool) {
	v := m.affiliate_6mo_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAffiliate6moCode returns the old "affiliate_6mo_code" field's value of the CheckoutSession entity.
// If the CheckoutSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutSessionMutation) OldAffiliate6moCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAffiliate6moCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAffiliate6moCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAffiliate6moCode: %w", err)
	}
	return oldValue.Affiliate6moCode, nil
}

// ClearAffiliate6moCode clears the value of the "affiliate_6mo_code" field.
func (m *CheckoutSessionMutation) ClearAffiliate6moCode() {
	m.affiliate_6mo_code = nil
	m.clearedFields[checkoutsession.FieldAffiliate6moCode] = struct{}{}
}

// Affiliate6moCodeCleared returns if the "affiliate_6mo_code" field was cleared in this mutation.
func (m *CheckoutSessionMutation) Affiliate6moCodeCleared() bool {
	_, ok := m.clearedFields[checkoutsession.FieldAffiliate6moCode]
	return ok
}

// ResetAffiliate6moCode resets all changes to the "affiliate_6mo_code" field.
func (m *CheckoutSessionMutation) ResetAffiliate6moCode() {
	m.affiliate_6mo_code = nil
	delete(m.clearedFields, checkoutsession.FieldAffiliate6moCode)
}

// SetAffiliate12moCode sets the "affiliate_12mo_code" field.
func (m *CheckoutSessionMutation) SetAffiliate12moCode(s string) {
	m.affiliate_12mo_code = &s
}

// Affiliate12moCode returns the value of the "affiliate_12mo_code" field in the mutation.
func (m *CheckoutSessionMutation) Affiliate12moCode() (r string, exists bool) {
	v := m.affiliate_12mo_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAffiliate12moCode returns the old "affiliate_12mo_code" field's value of the CheckoutSession entity.
// If the CheckoutSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckoutSessionMutation) OldAffiliate12moCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAffiliate12moCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAffiliate12moCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAffiliate12moCode: %w", err)
	}
	return oldValue.Affiliate12moCode, nil
}

// ClearAffiliate12moCode clears the value of the "affiliate_12mo_code" field.
func (m *CheckoutSessionMutation) ClearAffiliate12moCode() {
	m.affiliate_12mo_code = nil
	m.clearedFields[checkoutsession.FieldAffiliate12moCode] = struct{}{}
}

// Affiliate12moCodeCleared returns if the "affiliate_12mo_code" field was cleared in this mutation.
func (m *CheckoutSessionMutation) Affiliate12moCodeCleared() bool {
	_, ok := m.clearedFields[checkoutsession.FieldAffiliate12moCode]
	return ok
}

// ResetAffiliate12moCode resets all changes to the "affiliate_12mo_code" field.
func (m *CheckoutSessionMutation) ResetAffiliate12moCode() {
	m.affiliate_12mo_code = nil
	delete(m.clearedFields, checkoutsession.FieldAffiliate12moCode)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CheckoutSessionMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CheckoutSessionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CheckoutSessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CheckoutSessionMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CheckoutSessionMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CheckoutSessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetSubscriptionID sets the "subscription" edge to the Subscription entity by id.
func (m *CheckoutSessionMutation) SetSubscriptionID(id uuid.UUID) {
	m.subscription = &id
}

// ClearSubscription clears the "subscription" edge to the Subscription entity.
func (m *CheckoutSessionMutation) ClearSubscription() {
	m.clearedsubscription = true
}

// SubscriptionCleared reports if the "subscription" edge to the Subscription entity was cleared.
func (m *CheckoutSessionMutation) SubscriptionCleared() bool {
	return m.clearedsubscription
}

// SubscriptionID returns the "subscription" edge ID in the mutation.
func (m *CheckoutSessionMutation) SubscriptionID() (id uuid.UUID, exists bool) {
	if m.subscription != nil {
		return *m.subscription, true
	}
	return
}

// SubscriptionIDs returns the "subscription" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionID instead. It exists only for internal usage by the builders.
func (m *CheckoutSessionMutation) SubscriptionIDs() (ids []uuid.UUID) {
	if id := m.subscription; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscription resets all changes to the "subscription" edge.
func (m *CheckoutSessionMutation) ResetSubscription() {
	m.subscription = nil
	m.clearedsubscription = false
}

// Where appends a list predicates to the CheckoutSessionMutation builder.
func (m *CheckoutSessionMutation) Where(ps ...predicate.CheckoutSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CheckoutSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CheckoutSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CheckoutSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CheckoutSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CheckoutSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CheckoutSession).
func (m *CheckoutSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CheckoutSessionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, checkoutsession.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, checkoutsession.FieldUpdateTime)
	}
	if m.stripe_session_id != nil {
		fields = append(fields, checkoutsession.FieldStripeSessionID)
	}
	if m.stripe_price_id != nil {
		fields = append(fields, checkoutsession.FieldStripePriceID)
	}
	if m.mode != nil {
		fields = append(fields, checkoutsession.FieldMode)
	}
	if m.completed != nil {
		fields = append(fields, checkoutsession.FieldCompleted)
	}
	if m.completed_at != nil {
		fields = append(fields, checkoutsession.FieldCompletedAt)
	}
	if m.affiliate_6mo_code != nil {
		fields = append(fields, checkoutsession.FieldAffiliate6moCode)
	}
	if m.affiliate_12mo_code != nil {
		fields = append(fields, checkoutsession.FieldAffiliate12moCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CheckoutSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case checkoutsession.FieldCreateTime:
		return m.CreateTime()
	case checkoutsession.FieldUpdateTime:
		return m.UpdateTime()
	case checkoutsession.FieldStripeSessionID:
		return m.StripeSessionID()
	case checkoutsession.FieldStripePriceID:
		return m.StripePriceID()
	case checkoutsession.FieldMode:
		return m.Mode()
	case checkoutsession.FieldCompleted:
		return m.Completed()
	case checkoutsession.FieldCompletedAt:
		return m.CompletedAt()
	case checkoutsession.FieldAffiliate6moCode:
		return m.Affiliate6moCode()
	case checkoutsession.FieldAffiliate12moCode:
		return m.Affiliate12moCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CheckoutSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case checkoutsession.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case checkoutsession.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case checkoutsession.FieldStripeSessionID:
		return m.OldStripeSessionID(ctx)
	case checkoutsession.FieldStripePriceID:
		return m.OldStripePriceID(ctx)
	case checkoutsession.FieldMode:
		return m.OldMode(ctx)
	case checkoutsession.FieldCompleted:
		return m.OldCompleted(ctx)
	case checkoutsession.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case checkoutsession.FieldAffiliate6moCode:
		return m.OldAffiliate6moCode(ctx)
	case checkoutsession.FieldAffiliate12moCode:
		return m.OldAffiliate12moCode(ctx)
	}
	return nil, fmt.Errorf("unknown CheckoutSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckoutSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case checkoutsession.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case checkoutsession.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case checkoutsession.FieldStripeSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeSessionID(v)
		return nil
	case checkoutsession.FieldStripePriceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripePriceID(v)
		return nil
	case checkoutsession.FieldMode:
		v, ok := value.(checkoutsession.Mode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMode(v)
		return nil
	case checkoutsession.FieldCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompleted(v)
		return nil
	case checkoutsession.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case checkoutsession.FieldAffiliate6moCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAffiliate6moCode(v)
		return nil
	case checkoutsession.FieldAffiliate12moCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAffiliate12moCode(v)
		return nil
	}
	return fmt.Errorf("unknown CheckoutSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CheckoutSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CheckoutSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckoutSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CheckoutSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CheckoutSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(checkoutsession.FieldStripeSessionID) {
		fields = append(fields, checkoutsession.FieldStripeSessionID)
	}
	if m.FieldCleared(checkoutsession.FieldCompletedAt) {
		fields = append(fields, checkoutsession.FieldCompletedAt)
	}
	if m.FieldCleared(checkoutsession.FieldAffiliate6moCode) {
		fields = append(fields, checkoutsession.FieldAffiliate6moCode)
	}
	if m.FieldCleared(checkoutsession.FieldAffiliate12moCode) {
		fields = append(fields, checkoutsession.FieldAffiliate12moCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CheckoutSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CheckoutSessionMutation) ClearField(name string) error {
	switch name {
	case checkoutsession.FieldStripeSessionID:
		m.ClearStripeSessionID()
		return nil
	case checkoutsession.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case checkoutsession.FieldAffiliate6moCode:
		m.ClearAffiliate6moCode()
		return nil
	case checkoutsession.FieldAffiliate12moCode:
		m.ClearAffiliate12moCode()
		return nil
	}
	return fmt.Errorf("unknown CheckoutSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CheckoutSessionMutation) ResetField(name string) error {
	switch name {
	case checkoutsession.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case checkoutsession.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case checkoutsession.FieldStripeSessionID:
		m.ResetStripeSessionID()
		return nil
	case checkoutsession.FieldStripePriceID:
		m.ResetStripePriceID()
		return nil
	case checkoutsession.FieldMode:
		m.ResetMode()
		return nil
	case checkoutsession.FieldCompleted:
		m.ResetCompleted()
		return nil
	case checkoutsession.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case checkoutsession.FieldAffiliate6moCode:
		m.ResetAffiliate6moCode()
		return nil
	case checkoutsession.FieldAffiliate12moCode:
		m.ResetAffiliate12moCode()
		return nil
	}
	return fmt.Errorf("unknown CheckoutSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CheckoutSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, checkoutsession.EdgeUser)
	}
	if m.subscription != nil {
		edges = append(edges, checkoutsession.EdgeSubscription)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CheckoutSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case checkoutsession.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case checkoutsession.EdgeSubscription:
		if id := m.subscription; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CheckoutSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CheckoutSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CheckoutSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, checkoutsession.EdgeUser)
	}
	if m.clearedsubscription {
		edges = append(edges, checkoutsession.EdgeSubscription)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CheckoutSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case checkoutsession.EdgeUser:
		return m.cleareduser
	case checkoutsession.EdgeSubscription:
		return m.clearedsubscription
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CheckoutSessionMutation) ClearEdge(name string) error {
	switch name {
	case checkoutsession.EdgeUser:
		m.ClearUser()
		return nil
	case checkoutsession.EdgeSubscription:
		m.ClearSubscription()
		return nil
	}
	return fmt.Errorf("unknown CheckoutSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CheckoutSessionMutation) ResetEdge(name string) error {
	switch name {
	case checkoutsession.EdgeUser:
		m.ResetUser()
		return nil
	case checkoutsession.EdgeSubscription:
		m.ResetSubscription()
		return nil
	}
	return fmt.Errorf("unknown CheckoutSession edge %s", name)
}

// DocumentMutation represents an operation that mutates the Document nodes in the graph.
type DocumentMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	create_time         *time.Time
	update_time         *time.Time
	name                *string
	tags                *[]string
	appendtags          []string
	clearedFields       map[string]struct{}
	car                 *uuid.UUID
	clearedcar          bool
	expense             *uuid.UUID
	clearedexpense      bool
	fuel_up             *uuid.UUID
	clearedfuel_up      bool
	service_log         *uuid.UUID
	clearedservice_log  bool
	drag_session        *uuid.UUID
	cleareddrag_session bool
	dyno_session        *uuid.UUID
	cleareddyno_session bool
	done                bool
	oldValue            func(context.Context) (*Document, error)
	predicates          []predicate.Document
}

var _ ent.Mutation = (*DocumentMutation)(nil)

// documentOption allows management of the mutation configuration using functional options.
type documentOption func(*DocumentMutation)

// newDocumentMutation creates new mutation for the Document entity.
func newDocumentMutation(c config, op Op, opts ...documentOption) *DocumentMutation {
	m := &DocumentMutation{
		config:        c,
		op:            op,
		typ:           TypeDocument,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentID sets the ID field of the mutation.
func withDocumentID(id uuid.UUID) documentOption {
	return func(m *DocumentMutation) {
		var (
			err   error
			once  sync.Once
			value *Document
		)
		m.oldValue = func(ctx context.Context) (*Document, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Document.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocument sets the old Document of the mutation.
func withDocument(node *Document) documentOption {
	return func(m *DocumentMutation) {
		m.oldValue = func(context.Context) (*Document, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Document entities.
func (m *DocumentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Document.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *DocumentMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DocumentMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DocumentMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DocumentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DocumentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DocumentMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *DocumentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DocumentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DocumentMutation) ResetName() {
	m.name = nil
}

// SetTags sets the "tags" field.
func (m *DocumentMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *DocumentMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *DocumentMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *DocumentMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *DocumentMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *DocumentMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *DocumentMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *DocumentMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *DocumentMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *DocumentMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// SetExpenseID sets the "expense" edge to the Expense entity by id.
func (m *DocumentMutation) SetExpenseID(id uuid.UUID) {
	m.expense = &id
}

// ClearExpense clears the "expense" edge to the Expense entity.
func (m *DocumentMutation) ClearExpense() {
	m.clearedexpense = true
}

// ExpenseCleared reports if the "expense" edge to the Expense entity was cleared.
func (m *DocumentMutation) ExpenseCleared() bool {
	return m.clearedexpense
}

// ExpenseID returns the "expense" edge ID in the mutation.
func (m *DocumentMutation) ExpenseID() (id uuid.UUID, exists bool) {
	if m.expense != nil {
		return *m.expense, true
	}
	return
}

// ExpenseIDs returns the "expense" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExpenseID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) ExpenseIDs() (ids []uuid.UUID) {
	if id := m.expense; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExpense resets all changes to the "expense" edge.
func (m *DocumentMutation) ResetExpense() {
	m.expense = nil
	m.clearedexpense = false
}

// SetFuelUpID sets the "fuel_up" edge to the FuelUp entity by id.
func (m *DocumentMutation) SetFuelUpID(id uuid.UUID) {
	m.fuel_up = &id
}

// ClearFuelUp clears the "fuel_up" edge to the FuelUp entity.
func (m *DocumentMutation) ClearFuelUp() {
	m.clearedfuel_up = true
}

// FuelUpCleared reports if the "fuel_up" edge to the FuelUp entity was cleared.
func (m *DocumentMutation) FuelUpCleared() bool {
	return m.clearedfuel_up
}

// FuelUpID returns the "fuel_up" edge ID in the mutation.
func (m *DocumentMutation) FuelUpID() (id uuid.UUID, exists bool) {
	if m.fuel_up != nil {
		return *m.fuel_up, true
	}
	return
}

// FuelUpIDs returns the "fuel_up" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FuelUpID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) FuelUpIDs() (ids []uuid.UUID) {
	if id := m.fuel_up; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFuelUp resets all changes to the "fuel_up" edge.
func (m *DocumentMutation) ResetFuelUp() {
	m.fuel_up = nil
	m.clearedfuel_up = false
}

// SetServiceLogID sets the "service_log" edge to the ServiceLog entity by id.
func (m *DocumentMutation) SetServiceLogID(id uuid.UUID) {
	m.service_log = &id
}

// ClearServiceLog clears the "service_log" edge to the ServiceLog entity.
func (m *DocumentMutation) ClearServiceLog() {
	m.clearedservice_log = true
}

// ServiceLogCleared reports if the "service_log" edge to the ServiceLog entity was cleared.
func (m *DocumentMutation) ServiceLogCleared() bool {
	return m.clearedservice_log
}

// ServiceLogID returns the "service_log" edge ID in the mutation.
func (m *DocumentMutation) ServiceLogID() (id uuid.UUID, exists bool) {
	if m.service_log != nil {
		return *m.service_log, true
	}
	return
}

// ServiceLogIDs returns the "service_log" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceLogID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) ServiceLogIDs() (ids []uuid.UUID) {
	if id := m.service_log; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceLog resets all changes to the "service_log" edge.
func (m *DocumentMutation) ResetServiceLog() {
	m.service_log = nil
	m.clearedservice_log = false
}

// SetDragSessionID sets the "drag_session" edge to the DragSession entity by id.
func (m *DocumentMutation) SetDragSessionID(id uuid.UUID) {
	m.drag_session = &id
}

// ClearDragSession clears the "drag_session" edge to the DragSession entity.
func (m *DocumentMutation) ClearDragSession() {
	m.cleareddrag_session = true
}

// DragSessionCleared reports if the "drag_session" edge to the DragSession entity was cleared.
func (m *DocumentMutation) DragSessionCleared() bool {
	return m.cleareddrag_session
}

// DragSessionID returns the "drag_session" edge ID in the mutation.
func (m *DocumentMutation) DragSessionID() (id uuid.UUID, exists bool) {
	if m.drag_session != nil {
		return *m.drag_session, true
	}
	return
}

// DragSessionIDs returns the "drag_session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DragSessionID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) DragSessionIDs() (ids []uuid.UUID) {
	if id := m.drag_session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDragSession resets all changes to the "drag_session" edge.
func (m *DocumentMutation) ResetDragSession() {
	m.drag_session = nil
	m.cleareddrag_session = false
}

// SetDynoSessionID sets the "dyno_session" edge to the DynoSession entity by id.
func (m *DocumentMutation) SetDynoSessionID(id uuid.UUID) {
	m.dyno_session = &id
}

// ClearDynoSession clears the "dyno_session" edge to the DynoSession entity.
func (m *DocumentMutation) ClearDynoSession() {
	m.cleareddyno_session = true
}

// DynoSessionCleared reports if the "dyno_session" edge to the DynoSession entity was cleared.
func (m *DocumentMutation) DynoSessionCleared() bool {
	return m.cleareddyno_session
}

// DynoSessionID returns the "dyno_session" edge ID in the mutation.
func (m *DocumentMutation) DynoSessionID() (id uuid.UUID, exists bool) {
	if m.dyno_session != nil {
		return *m.dyno_session, true
	}
	return
}

// DynoSessionIDs returns the "dyno_session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DynoSessionID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) DynoSessionIDs() (ids []uuid.UUID) {
	if id := m.dyno_session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDynoSession resets all changes to the "dyno_session" edge.
func (m *DocumentMutation) ResetDynoSession() {
	m.dyno_session = nil
	m.cleareddyno_session = false
}

// Where appends a list predicates to the DocumentMutation builder.
func (m *DocumentMutation) Where(ps ...predicate.Document) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Document, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Document).
func (m *DocumentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, document.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, document.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, document.FieldName)
	}
	if m.tags != nil {
		fields = append(fields, document.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case document.FieldCreateTime:
		return m.CreateTime()
	case document.FieldUpdateTime:
		return m.UpdateTime()
	case document.FieldName:
		return m.Name()
	case document.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case document.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case document.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case document.FieldName:
		return m.OldName(ctx)
	case document.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Document field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case document.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case document.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case document.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case document.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Document field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Document numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Document nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentMutation) ResetField(name string) error {
	switch name {
	case document.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case document.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case document.FieldName:
		m.ResetName()
		return nil
	case document.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Document field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.car != nil {
		edges = append(edges, document.EdgeCar)
	}
	if m.expense != nil {
		edges = append(edges, document.EdgeExpense)
	}
	if m.fuel_up != nil {
		edges = append(edges, document.EdgeFuelUp)
	}
	if m.service_log != nil {
		edges = append(edges, document.EdgeServiceLog)
	}
	if m.drag_session != nil {
		edges = append(edges, document.EdgeDragSession)
	}
	if m.dyno_session != nil {
		edges = append(edges, document.EdgeDynoSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case document.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeExpense:
		if id := m.expense; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeFuelUp:
		if id := m.fuel_up; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeServiceLog:
		if id := m.service_log; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeDragSession:
		if id := m.drag_session; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeDynoSession:
		if id := m.dyno_session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcar {
		edges = append(edges, document.EdgeCar)
	}
	if m.clearedexpense {
		edges = append(edges, document.EdgeExpense)
	}
	if m.clearedfuel_up {
		edges = append(edges, document.EdgeFuelUp)
	}
	if m.clearedservice_log {
		edges = append(edges, document.EdgeServiceLog)
	}
	if m.cleareddrag_session {
		edges = append(edges, document.EdgeDragSession)
	}
	if m.cleareddyno_session {
		edges = append(edges, document.EdgeDynoSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentMutation) EdgeCleared(name string) bool {
	switch name {
	case document.EdgeCar:
		return m.clearedcar
	case document.EdgeExpense:
		return m.clearedexpense
	case document.EdgeFuelUp:
		return m.clearedfuel_up
	case document.EdgeServiceLog:
		return m.clearedservice_log
	case document.EdgeDragSession:
		return m.cleareddrag_session
	case document.EdgeDynoSession:
		return m.cleareddyno_session
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentMutation) ClearEdge(name string) error {
	switch name {
	case document.EdgeCar:
		m.ClearCar()
		return nil
	case document.EdgeExpense:
		m.ClearExpense()
		return nil
	case document.EdgeFuelUp:
		m.ClearFuelUp()
		return nil
	case document.EdgeServiceLog:
		m.ClearServiceLog()
		return nil
	case document.EdgeDragSession:
		m.ClearDragSession()
		return nil
	case document.EdgeDynoSession:
		m.ClearDynoSession()
		return nil
	}
	return fmt.Errorf("unknown Document unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentMutation) ResetEdge(name string) error {
	switch name {
	case document.EdgeCar:
		m.ResetCar()
		return nil
	case document.EdgeExpense:
		m.ResetExpense()
		return nil
	case document.EdgeFuelUp:
		m.ResetFuelUp()
		return nil
	case document.EdgeServiceLog:
		m.ResetServiceLog()
		return nil
	case document.EdgeDragSession:
		m.ResetDragSession()
		return nil
	case document.EdgeDynoSession:
		m.ResetDynoSession()
		return nil
	}
	return fmt.Errorf("unknown Document edge %s", name)
}

// DragResultMutation represents an operation that mutates the DragResult nodes in the graph.
type DragResultMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	create_time    *time.Time
	update_time    *time.Time
	unit           *dragresult.Unit
	value          *float64
	addvalue       *float64
	result         *float64
	addresult      *float64
	clearedFields  map[string]struct{}
	session        *uuid.UUID
	clearedsession bool
	done           bool
	oldValue       func(context.Context) (*DragResult, error)
	predicates     []predicate.DragResult
}

var _ ent.Mutation = (*DragResultMutation)(nil)

// dragresultOption allows management of the mutation configuration using functional options.
type dragresultOption func(*DragResultMutation)

// newDragResultMutation creates new mutation for the DragResult entity.
func newDragResultMutation(c config, op Op, opts ...dragresultOption) *DragResultMutation {
	m := &DragResultMutation{
		config:        c,
		op:            op,
		typ:           TypeDragResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDragResultID sets the ID field of the mutation.
func withDragResultID(id uuid.UUID) dragresultOption {
	return func(m *DragResultMutation) {
		var (
			err   error
			once  sync.Once
			value *DragResult
		)
		m.oldValue = func(ctx context.Context) (*DragResult, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DragResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDragResult sets the old DragResult of the mutation.
func withDragResult(node *DragResult) dragresultOption {
	return func(m *DragResultMutation) {
		m.oldValue = func(context.Context) (*DragResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DragResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DragResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DragResult entities.
func (m *DragResultMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DragResultMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DragResultMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DragResult.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *DragResultMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DragResultMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DragResult entity.
// If the DragResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DragResultMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DragResultMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DragResultMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DragResultMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DragResult entity.
// If the DragResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DragResultMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DragResultMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUnit sets the "unit" field.
func (m *DragResultMutation) SetUnit(d dragresult.Unit) {
	m.unit = &d
}

// Unit returns the value of the "unit" field in the mutation.
func (m *DragResultMutation) Unit() (r dragresult.Unit, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the DragResult entity.
// If the DragResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DragResultMutation) OldUnit(ctx context.Context) (v dragresult.Unit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *DragResultMutation) ResetUnit() {
	m.unit = nil
}

// SetValue sets the "value" field.
func (m *DragResultMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *DragResultMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the DragResult entity.
// If the DragResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DragResultMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *DragResultMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *DragResultMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *DragResultMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetResult sets the "result" field.
func (m *DragResultMutation) SetResult(f float64) {
	m.result = &f
	m.addresult = nil
}

// Result returns the value of the "result" field in the mutation.
func (m *DragResultMutation) Result() (r float64, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the DragResult entity.
// If the DragResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DragResultMutation) OldResult(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// AddResult adds f to the "result" field.
func (m *DragResultMutation) AddResult(f float64) {
	if m.addresult != nil {
		*m.addresult += f
	} else {
		m.addresult = &f
	}
}

// AddedResult returns the value that was added to the "result" field in this mutation.
func (m *DragResultMutation) AddedResult() (r float64, exists bool) {
	v := m.addresult
	if v == nil {
		return
	}
	return *v, true
}

// ResetResult resets all changes to the "result" field.
func (m *DragResultMutation) ResetResult() {
	m.result = nil
	m.addresult = nil
}

// SetSessionID sets the "session" edge to the DragSession entity by id.
func (m *DragResultMutation) SetSessionID(id uuid.UUID) {
	m.session = &id
}

// ClearSession clears the "session" edge to the DragSession entity.
func (m *DragResultMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared reports if the "session" edge to the DragSession entity was cleared.
func (m *DragResultMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionID returns the "session" edge ID in the mutation.
func (m *DragResultMutation) SessionID() (id uuid.UUID, exists bool) {
	if m.session != nil {
		return *m.session, true
	}
	return
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *DragResultMutation) SessionIDs() (ids []uuid.UUID) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *DragResultMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// Where appends a list predicates to the DragResultMutation builder.
func (m *DragResultMutation) Where(ps ...predicate.DragResult) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DragResultMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DragResultMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DragResult, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DragResultMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DragResultMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DragResult).
func (m *DragResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DragResultMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, dragresult.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, dragresult.FieldUpdateTime)
	}
	if m.unit != nil {
		fields = append(fields, dragresult.FieldUnit)
	}
	if m.value != nil {
		fields = append(fields, dragresult.FieldValue)
	}
	if m.result != nil {
		fields = append(fields, dragresult.FieldResult)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DragResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dragresult.FieldCreateTime:
		return m.CreateTime()
	case dragresult.FieldUpdateTime:
		return m.UpdateTime()
	case dragresult.FieldUnit:
		return m.Unit()
	case dragresult.FieldValue:
		return m.Value()
	case dragresult.FieldResult:
		return m.Result()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DragResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dragresult.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case dragresult.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case dragresult.FieldUnit:
		return m.OldUnit(ctx)
	case dragresult.FieldValue:
		return m.OldValue(ctx)
	case dragresult.FieldResult:
		return m.OldResult(ctx)
	}
	return nil, fmt.Errorf("unknown DragResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DragResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dragresult.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case dragresult.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case dragresult.FieldUnit:
		v, ok := value.(dragresult.Unit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case dragresult.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case dragresult.FieldResult:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	}
	return fmt.Errorf("unknown DragResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DragResultMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, dragresult.FieldValue)
	}
	if m.addresult != nil {
		fields = append(fields, dragresult.FieldResult)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DragResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dragresult.FieldValue:
		return m.AddedValue()
	case dragresult.FieldResult:
		return m.AddedResult()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DragResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dragresult.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case dragresult.FieldResult:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResult(v)
		return nil
	}
	return fmt.Errorf("unknown DragResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DragResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DragResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DragResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DragResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DragResultMutation) ResetField(name string) error {
	switch name {
	case dragresult.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case dragresult.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case dragresult.FieldUnit:
		m.ResetUnit()
		return nil
	case dragresult.FieldValue:
		m.ResetValue()
		return nil
	case dragresult.FieldResult:
		m.ResetResult()
		return nil
	}
	return fmt.Errorf("unknown DragResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DragResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.session != nil {
		edges = append(edges, dragresult.EdgeSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DragResultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dragresult.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DragResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DragResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DragResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsession {
		edges = append(edges, dragresult.EdgeSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DragResultMutation) EdgeCleared(name string) bool {
	switch name {
	case dragresult.EdgeSession:
		return m.clearedsession
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DragResultMutation) ClearEdge(name string) error {
	switch name {
	case dragresult.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown DragResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DragResultMutation) ResetEdge(name string) error {
	switch name {
	case dragresult.EdgeSession:
		m.ResetSession()
		return nil
	}
	return fmt.Errorf("unknown DragResult edge %s", name)
}

// DragSessionMutation represents an operation that mutates the DragSession nodes in the graph.
type DragSessionMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	create_time      *time.Time
	update_time      *time.Time
	title            *string
	notes            *map[string]interface{}
	clearedFields    map[string]struct{}
	car              *uuid.UUID
	clearedcar       bool
	results          map[uuid.UUID]struct{}
	removedresults   map[uuid.UUID]struct{}
	clearedresults   bool
	documents        map[uuid.UUID]struct{}
	removeddocuments map[uuid.UUID]struct{}
	cleareddocuments bool
	done             bool
	oldValue         func(context.Context) (*DragSession, error)
	predicates       []predicate.DragSession
}

var _ ent.Mutation = (*DragSessionMutation)(nil)

// dragsessionOption allows management of the mutation configuration using functional options.
type dragsessionOption func(*DragSessionMutation)

// newDragSessionMutation creates new mutation for the DragSession entity.
func newDragSessionMutation(c config, op Op, opts ...dragsessionOption) *DragSessionMutation {
	m := &DragSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeDragSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDragSessionID sets the ID field of the mutation.
func withDragSessionID(id uuid.UUID) dragsessionOption {
	return func(m *DragSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *DragSession
		)
		m.oldValue = func(ctx context.Context) (*DragSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DragSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDragSession sets the old DragSession of the mutation.
func withDragSession(node *DragSession) dragsessionOption {
	return func(m *DragSessionMutation) {
		m.oldValue = func(context.Context) (*DragSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DragSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DragSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DragSession entities.
func (m *DragSessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DragSessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DragSessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DragSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *DragSessionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DragSessionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DragSession entity.
// If the DragSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DragSessionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DragSessionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DragSessionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DragSessionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DragSession entity.
// If the DragSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DragSessionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DragSessionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTitle sets the "title" field.
func (m *DragSessionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DragSessionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the DragSession entity.
// If the DragSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DragSessionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DragSessionMutation) ResetTitle() {
	m.title = nil
}

// SetNotes sets the "notes" field.
func (m *DragSessionMutation) SetNotes(value map[string]interface{}) {
	m.notes = &value
}

// Notes returns the value of the "notes" field in the mutation.
func (m *DragSessionMutation) Notes() (r map[string]interface{}, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the DragSession entity.
// If the DragSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DragSessionMutation) OldNotes(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *DragSessionMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[dragsession.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *DragSessionMutation) NotesCleared() bool {
	_, ok := m.clearedFields[dragsession.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *DragSessionMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, dragsession.FieldNotes)
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *DragSessionMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *DragSessionMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *DragSessionMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *DragSessionMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *DragSessionMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *DragSessionMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// AddResultIDs adds the "results" edge to the DragResult entity by ids.
func (m *DragSessionMutation) AddResultIDs(ids ...uuid.UUID) {
	if m.results == nil {
		m.results = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.results[ids[i]] = struct{}{}
	}
}

// ClearResults clears the "results" edge to the DragResult entity.
func (m *DragSessionMutation) ClearResults() {
	m.clearedresults = true
}

// ResultsCleared reports if the "results" edge to the DragResult entity was cleared.
func (m *DragSessionMutation) ResultsCleared() bool {
	return m.clearedresults
}

// RemoveResultIDs removes the "results" edge to the DragResult entity by IDs.
func (m *DragSessionMutation) RemoveResultIDs(ids ...uuid.UUID) {
	if m.removedresults == nil {
		m.removedresults = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.results, ids[i])
		m.removedresults[ids[i]] = struct{}{}
	}
}

// RemovedResults returns the removed IDs of the "results" edge to the DragResult entity.
func (m *DragSessionMutation) RemovedResultsIDs() (ids []uuid.UUID) {
	for id := range m.removedresults {
		ids = append(ids, id)
	}
	return
}

// ResultsIDs returns the "results" edge IDs in the mutation.
func (m *DragSessionMutation) ResultsIDs() (ids []uuid.UUID) {
	for id := range m.results {
		ids = append(ids, id)
	}
	return
}

// ResetResults resets all changes to the "results" edge.
func (m *DragSessionMutation) ResetResults() {
	m.results = nil
	m.clearedresults = false
	m.removedresults = nil
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *DragSessionMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *DragSessionMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *DragSessionMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *DragSessionMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *DragSessionMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *DragSessionMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *DragSessionMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// Where appends a list predicates to the DragSessionMutation builder.
func (m *DragSessionMutation) Where(ps ...predicate.DragSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DragSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DragSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DragSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DragSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DragSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DragSession).
func (m *DragSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DragSessionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, dragsession.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, dragsession.FieldUpdateTime)
	}
	if m.title != nil {
		fields = append(fields, dragsession.FieldTitle)
	}
	if m.notes != nil {
		fields = append(fields, dragsession.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DragSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dragsession.FieldCreateTime:
		return m.CreateTime()
	case dragsession.FieldUpdateTime:
		return m.UpdateTime()
	case dragsession.FieldTitle:
		return m.Title()
	case dragsession.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DragSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dragsession.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case dragsession.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case dragsession.FieldTitle:
		return m.OldTitle(ctx)
	case dragsession.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown DragSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DragSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dragsession.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case dragsession.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case dragsession.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dragsession.FieldNotes:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown DragSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DragSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DragSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DragSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DragSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DragSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dragsession.FieldNotes) {
		fields = append(fields, dragsession.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DragSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DragSessionMutation) ClearField(name string) error {
	switch name {
	case dragsession.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown DragSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DragSessionMutation) ResetField(name string) error {
	switch name {
	case dragsession.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case dragsession.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case dragsession.FieldTitle:
		m.ResetTitle()
		return nil
	case dragsession.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown DragSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DragSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.car != nil {
		edges = append(edges, dragsession.EdgeCar)
	}
	if m.results != nil {
		edges = append(edges, dragsession.EdgeResults)
	}
	if m.documents != nil {
		edges = append(edges, dragsession.EdgeDocuments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DragSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dragsession.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case dragsession.EdgeResults:
		ids := make([]ent.Value, 0, len(m.results))
		for id := range m.results {
			ids = append(ids, id)
		}
		return ids
	case dragsession.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DragSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedresults != nil {
		edges = append(edges, dragsession.EdgeResults)
	}
	if m.removeddocuments != nil {
		edges = append(edges, dragsession.EdgeDocuments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DragSessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dragsession.EdgeResults:
		ids := make([]ent.Value, 0, len(m.removedresults))
		for id := range m.removedresults {
			ids = append(ids, id)
		}
		return ids
	case dragsession.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DragSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcar {
		edges = append(edges, dragsession.EdgeCar)
	}
	if m.clearedresults {
		edges = append(edges, dragsession.EdgeResults)
	}
	if m.cleareddocuments {
		edges = append(edges, dragsession.EdgeDocuments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DragSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case dragsession.EdgeCar:
		return m.clearedcar
	case dragsession.EdgeResults:
		return m.clearedresults
	case dragsession.EdgeDocuments:
		return m.cleareddocuments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DragSessionMutation) ClearEdge(name string) error {
	switch name {
	case dragsession.EdgeCar:
		m.ClearCar()
		return nil
	}
	return fmt.Errorf("unknown DragSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DragSessionMutation) ResetEdge(name string) error {
	switch name {
	case dragsession.EdgeCar:
		m.ResetCar()
		return nil
	case dragsession.EdgeResults:
		m.ResetResults()
		return nil
	case dragsession.EdgeDocuments:
		m.ResetDocuments()
		return nil
	}
	return fmt.Errorf("unknown DragSession edge %s", name)
}

// DynoResultMutation represents an operation that mutates the DynoResult nodes in the graph.
type DynoResultMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	create_time    *time.Time
	update_time    *time.Time
	rpm            *int
	addrpm         *int
	power_kw       *float64
	addpower_kw    *float64
	torque_nm      *float64
	addtorque_nm   *float64
	clearedFields  map[string]struct{}
	session        *uuid.UUID
	clearedsession bool
	done           bool
	oldValue       func(context.Context) (*DynoResult, error)
	predicates     []predicate.DynoResult
}

var _ ent.Mutation = (*DynoResultMutation)(nil)

// dynoresultOption allows management of the mutation configuration using functional options.
type dynoresultOption func(*DynoResultMutation)

// newDynoResultMutation creates new mutation for the DynoResult entity.
func newDynoResultMutation(c config, op Op, opts ...dynoresultOption) *DynoResultMutation {
	m := &DynoResultMutation{
		config:        c,
		op:            op,
		typ:           TypeDynoResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDynoResultID sets the ID field of the mutation.
func withDynoResultID(id uuid.UUID) dynoresultOption {
	return func(m *DynoResultMutation) {
		var (
			err   error
			once  sync.Once
			value *DynoResult
		)
		m.oldValue = func(ctx context.Context) (*DynoResult, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DynoResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDynoResult sets the old DynoResult of the mutation.
func withDynoResult(node *DynoResult) dynoresultOption {
	return func(m *DynoResultMutation) {
		m.oldValue = func(context.Context) (*DynoResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DynoResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DynoResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DynoResult entities.
func (m *DynoResultMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DynoResultMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DynoResultMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DynoResult.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *DynoResultMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DynoResultMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DynoResult entity.
// If the DynoResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DynoResultMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DynoResultMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DynoResultMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DynoResultMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DynoResult entity.
// If the DynoResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DynoResultMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DynoResultMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetRpm sets the "rpm" field.
func (m *DynoResultMutation) SetRpm(i int) {
	m.rpm = &i
	m.addrpm = nil
}

// Rpm returns the value of the "rpm" field in the mutation.
func (m *DynoResultMutation) Rpm() (r int, exists bool) {
	v := m.rpm
	if v == nil {
		return
	}
	return *v, true
}

// OldRpm returns the old "rpm" field's value of the DynoResult entity.
// If the DynoResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DynoResultMutation) OldRpm(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRpm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRpm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRpm: %w", err)
	}
	return oldValue.Rpm, nil
}

// AddRpm adds i to the "rpm" field.
func (m *DynoResultMutation) AddRpm(i int) {
	if m.addrpm != nil {
		*m.addrpm += i
	} else {
		m.addrpm = &i
	}
}

// AddedRpm returns the value that was added to the "rpm" field in this mutation.
func (m *DynoResultMutation) AddedRpm() (r int, exists bool) {
	v := m.addrpm
	if v == nil {
		return
	}
	return *v, true
}

// ResetRpm resets all changes to the "rpm" field.
func (m *DynoResultMutation) ResetRpm() {
	m.rpm = nil
	m.addrpm = nil
}

// SetPowerKw sets the "power_kw" field.
func (m *DynoResultMutation) SetPowerKw(f float64) {
	m.power_kw = &f
	m.addpower_kw = nil
}

// PowerKw returns the value of the "power_kw" field in the mutation.
func (m *DynoResultMutation) PowerKw() (r float64, exists bool) {
	v := m.power_kw
	if v == nil {
		return
	}
	return *v, true
}

// OldPowerKw returns the old "power_kw" field's value of the DynoResult entity.
// If the DynoResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DynoResultMutation) OldPowerKw(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPowerKw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPowerKw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPowerKw: %w", err)
	}
	return oldValue.PowerKw, nil
}

// AddPowerKw adds f to the "power_kw" field.
func (m *DynoResultMutation) AddPowerKw(f float64) {
	if m.addpower_kw != nil {
		*m.addpower_kw += f
	} else {
		m.addpower_kw = &f
	}
}

// AddedPowerKw returns the value that was added to the "power_kw" field in this mutation.
func (m *DynoResultMutation) AddedPowerKw() (r float64, exists bool) {
	v := m.addpower_kw
	if v == nil {
		return
	}
	return *v, true
}

// ClearPowerKw clears the value of the "power_kw" field.
func (m *DynoResultMutation) ClearPowerKw() {
	m.power_kw = nil
	m.addpower_kw = nil
	m.clearedFields[dynoresult.FieldPowerKw] = struct{}{}
}

// PowerKwCleared returns if the "power_kw" field was cleared in this mutation.
func (m *DynoResultMutation) PowerKwCleared() bool {
	_, ok := m.clearedFields[dynoresult.FieldPowerKw]
	return ok
}

// ResetPowerKw resets all changes to the "power_kw" field.
func (m *DynoResultMutation) ResetPowerKw() {
	m.power_kw = nil
	m.addpower_kw = nil
	delete(m.clearedFields, dynoresult.FieldPowerKw)
}

// SetTorqueNm sets the "torque_nm" field.
func (m *DynoResultMutation) SetTorqueNm(f float64) {
	m.torque_nm = &f
	m.addtorque_nm = nil
}

// TorqueNm returns the value of the "torque_nm" field in the mutation.
func (m *DynoResultMutation) TorqueNm() (r float64, exists bool) {
	v := m.torque_nm
	if v == nil {
		return
	}
	return *v, true
}

// OldTorqueNm returns the old "torque_nm" field's value of the DynoResult entity.
// If the DynoResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DynoResultMutation) OldTorqueNm(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTorqueNm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTorqueNm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTorqueNm: %w", err)
	}
	return oldValue.TorqueNm, nil
}

// AddTorqueNm adds f to the "torque_nm" field.
func (m *DynoResultMutation) AddTorqueNm(f float64) {
	if m.addtorque_nm != nil {
		*m.addtorque_nm += f
	} else {
		m.addtorque_nm = &f
	}
}

// AddedTorqueNm returns the value that was added to the "torque_nm" field in this mutation.
func (m *DynoResultMutation) AddedTorqueNm() (r float64, exists bool) {
	v := m.addtorque_nm
	if v == nil {
		return
	}
	return *v, true
}

// ClearTorqueNm clears the value of the "torque_nm" field.
func (m *DynoResultMutation) ClearTorqueNm() {
	m.torque_nm = nil
	m.addtorque_nm = nil
	m.clearedFields[dynoresult.FieldTorqueNm] = struct{}{}
}

// TorqueNmCleared returns if the "torque_nm" field was cleared in this mutation.
func (m *DynoResultMutation) TorqueNmCleared() bool {
	_, ok := m.clearedFields[dynoresult.FieldTorqueNm]
	return ok
}

// ResetTorqueNm resets all changes to the "torque_nm" field.
func (m *DynoResultMutation) ResetTorqueNm() {
	m.torque_nm = nil
	m.addtorque_nm = nil
	delete(m.clearedFields, dynoresult.FieldTorqueNm)
}

// SetSessionID sets the "session" edge to the DynoSession entity by id.
func (m *DynoResultMutation) SetSessionID(id uuid.UUID) {
	m.session = &id
}

// ClearSession clears the "session" edge to the DynoSession entity.
func (m *DynoResultMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared reports if the "session" edge to the DynoSession entity was cleared.
func (m *DynoResultMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionID returns the "session" edge ID in the mutation.
func (m *DynoResultMutation) SessionID() (id uuid.UUID, exists bool) {
	if m.session != nil {
		return *m.session, true
	}
	return
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *DynoResultMutation) SessionIDs() (ids []uuid.UUID) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *DynoResultMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// Where appends a list predicates to the DynoResultMutation builder.
func (m *DynoResultMutation) Where(ps ...predicate.DynoResult) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DynoResultMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DynoResultMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DynoResult, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DynoResultMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DynoResultMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DynoResult).
func (m *DynoResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DynoResultMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, dynoresult.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, dynoresult.FieldUpdateTime)
	}
	if m.rpm != nil {
		fields = append(fields, dynoresult.FieldRpm)
	}
	if m.power_kw != nil {
		fields = append(fields, dynoresult.FieldPowerKw)
	}
	if m.torque_nm != nil {
		fields = append(fields, dynoresult.FieldTorqueNm)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DynoResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dynoresult.FieldCreateTime:
		return m.CreateTime()
	case dynoresult.FieldUpdateTime:
		return m.UpdateTime()
	case dynoresult.FieldRpm:
		return m.Rpm()
	case dynoresult.FieldPowerKw:
		return m.PowerKw()
	case dynoresult.FieldTorqueNm:
		return m.TorqueNm()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DynoResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dynoresult.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case dynoresult.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case dynoresult.FieldRpm:
		return m.OldRpm(ctx)
	case dynoresult.FieldPowerKw:
		return m.OldPowerKw(ctx)
	case dynoresult.FieldTorqueNm:
		return m.OldTorqueNm(ctx)
	}
	return nil, fmt.Errorf("unknown DynoResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DynoResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dynoresult.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case dynoresult.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case dynoresult.FieldRpm:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRpm(v)
		return nil
	case dynoresult.FieldPowerKw:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPowerKw(v)
		return nil
	case dynoresult.FieldTorqueNm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTorqueNm(v)
		return nil
	}
	return fmt.Errorf("unknown DynoResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DynoResultMutation) AddedFields() []string {
	var fields []string
	if m.addrpm != nil {
		fields = append(fields, dynoresult.FieldRpm)
	}
	if m.addpower_kw != nil {
		fields = append(fields, dynoresult.FieldPowerKw)
	}
	if m.addtorque_nm != nil {
		fields = append(fields, dynoresult.FieldTorqueNm)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DynoResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dynoresult.FieldRpm:
		return m.AddedRpm()
	case dynoresult.FieldPowerKw:
		return m.AddedPowerKw()
	case dynoresult.FieldTorqueNm:
		return m.AddedTorqueNm()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DynoResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dynoresult.FieldRpm:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRpm(v)
		return nil
	case dynoresult.FieldPowerKw:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPowerKw(v)
		return nil
	case dynoresult.FieldTorqueNm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTorqueNm(v)
		return nil
	}
	return fmt.Errorf("unknown DynoResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DynoResultMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dynoresult.FieldPowerKw) {
		fields = append(fields, dynoresult.FieldPowerKw)
	}
	if m.FieldCleared(dynoresult.FieldTorqueNm) {
		fields = append(fields, dynoresult.FieldTorqueNm)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DynoResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DynoResultMutation) ClearField(name string) error {
	switch name {
	case dynoresult.FieldPowerKw:
		m.ClearPowerKw()
		return nil
	case dynoresult.FieldTorqueNm:
		m.ClearTorqueNm()
		return nil
	}
	return fmt.Errorf("unknown DynoResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DynoResultMutation) ResetField(name string) error {
	switch name {
	case dynoresult.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case dynoresult.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case dynoresult.FieldRpm:
		m.ResetRpm()
		return nil
	case dynoresult.FieldPowerKw:
		m.ResetPowerKw()
		return nil
	case dynoresult.FieldTorqueNm:
		m.ResetTorqueNm()
		return nil
	}
	return fmt.Errorf("unknown DynoResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DynoResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.session != nil {
		edges = append(edges, dynoresult.EdgeSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DynoResultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dynoresult.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DynoResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DynoResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DynoResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsession {
		edges = append(edges, dynoresult.EdgeSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DynoResultMutation) EdgeCleared(name string) bool {
	switch name {
	case dynoresult.EdgeSession:
		return m.clearedsession
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DynoResultMutation) ClearEdge(name string) error {
	switch name {
	case dynoresult.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown DynoResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DynoResultMutation) ResetEdge(name string) error {
	switch name {
	case dynoresult.EdgeSession:
		m.ResetSession()
		return nil
	}
	return fmt.Errorf("unknown DynoResult edge %s", name)
}

// DynoSessionMutation represents an operation that mutates the DynoSession nodes in the graph.
type DynoSessionMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	create_time      *time.Time
	update_time      *time.Time
	title            *string
	notes            *map[string]interface{}
	clearedFields    map[string]struct{}
	car              *uuid.UUID
	clearedcar       bool
	results          map[uuid.UUID]struct{}
	removedresults   map[uuid.UUID]struct{}
	clearedresults   bool
	documents        map[uuid.UUID]struct{}
	removeddocuments map[uuid.UUID]struct{}
	cleareddocuments bool
	done             bool
	oldValue         func(context.Context) (*DynoSession, error)
	predicates       []predicate.DynoSession
}

var _ ent.Mutation = (*DynoSessionMutation)(nil)

// dynosessionOption allows management of the mutation configuration using functional options.
type dynosessionOption func(*DynoSessionMutation)

// newDynoSessionMutation creates new mutation for the DynoSession entity.
func newDynoSessionMutation(c config, op Op, opts ...dynosessionOption) *DynoSessionMutation {
	m := &DynoSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeDynoSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDynoSessionID sets the ID field of the mutation.
func withDynoSessionID(id uuid.UUID) dynosessionOption {
	return func(m *DynoSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *DynoSession
		)
		m.oldValue = func(ctx context.Context) (*DynoSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DynoSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDynoSession sets the old DynoSession of the mutation.
func withDynoSession(node *DynoSession) dynosessionOption {
	return func(m *DynoSessionMutation) {
		m.oldValue = func(context.Context) (*DynoSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DynoSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DynoSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DynoSession entities.
func (m *DynoSessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DynoSessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DynoSessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DynoSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *DynoSessionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DynoSessionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DynoSession entity.
// If the DynoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DynoSessionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DynoSessionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DynoSessionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DynoSessionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DynoSession entity.
// If the DynoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DynoSessionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DynoSessionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTitle sets the "title" field.
func (m *DynoSessionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DynoSessionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the DynoSession entity.
// If the DynoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DynoSessionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DynoSessionMutation) ResetTitle() {
	m.title = nil
}

// SetNotes sets the "notes" field.
func (m *DynoSessionMutation) SetNotes(value map[string]interface{}) {
	m.notes = &value
}

// Notes returns the value of the "notes" field in the mutation.
func (m *DynoSessionMutation) Notes() (r map[string]interface{}, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the DynoSession entity.
// If the DynoSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DynoSessionMutation) OldNotes(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *DynoSessionMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[dynosession.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *DynoSessionMutation) NotesCleared() bool {
	_, ok := m.clearedFields[dynosession.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *DynoSessionMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, dynosession.FieldNotes)
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *DynoSessionMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *DynoSessionMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *DynoSessionMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *DynoSessionMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *DynoSessionMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *DynoSessionMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// AddResultIDs adds the "results" edge to the DynoResult entity by ids.
func (m *DynoSessionMutation) AddResultIDs(ids ...uuid.UUID) {
	if m.results == nil {
		m.results = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.results[ids[i]] = struct{}{}
	}
}

// ClearResults clears the "results" edge to the DynoResult entity.
func (m *DynoSessionMutation) ClearResults() {
	m.clearedresults = true
}

// ResultsCleared reports if the "results" edge to the DynoResult entity was cleared.
func (m *DynoSessionMutation) ResultsCleared() bool {
	return m.clearedresults
}

// RemoveResultIDs removes the "results" edge to the DynoResult entity by IDs.
func (m *DynoSessionMutation) RemoveResultIDs(ids ...uuid.UUID) {
	if m.removedresults == nil {
		m.removedresults = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.results, ids[i])
		m.removedresults[ids[i]] = struct{}{}
	}
}

// RemovedResults returns the removed IDs of the "results" edge to the DynoResult entity.
func (m *DynoSessionMutation) RemovedResultsIDs() (ids []uuid.UUID) {
	for id := range m.removedresults {
		ids = append(ids, id)
	}
	return
}

// ResultsIDs returns the "results" edge IDs in the mutation.
func (m *DynoSessionMutation) ResultsIDs() (ids []uuid.UUID) {
	for id := range m.results {
		ids = append(ids, id)
	}
	return
}

// ResetResults resets all changes to the "results" edge.
func (m *DynoSessionMutation) ResetResults() {
	m.results = nil
	m.clearedresults = false
	m.removedresults = nil
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *DynoSessionMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *DynoSessionMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *DynoSessionMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *DynoSessionMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *DynoSessionMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *DynoSessionMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *DynoSessionMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// Where appends a list predicates to the DynoSessionMutation builder.
func (m *DynoSessionMutation) Where(ps ...predicate.DynoSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DynoSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DynoSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DynoSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DynoSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DynoSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DynoSession).
func (m *DynoSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DynoSessionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, dynosession.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, dynosession.FieldUpdateTime)
	}
	if m.title != nil {
		fields = append(fields, dynosession.FieldTitle)
	}
	if m.notes != nil {
		fields = append(fields, dynosession.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DynoSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dynosession.FieldCreateTime:
		return m.CreateTime()
	case dynosession.FieldUpdateTime:
		return m.UpdateTime()
	case dynosession.FieldTitle:
		return m.Title()
	case dynosession.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DynoSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dynosession.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case dynosession.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case dynosession.FieldTitle:
		return m.OldTitle(ctx)
	case dynosession.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown DynoSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DynoSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dynosession.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case dynosession.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case dynosession.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dynosession.FieldNotes:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown DynoSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DynoSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DynoSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DynoSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DynoSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DynoSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dynosession.FieldNotes) {
		fields = append(fields, dynosession.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DynoSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DynoSessionMutation) ClearField(name string) error {
	switch name {
	case dynosession.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown DynoSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DynoSessionMutation) ResetField(name string) error {
	switch name {
	case dynosession.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case dynosession.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case dynosession.FieldTitle:
		m.ResetTitle()
		return nil
	case dynosession.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown DynoSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DynoSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.car != nil {
		edges = append(edges, dynosession.EdgeCar)
	}
	if m.results != nil {
		edges = append(edges, dynosession.EdgeResults)
	}
	if m.documents != nil {
		edges = append(edges, dynosession.EdgeDocuments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DynoSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dynosession.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case dynosession.EdgeResults:
		ids := make([]ent.Value, 0, len(m.results))
		for id := range m.results {
			ids = append(ids, id)
		}
		return ids
	case dynosession.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DynoSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedresults != nil {
		edges = append(edges, dynosession.EdgeResults)
	}
	if m.removeddocuments != nil {
		edges = append(edges, dynosession.EdgeDocuments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DynoSessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dynosession.EdgeResults:
		ids := make([]ent.Value, 0, len(m.removedresults))
		for id := range m.removedresults {
			ids = append(ids, id)
		}
		return ids
	case dynosession.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DynoSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcar {
		edges = append(edges, dynosession.EdgeCar)
	}
	if m.clearedresults {
		edges = append(edges, dynosession.EdgeResults)
	}
	if m.cleareddocuments {
		edges = append(edges, dynosession.EdgeDocuments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DynoSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case dynosession.EdgeCar:
		return m.clearedcar
	case dynosession.EdgeResults:
		return m.clearedresults
	case dynosession.EdgeDocuments:
		return m.cleareddocuments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DynoSessionMutation) ClearEdge(name string) error {
	switch name {
	case dynosession.EdgeCar:
		m.ClearCar()
		return nil
	}
	return fmt.Errorf("unknown DynoSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DynoSessionMutation) ResetEdge(name string) error {
	switch name {
	case dynosession.EdgeCar:
		m.ResetCar()
		return nil
	case dynosession.EdgeResults:
		m.ResetResults()
		return nil
	case dynosession.EdgeDocuments:
		m.ResetDocuments()
		return nil
	}
	return fmt.Errorf("unknown DynoSession edge %s", name)
}

// ExpenseMutation represents an operation that mutates the Expense nodes in the graph.
type ExpenseMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	create_time        *time.Time
	update_time        *time.Time
	occurred_at        *time.Time
	_type              *expense.Type
	amount             *float64
	addamount          *float64
	notes              *string
	clearedFields      map[string]struct{}
	car                *uuid.UUID
	clearedcar         bool
	fuel_up            *uuid.UUID
	clearedfuel_up     bool
	service_log        *uuid.UUID
	clearedservice_log bool
	documents          map[uuid.UUID]struct{}
	removeddocuments   map[uuid.UUID]struct{}
	cleareddocuments   bool
	done               bool
	oldValue           func(context.Context) (*Expense, error)
	predicates         []predicate.Expense
}

var _ ent.Mutation = (*ExpenseMutation)(nil)

// expenseOption allows management of the mutation configuration using functional options.
type expenseOption func(*ExpenseMutation)

// newExpenseMutation creates new mutation for the Expense entity.
func newExpenseMutation(c config, op Op, opts ...expenseOption) *ExpenseMutation {
	m := &ExpenseMutation{
		config:        c,
		op:            op,
		typ:           TypeExpense,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExpenseID sets the ID field of the mutation.
func withExpenseID(id uuid.UUID) expenseOption {
	return func(m *ExpenseMutation) {
		var (
			err   error
			once  sync.Once
			value *Expense
		)
		m.oldValue = func(ctx context.Context) (*Expense, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Expense.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExpense sets the old Expense of the mutation.
func withExpense(node *Expense) expenseOption {
	return func(m *ExpenseMutation) {
		m.oldValue = func(context.Context) (*Expense, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExpenseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExpenseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Expense entities.
func (m *ExpenseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExpenseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExpenseMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Expense.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ExpenseMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ExpenseMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Expense entity.
// If the Expense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExpenseMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ExpenseMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ExpenseMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ExpenseMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Expense entity.
// If the Expense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExpenseMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ExpenseMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetOccurredAt sets the "occurred_at" field.
func (m *ExpenseMutation) SetOccurredAt(t time.Time) {
	m.occurred_at = &t
}

// OccurredAt returns the value of the "occurred_at" field in the mutation.
func (m *ExpenseMutation) OccurredAt() (r time.Time, exists bool) {
	v := m.occurred_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOccurredAt returns the old "occurred_at" field's value of the Expense entity.
// If the Expense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExpenseMutation) OldOccurredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOccurredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOccurredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccurredAt: %w", err)
	}
	return oldValue.OccurredAt, nil
}

// ResetOccurredAt resets all changes to the "occurred_at" field.
func (m *ExpenseMutation) ResetOccurredAt() {
	m.occurred_at = nil
}

// SetType sets the "type" field.
func (m *ExpenseMutation) SetType(e expense.Type) {
	m._type = &e
}

// GetType returns the value of the "type" field in the mutation.
func (m *ExpenseMutation) GetType() (r expense.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Expense entity.
// If the Expense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExpenseMutation) OldType(ctx context.Context) (v expense.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ExpenseMutation) ResetType() {
	m._type = nil
}

// SetAmount sets the "amount" field.
func (m *ExpenseMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *ExpenseMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Expense entity.
// If the Expense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExpenseMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *ExpenseMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *ExpenseMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *ExpenseMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetNotes sets the "notes" field.
func (m *ExpenseMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *ExpenseMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Expense entity.
// If the Expense object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExpenseMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *ExpenseMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[expense.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *ExpenseMutation) NotesCleared() bool {
	_, ok := m.clearedFields[expense.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *ExpenseMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, expense.FieldNotes)
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *ExpenseMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *ExpenseMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *ExpenseMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *ExpenseMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *ExpenseMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *ExpenseMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// SetFuelUpID sets the "fuel_up" edge to the FuelUp entity by id.
func (m *ExpenseMutation) SetFuelUpID(id uuid.UUID) {
	m.fuel_up = &id
}

// ClearFuelUp clears the "fuel_up" edge to the FuelUp entity.
func (m *ExpenseMutation) ClearFuelUp() {
	m.clearedfuel_up = true
}

// FuelUpCleared reports if the "fuel_up" edge to the FuelUp entity was cleared.
func (m *ExpenseMutation) FuelUpCleared() bool {
	return m.clearedfuel_up
}

// FuelUpID returns the "fuel_up" edge ID in the mutation.
func (m *ExpenseMutation) FuelUpID() (id uuid.UUID, exists bool) {
	if m.fuel_up != nil {
		return *m.fuel_up, true
	}
	return
}

// FuelUpIDs returns the "fuel_up" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FuelUpID instead. It exists only for internal usage by the builders.
func (m *ExpenseMutation) FuelUpIDs() (ids []uuid.UUID) {
	if id := m.fuel_up; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFuelUp resets all changes to the "fuel_up" edge.
func (m *ExpenseMutation) ResetFuelUp() {
	m.fuel_up = nil
	m.clearedfuel_up = false
}

// SetServiceLogID sets the "service_log" edge to the ServiceLog entity by id.
func (m *ExpenseMutation) SetServiceLogID(id uuid.UUID) {
	m.service_log = &id
}

// ClearServiceLog clears the "service_log" edge to the ServiceLog entity.
func (m *ExpenseMutation) ClearServiceLog() {
	m.clearedservice_log = true
}

// ServiceLogCleared reports if the "service_log" edge to the ServiceLog entity was cleared.
func (m *ExpenseMutation) ServiceLogCleared() bool {
	return m.clearedservice_log
}

// ServiceLogID returns the "service_log" edge ID in the mutation.
func (m *ExpenseMutation) ServiceLogID() (id uuid.UUID, exists bool) {
	if m.service_log != nil {
		return *m.service_log, true
	}
	return
}

// ServiceLogIDs returns the "service_log" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceLogID instead. It exists only for internal usage by the builders.
func (m *ExpenseMutation) ServiceLogIDs() (ids []uuid.UUID) {
	if id := m.service_log; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceLog resets all changes to the "service_log" edge.
func (m *ExpenseMutation) ResetServiceLog() {
	m.service_log = nil
	m.clearedservice_log = false
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *ExpenseMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *ExpenseMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *ExpenseMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *ExpenseMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *ExpenseMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *ExpenseMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *ExpenseMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// Where appends a list predicates to the ExpenseMutation builder.
func (m *ExpenseMutation) Where(ps ...predicate.Expense) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExpenseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExpenseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Expense, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExpenseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExpenseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Expense).
func (m *ExpenseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExpenseMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, expense.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, expense.FieldUpdateTime)
	}
	if m.occurred_at != nil {
		fields = append(fields, expense.FieldOccurredAt)
	}
	if m._type != nil {
		fields = append(fields, expense.FieldType)
	}
	if m.amount != nil {
		fields = append(fields, expense.FieldAmount)
	}
	if m.notes != nil {
		fields = append(fields, expense.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExpenseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case expense.FieldCreateTime:
		return m.CreateTime()
	case expense.FieldUpdateTime:
		return m.UpdateTime()
	case expense.FieldOccurredAt:
		return m.OccurredAt()
	case expense.FieldType:
		return m.GetType()
	case expense.FieldAmount:
		return m.Amount()
	case expense.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExpenseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case expense.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case expense.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case expense.FieldOccurredAt:
		return m.OldOccurredAt(ctx)
	case expense.FieldType:
		return m.OldType(ctx)
	case expense.FieldAmount:
		return m.OldAmount(ctx)
	case expense.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown Expense field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExpenseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case expense.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case expense.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case expense.FieldOccurredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccurredAt(v)
		return nil
	case expense.FieldType:
		v, ok := value.(expense.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case expense.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case expense.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown Expense field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExpenseMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, expense.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExpenseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case expense.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExpenseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case expense.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Expense numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExpenseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(expense.FieldNotes) {
		fields = append(fields, expense.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExpenseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExpenseMutation) ClearField(name string) error {
	switch name {
	case expense.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown Expense nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExpenseMutation) ResetField(name string) error {
	switch name {
	case expense.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case expense.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case expense.FieldOccurredAt:
		m.ResetOccurredAt()
		return nil
	case expense.FieldType:
		m.ResetType()
		return nil
	case expense.FieldAmount:
		m.ResetAmount()
		return nil
	case expense.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown Expense field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExpenseMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.car != nil {
		edges = append(edges, expense.EdgeCar)
	}
	if m.fuel_up != nil {
		edges = append(edges, expense.EdgeFuelUp)
	}
	if m.service_log != nil {
		edges = append(edges, expense.EdgeServiceLog)
	}
	if m.documents != nil {
		edges = append(edges, expense.EdgeDocuments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExpenseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case expense.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case expense.EdgeFuelUp:
		if id := m.fuel_up; id != nil {
			return []ent.Value{*id}
		}
	case expense.EdgeServiceLog:
		if id := m.service_log; id != nil {
			return []ent.Value{*id}
		}
	case expense.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExpenseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddocuments != nil {
		edges = append(edges, expense.EdgeDocuments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExpenseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case expense.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExpenseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcar {
		edges = append(edges, expense.EdgeCar)
	}
	if m.clearedfuel_up {
		edges = append(edges, expense.EdgeFuelUp)
	}
	if m.clearedservice_log {
		edges = append(edges, expense.EdgeServiceLog)
	}
	if m.cleareddocuments {
		edges = append(edges, expense.EdgeDocuments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExpenseMutation) EdgeCleared(name string) bool {
	switch name {
	case expense.EdgeCar:
		return m.clearedcar
	case expense.EdgeFuelUp:
		return m.clearedfuel_up
	case expense.EdgeServiceLog:
		return m.clearedservice_log
	case expense.EdgeDocuments:
		return m.cleareddocuments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExpenseMutation) ClearEdge(name string) error {
	switch name {
	case expense.EdgeCar:
		m.ClearCar()
		return nil
	case expense.EdgeFuelUp:
		m.ClearFuelUp()
		return nil
	case expense.EdgeServiceLog:
		m.ClearServiceLog()
		return nil
	}
	return fmt.Errorf("unknown Expense unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExpenseMutation) ResetEdge(name string) error {
	switch name {
	case expense.EdgeCar:
		m.ResetCar()
		return nil
	case expense.EdgeFuelUp:
		m.ResetFuelUp()
		return nil
	case expense.EdgeServiceLog:
		m.ResetServiceLog()
		return nil
	case expense.EdgeDocuments:
		m.ResetDocuments()
		return nil
	}
	return fmt.Errorf("unknown Expense edge %s", name)
}

// FuelUpMutation represents an operation that mutates the FuelUp nodes in the graph.
type FuelUpMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	create_time             *time.Time
	update_time             *time.Time
	occurred_at             *time.Time
	station                 *string
	amount_liters           *float64
	addamount_liters        *float64
	fuel_category           *fuelup.FuelCategory
	octane_rating           *fuelup.OctaneRating
	is_full_tank            *bool
	notes                   *string
	clearedFields           map[string]struct{}
	car                     *uuid.UUID
	clearedcar              bool
	odometer_reading        *uuid.UUID
	clearedodometer_reading bool
	expense                 *uuid.UUID
	clearedexpense          bool
	documents               map[uuid.UUID]struct{}
	removeddocuments        map[uuid.UUID]struct{}
	cleareddocuments        bool
	done                    bool
	oldValue                func(context.Context) (*FuelUp, error)
	predicates              []predicate.FuelUp
}

var _ ent.Mutation = (*FuelUpMutation)(nil)

// fuelupOption allows management of the mutation configuration using functional options.
type fuelupOption func(*FuelUpMutation)

// newFuelUpMutation creates new mutation for the FuelUp entity.
func newFuelUpMutation(c config, op Op, opts ...fuelupOption) *FuelUpMutation {
	m := &FuelUpMutation{
		config:        c,
		op:            op,
		typ:           TypeFuelUp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFuelUpID sets the ID field of the mutation.
func withFuelUpID(id uuid.UUID) fuelupOption {
	return func(m *FuelUpMutation) {
		var (
			err   error
			once  sync.Once
			value *FuelUp
		)
		m.oldValue = func(ctx context.Context) (*FuelUp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FuelUp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFuelUp sets the old FuelUp of the mutation.
func withFuelUp(node *FuelUp) fuelupOption {
	return func(m *FuelUpMutation) {
		m.oldValue = func(context.Context) (*FuelUp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FuelUpMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FuelUpMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FuelUp entities.
func (m *FuelUpMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FuelUpMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FuelUpMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FuelUp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *FuelUpMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *FuelUpMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *FuelUpMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *FuelUpMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *FuelUpMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *FuelUpMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetOccurredAt sets the "occurred_at" field.
func (m *FuelUpMutation) SetOccurredAt(t time.Time) {
	m.occurred_at = &t
}

// OccurredAt returns the value of the "occurred_at" field in the mutation.
func (m *FuelUpMutation) OccurredAt() (r time.Time, exists bool) {
	v := m.occurred_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOccurredAt returns the old "occurred_at" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldOccurredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOccurredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOccurredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccurredAt: %w", err)
	}
	return oldValue.OccurredAt, nil
}

// ResetOccurredAt resets all changes to the "occurred_at" field.
func (m *FuelUpMutation) ResetOccurredAt() {
	m.occurred_at = nil
}

// SetStation sets the "station" field.
func (m *FuelUpMutation) SetStation(s string) {
	m.station = &s
}

// Station returns the value of the "station" field in the mutation.
func (m *FuelUpMutation) Station() (r string, exists bool) {
	v := m.station
	if v == nil {
		return
	}
	return *v, true
}

// OldStation returns the old "station" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldStation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStation: %w", err)
	}
	return oldValue.Station, nil
}

// ResetStation resets all changes to the "station" field.
func (m *FuelUpMutation) ResetStation() {
	m.station = nil
}

// SetAmountLiters sets the "amount_liters" field.
func (m *FuelUpMutation) SetAmountLiters(f float64) {
	m.amount_liters = &f
	m.addamount_liters = nil
}

// AmountLiters returns the value of the "amount_liters" field in the mutation.
func (m *FuelUpMutation) AmountLiters() (r float64, exists bool) {
	v := m.amount_liters
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountLiters returns the old "amount_liters" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldAmountLiters(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountLiters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountLiters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountLiters: %w", err)
	}
	return oldValue.AmountLiters, nil
}

// AddAmountLiters adds f to the "amount_liters" field.
func (m *FuelUpMutation) AddAmountLiters(f float64) {
	if m.addamount_liters != nil {
		*m.addamount_liters += f
	} else {
		m.addamount_liters = &f
	}
}

// AddedAmountLiters returns the value that was added to the "amount_liters" field in this mutation.
func (m *FuelUpMutation) AddedAmountLiters() (r float64, exists bool) {
	v := m.addamount_liters
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmountLiters resets all changes to the "amount_liters" field.
func (m *FuelUpMutation) ResetAmountLiters() {
	m.amount_liters = nil
	m.addamount_liters = nil
}

// SetFuelCategory sets the "fuel_category" field.
func (m *FuelUpMutation) SetFuelCategory(fc fuelup.FuelCategory) {
	m.fuel_category = &fc
}

// FuelCategory returns the value of the "fuel_category" field in the mutation.
func (m *FuelUpMutation) FuelCategory() (r fuelup.FuelCategory, exists bool) {
	v := m.fuel_category
	if v == nil {
		return
	}
	return *v, true
}

// OldFuelCategory returns the old "fuel_category" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldFuelCategory(ctx context.Context) (v fuelup.FuelCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFuelCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFuelCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFuelCategory: %w", err)
	}
	return oldValue.FuelCategory, nil
}

// ResetFuelCategory resets all changes to the "fuel_category" field.
func (m *FuelUpMutation) ResetFuelCategory() {
	m.fuel_category = nil
}

// SetOctaneRating sets the "octane_rating" field.
func (m *FuelUpMutation) SetOctaneRating(fr fuelup.OctaneRating) {
	m.octane_rating = &fr
}

// OctaneRating returns the value of the "octane_rating" field in the mutation.
func (m *FuelUpMutation) OctaneRating() (r fuelup.OctaneRating, exists bool) {
	v := m.octane_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldOctaneRating returns the old "octane_rating" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldOctaneRating(ctx context.Context) (v *fuelup.OctaneRating, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOctaneRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOctaneRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOctaneRating: %w", err)
	}
	return oldValue.OctaneRating, nil
}

// ClearOctaneRating clears the value of the "octane_rating" field.
func (m *FuelUpMutation) ClearOctaneRating() {
	m.octane_rating = nil
	m.clearedFields[fuelup.FieldOctaneRating] = struct{}{}
}

// OctaneRatingCleared returns if the "octane_rating" field was cleared in this mutation.
func (m *FuelUpMutation) OctaneRatingCleared() bool {
	_, ok := m.clearedFields[fuelup.FieldOctaneRating]
	return ok
}

// ResetOctaneRating resets all changes to the "octane_rating" field.
func (m *FuelUpMutation) ResetOctaneRating() {
	m.octane_rating = nil
	delete(m.clearedFields, fuelup.FieldOctaneRating)
}

// SetIsFullTank sets the "is_full_tank" field.
func (m *FuelUpMutation) SetIsFullTank(b bool) {
	m.is_full_tank = &b
}

// IsFullTank returns the value of the "is_full_tank" field in the mutation.
func (m *FuelUpMutation) IsFullTank() (r bool, exists bool) {
	v := m.is_full_tank
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFullTank returns the old "is_full_tank" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldIsFullTank(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFullTank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFullTank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFullTank: %w", err)
	}
	return oldValue.IsFullTank, nil
}

// ResetIsFullTank resets all changes to the "is_full_tank" field.
func (m *FuelUpMutation) ResetIsFullTank() {
	m.is_full_tank = nil
}

// SetNotes sets the "notes" field.
func (m *FuelUpMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *FuelUpMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *FuelUpMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[fuelup.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *FuelUpMutation) NotesCleared() bool {
	_, ok := m.clearedFields[fuelup.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *FuelUpMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, fuelup.FieldNotes)
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *FuelUpMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *FuelUpMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *FuelUpMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *FuelUpMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *FuelUpMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *FuelUpMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// SetOdometerReadingID sets the "odometer_reading" edge to the OdometerReading entity by id.
func (m *FuelUpMutation) SetOdometerReadingID(id uuid.UUID) {
	m.odometer_reading = &id
}

// ClearOdometerReading clears the "odometer_reading" edge to the OdometerReading entity.
func (m *FuelUpMutation) ClearOdometerReading() {
	m.clearedodometer_reading = true
}

// OdometerReadingCleared reports if the "odometer_reading" edge to the OdometerReading entity was cleared.
func (m *FuelUpMutation) OdometerReadingCleared() bool {
	return m.clearedodometer_reading
}

// OdometerReadingID returns the "odometer_reading" edge ID in the mutation.
func (m *FuelUpMutation) OdometerReadingID() (id uuid.UUID, exists bool) {
	if m.odometer_reading != nil {
		return *m.odometer_reading, true
	}
	return
}

// OdometerReadingIDs returns the "odometer_reading" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OdometerReadingID instead. It exists only for internal usage by the builders.
func (m *FuelUpMutation) OdometerReadingIDs() (ids []uuid.UUID) {
	if id := m.odometer_reading; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOdometerReading resets all changes to the "odometer_reading" edge.
func (m *FuelUpMutation) ResetOdometerReading() {
	m.odometer_reading = nil
	m.clearedodometer_reading = false
}

// SetExpenseID sets the "expense" edge to the Expense entity by id.
func (m *FuelUpMutation) SetExpenseID(id uuid.UUID) {
	m.expense = &id
}

// ClearExpense clears the "expense" edge to the Expense entity.
func (m *FuelUpMutation) ClearExpense() {
	m.clearedexpense = true
}

// ExpenseCleared reports if the "expense" edge to the Expense entity was cleared.
func (m *FuelUpMutation) ExpenseCleared() bool {
	return m.clearedexpense
}

// ExpenseID returns the "expense" edge ID in the mutation.
func (m *FuelUpMutation) ExpenseID() (id uuid.UUID, exists bool) {
	if m.expense != nil {
		return *m.expense, true
	}
	return
}

// ExpenseIDs returns the "expense" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExpenseID instead. It exists only for internal usage by the builders.
func (m *FuelUpMutation) ExpenseIDs() (ids []uuid.UUID) {
	if id := m.expense; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExpense resets all changes to the "expense" edge.
func (m *FuelUpMutation) ResetExpense() {
	m.expense = nil
	m.clearedexpense = false
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *FuelUpMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *FuelUpMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *FuelUpMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *FuelUpMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *FuelUpMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *FuelUpMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *FuelUpMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// Where appends a list predicates to the FuelUpMutation builder.
func (m *FuelUpMutation) Where(ps ...predicate.FuelUp) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FuelUpMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FuelUpMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FuelUp, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FuelUpMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FuelUpMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FuelUp).
func (m *FuelUpMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FuelUpMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, fuelup.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, fuelup.FieldUpdateTime)
	}
	if m.occurred_at != nil {
		fields = append(fields, fuelup.FieldOccurredAt)
	}
	if m.station != nil {
		fields = append(fields, fuelup.FieldStation)
	}
	if m.amount_liters != nil {
		fields = append(fields, fuelup.FieldAmountLiters)
	}
	if m.fuel_category != nil {
		fields = append(fields, fuelup.FieldFuelCategory)
	}
	if m.octane_rating != nil {
		fields = append(fields, fuelup.FieldOctaneRating)
	}
	if m.is_full_tank != nil {
		fields = append(fields, fuelup.FieldIsFullTank)
	}
	if m.notes != nil {
		fields = append(fields, fuelup.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FuelUpMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fuelup.FieldCreateTime:
		return m.CreateTime()
	case fuelup.FieldUpdateTime:
		return m.UpdateTime()
	case fuelup.FieldOccurredAt:
		return m.OccurredAt()
	case fuelup.FieldStation:
		return m.Station()
	case fuelup.FieldAmountLiters:
		return m.AmountLiters()
	case fuelup.FieldFuelCategory:
		return m.FuelCategory()
	case fuelup.FieldOctaneRating:
		return m.OctaneRating()
	case fuelup.FieldIsFullTank:
		return m.IsFullTank()
	case fuelup.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FuelUpMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fuelup.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case fuelup.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case fuelup.FieldOccurredAt:
		return m.OldOccurredAt(ctx)
	case fuelup.FieldStation:
		return m.OldStation(ctx)
	case fuelup.FieldAmountLiters:
		return m.OldAmountLiters(ctx)
	case fuelup.FieldFuelCategory:
		return m.OldFuelCategory(ctx)
	case fuelup.FieldOctaneRating:
		return m.OldOctaneRating(ctx)
	case fuelup.FieldIsFullTank:
		return m.OldIsFullTank(ctx)
	case fuelup.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown FuelUp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FuelUpMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fuelup.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case fuelup.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case fuelup.FieldOccurredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccurredAt(v)
		return nil
	case fuelup.FieldStation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStation(v)
		return nil
	case fuelup.FieldAmountLiters:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountLiters(v)
		return nil
	case fuelup.FieldFuelCategory:
		v, ok := value.(fuelup.FuelCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFuelCategory(v)
		return nil
	case fuelup.FieldOctaneRating:
		v, ok := value.(fuelup.OctaneRating)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOctaneRating(v)
		return nil
	case fuelup.FieldIsFullTank:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFullTank(v)
		return nil
	case fuelup.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown FuelUp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FuelUpMutation) AddedFields() []string {
	var fields []string
	if m.addamount_liters != nil {
		fields = append(fields, fuelup.FieldAmountLiters)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FuelUpMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fuelup.FieldAmountLiters:
		return m.AddedAmountLiters()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FuelUpMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fuelup.FieldAmountLiters:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountLiters(v)
		return nil
	}
	return fmt.Errorf("unknown FuelUp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FuelUpMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fuelup.FieldOctaneRating) {
		fields = append(fields, fuelup.FieldOctaneRating)
	}
	if m.FieldCleared(fuelup.FieldNotes) {
		fields = append(fields, fuelup.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FuelUpMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FuelUpMutation) ClearField(name string) error {
	switch name {
	case fuelup.FieldOctaneRating:
		m.ClearOctaneRating()
		return nil
	case fuelup.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown FuelUp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FuelUpMutation) ResetField(name string) error {
	switch name {
	case fuelup.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case fuelup.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case fuelup.FieldOccurredAt:
		m.ResetOccurredAt()
		return nil
	case fuelup.FieldStation:
		m.ResetStation()
		return nil
	case fuelup.FieldAmountLiters:
		m.ResetAmountLiters()
		return nil
	case fuelup.FieldFuelCategory:
		m.ResetFuelCategory()
		return nil
	case fuelup.FieldOctaneRating:
		m.ResetOctaneRating()
		return nil
	case fuelup.FieldIsFullTank:
		m.ResetIsFullTank()
		return nil
	case fuelup.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown FuelUp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FuelUpMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.car != nil {
		edges = append(edges, fuelup.EdgeCar)
	}
	if m.odometer_reading != nil {
		edges = append(edges, fuelup.EdgeOdometerReading)
	}
	if m.expense != nil {
		edges = append(edges, fuelup.EdgeExpense)
	}
	if m.documents != nil {
		edges = append(edges, fuelup.EdgeDocuments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FuelUpMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fuelup.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case fuelup.EdgeOdometerReading:
		if id := m.odometer_reading; id != nil {
			return []ent.Value{*id}
		}
	case fuelup.EdgeExpense:
		if id := m.expense; id != nil {
			return []ent.Value{*id}
		}
	case fuelup.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FuelUpMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddocuments != nil {
		edges = append(edges, fuelup.EdgeDocuments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FuelUpMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case fuelup.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FuelUpMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcar {
		edges = append(edges, fuelup.EdgeCar)
	}
	if m.clearedodometer_reading {
		edges = append(edges, fuelup.EdgeOdometerReading)
	}
	if m.clearedexpense {
		edges = append(edges, fuelup.EdgeExpense)
	}
	if m.cleareddocuments {
		edges = append(edges, fuelup.EdgeDocuments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FuelUpMutation) EdgeCleared(name string) bool {
	switch name {
	case fuelup.EdgeCar:
		return m.clearedcar
	case fuelup.EdgeOdometerReading:
		return m.clearedodometer_reading
	case fuelup.EdgeExpense:
		return m.clearedexpense
	case fuelup.EdgeDocuments:
		return m.cleareddocuments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FuelUpMutation) ClearEdge(name string) error {
	switch name {
	case fuelup.EdgeCar:
		m.ClearCar()
		return nil
	case fuelup.EdgeOdometerReading:
		m.ClearOdometerReading()
		return nil
	case fuelup.EdgeExpense:
		m.ClearExpense()
		return nil
	}
	return fmt.Errorf("unknown FuelUp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FuelUpMutation) ResetEdge(name string) error {
	switch name {
	case fuelup.EdgeCar:
		m.ResetCar()
		return nil
	case fuelup.EdgeOdometerReading:
		m.ResetOdometerReading()
		return nil
	case fuelup.EdgeExpense:
		m.ResetExpense()
		return nil
	case fuelup.EdgeDocuments:
		m.ResetDocuments()
		return nil
	}
	return fmt.Errorf("unknown FuelUp edge %s", name)
}

// MediaMutation represents an operation that mutates the Media nodes in the graph.
type MediaMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	title         *string
	description   *string
	clearedFields map[string]struct{}
	car           *uuid.UUID
	clearedcar    bool
	albums        map[uuid.UUID]struct{}
	removedalbums map[uuid.UUID]struct{}
	clearedalbums bool
	done          bool
	oldValue      func(context.Context) (*Media, error)
	predicates    []predicate.Media
}

var _ ent.Mutation = (*MediaMutation)(nil)

// mediaOption allows management of the mutation configuration using functional options.
type mediaOption func(*MediaMutation)

// newMediaMutation creates new mutation for the Media entity.
func newMediaMutation(c config, op Op, opts ...mediaOption) *MediaMutation {
	m := &MediaMutation{
		config:        c,
		op:            op,
		typ:           TypeMedia,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMediaID sets the ID field of the mutation.
func withMediaID(id uuid.UUID) mediaOption {
	return func(m *MediaMutation) {
		var (
			err   error
			once  sync.Once
			value *Media
		)
		m.oldValue = func(ctx context.Context) (*Media, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Media.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedia sets the old Media of the mutation.
func withMedia(node *Media) mediaOption {
	return func(m *MediaMutation) {
		m.oldValue = func(context.Context) (*Media, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MediaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MediaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Media entities.
func (m *MediaMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MediaMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MediaMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Media.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *MediaMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *MediaMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *MediaMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *MediaMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *MediaMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *MediaMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTitle sets the "title" field.
func (m *MediaMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *MediaMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldTitle(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *MediaMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[media.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *MediaMutation) TitleCleared() bool {
	_, ok := m.clearedFields[media.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *MediaMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, media.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *MediaMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MediaMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MediaMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[media.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MediaMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[media.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MediaMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, media.FieldDescription)
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *MediaMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *MediaMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *MediaMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *MediaMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *MediaMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *MediaMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// AddAlbumIDs adds the "albums" edge to the Album entity by ids.
func (m *MediaMutation) AddAlbumIDs(ids ...uuid.UUID) {
	if m.albums == nil {
		m.albums = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.albums[ids[i]] = struct{}{}
	}
}

// ClearAlbums clears the "albums" edge to the Album entity.
func (m *MediaMutation) ClearAlbums() {
	m.clearedalbums = true
}

// AlbumsCleared reports if the "albums" edge to the Album entity was cleared.
func (m *MediaMutation) AlbumsCleared() bool {
	return m.clearedalbums
}

// RemoveAlbumIDs removes the "albums" edge to the Album entity by IDs.
func (m *MediaMutation) RemoveAlbumIDs(ids ...uuid.UUID) {
	if m.removedalbums == nil {
		m.removedalbums = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.albums, ids[i])
		m.removedalbums[ids[i]] = struct{}{}
	}
}

// RemovedAlbums returns the removed IDs of the "albums" edge to the Album entity.
func (m *MediaMutation) RemovedAlbumsIDs() (ids []uuid.UUID) {
	for id := range m.removedalbums {
		ids = append(ids, id)
	}
	return
}

// AlbumsIDs returns the "albums" edge IDs in the mutation.
func (m *MediaMutation) AlbumsIDs() (ids []uuid.UUID) {
	for id := range m.albums {
		ids = append(ids, id)
	}
	return
}

// ResetAlbums resets all changes to the "albums" edge.
func (m *MediaMutation) ResetAlbums() {
	m.albums = nil
	m.clearedalbums = false
	m.removedalbums = nil
}

// Where appends a list predicates to the MediaMutation builder.
func (m *MediaMutation) Where(ps ...predicate.Media) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MediaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MediaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Media, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MediaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MediaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Media).
func (m *MediaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MediaMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, media.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, media.FieldUpdateTime)
	}
	if m.title != nil {
		fields = append(fields, media.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, media.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MediaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case media.FieldCreateTime:
		return m.CreateTime()
	case media.FieldUpdateTime:
		return m.UpdateTime()
	case media.FieldTitle:
		return m.Title()
	case media.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MediaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case media.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case media.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case media.FieldTitle:
		return m.OldTitle(ctx)
	case media.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Media field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case media.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case media.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case media.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case media.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MediaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MediaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Media numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MediaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(media.FieldTitle) {
		fields = append(fields, media.FieldTitle)
	}
	if m.FieldCleared(media.FieldDescription) {
		fields = append(fields, media.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MediaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MediaMutation) ClearField(name string) error {
	switch name {
	case media.FieldTitle:
		m.ClearTitle()
		return nil
	case media.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Media nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MediaMutation) ResetField(name string) error {
	switch name {
	case media.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case media.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case media.FieldTitle:
		m.ResetTitle()
		return nil
	case media.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MediaMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.car != nil {
		edges = append(edges, media.EdgeCar)
	}
	if m.albums != nil {
		edges = append(edges, media.EdgeAlbums)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MediaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case media.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case media.EdgeAlbums:
		ids := make([]ent.Value, 0, len(m.albums))
		for id := range m.albums {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MediaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedalbums != nil {
		edges = append(edges, media.EdgeAlbums)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MediaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case media.EdgeAlbums:
		ids := make([]ent.Value, 0, len(m.removedalbums))
		for id := range m.removedalbums {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MediaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcar {
		edges = append(edges, media.EdgeCar)
	}
	if m.clearedalbums {
		edges = append(edges, media.EdgeAlbums)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MediaMutation) EdgeCleared(name string) bool {
	switch name {
	case media.EdgeCar:
		return m.clearedcar
	case media.EdgeAlbums:
		return m.clearedalbums
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MediaMutation) ClearEdge(name string) error {
	switch name {
	case media.EdgeCar:
		m.ClearCar()
		return nil
	}
	return fmt.Errorf("unknown Media unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MediaMutation) ResetEdge(name string) error {
	switch name {
	case media.EdgeCar:
		m.ResetCar()
		return nil
	case media.EdgeAlbums:
		m.ResetAlbums()
		return nil
	}
	return fmt.Errorf("unknown Media edge %s", name)
}

// ModIdeaMutation represents an operation that mutates the ModIdea nodes in the graph.
type ModIdeaMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	create_time            *time.Time
	update_time            *time.Time
	title                  *string
	category               *modidea.Category
	description            *string
	stage                  *string
	clearedFields          map[string]struct{}
	car                    *uuid.UUID
	clearedcar             bool
	tasks                  map[uuid.UUID]struct{}
	removedtasks           map[uuid.UUID]struct{}
	clearedtasks           bool
	product_options        map[uuid.UUID]struct{}
	removedproduct_options map[uuid.UUID]struct{}
	clearedproduct_options bool
	done                   bool
	oldValue               func(context.Context) (*ModIdea, error)
	predicates             []predicate.ModIdea
}

var _ ent.Mutation = (*ModIdeaMutation)(nil)

// modideaOption allows management of the mutation configuration using functional options.
type modideaOption func(*ModIdeaMutation)

// newModIdeaMutation creates new mutation for the ModIdea entity.
func newModIdeaMutation(c config, op Op, opts ...modideaOption) *ModIdeaMutation {
	m := &ModIdeaMutation{
		config:        c,
		op:            op,
		typ:           TypeModIdea,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModIdeaID sets the ID field of the mutation.
func withModIdeaID(id uuid.UUID) modideaOption {
	return func(m *ModIdeaMutation) {
		var (
			err   error
			once  sync.Once
			value *ModIdea
		)
		m.oldValue = func(ctx context.Context) (*ModIdea, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ModIdea.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withModIdea sets the old ModIdea of the mutation.
func withModIdea(node *ModIdea) modideaOption {
	return func(m *ModIdeaMutation) {
		m.oldValue = func(context.Context) (*ModIdea, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModIdeaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModIdeaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ModIdea entities.
func (m *ModIdeaMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ModIdeaMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ModIdeaMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ModIdea.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ModIdeaMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ModIdeaMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ModIdea entity.
// If the ModIdea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModIdeaMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ModIdeaMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ModIdeaMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ModIdeaMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ModIdea entity.
// If the ModIdea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModIdeaMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ModIdeaMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTitle sets the "title" field.
func (m *ModIdeaMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ModIdeaMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ModIdea entity.
// If the ModIdea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModIdeaMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ModIdeaMutation) ResetTitle() {
	m.title = nil
}

// SetCategory sets the "category" field.
func (m *ModIdeaMutation) SetCategory(value modidea.Category) {
	m.category = &value
}

// Category returns the value of the "category" field in the mutation.
func (m *ModIdeaMutation) Category() (r modidea.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ModIdea entity.
// If the ModIdea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModIdeaMutation) OldCategory(ctx context.Context) (v modidea.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ModIdeaMutation) ResetCategory() {
	m.category = nil
}

// SetDescription sets the "description" field.
func (m *ModIdeaMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ModIdeaMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ModIdea entity.
// If the ModIdea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModIdeaMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ModIdeaMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[modidea.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ModIdeaMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[modidea.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ModIdeaMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, modidea.FieldDescription)
}

// SetStage sets the "stage" field.
func (m *ModIdeaMutation) SetStage(s string) {
	m.stage = &s
}

// Stage returns the value of the "stage" field in the mutation.
func (m *ModIdeaMutation) Stage() (r string, exists bool) {
	v := m.stage
	if v == nil {
		return
	}
	return *v, true
}

// OldStage returns the old "stage" field's value of the ModIdea entity.
// If the ModIdea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModIdeaMutation) OldStage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStage: %w", err)
	}
	return oldValue.Stage, nil
}

// ClearStage clears the value of the "stage" field.
func (m *ModIdeaMutation) ClearStage() {
	m.stage = nil
	m.clearedFields[modidea.FieldStage] = struct{}{}
}

// StageCleared returns if the "stage" field was cleared in this mutation.
func (m *ModIdeaMutation) StageCleared() bool {
	_, ok := m.clearedFields[modidea.FieldStage]
	return ok
}

// ResetStage resets all changes to the "stage" field.
func (m *ModIdeaMutation) ResetStage() {
	m.stage = nil
	delete(m.clearedFields, modidea.FieldStage)
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *ModIdeaMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *ModIdeaMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *ModIdeaMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *ModIdeaMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *ModIdeaMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *ModIdeaMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *ModIdeaMutation) AddTaskIDs(ids ...uuid.UUID) {
	if m.tasks == nil {
		m.tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *ModIdeaMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *ModIdeaMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *ModIdeaMutation) RemoveTaskIDs(ids ...uuid.UUID) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *ModIdeaMutation) RemovedTasksIDs() (ids []uuid.UUID) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *ModIdeaMutation) TasksIDs() (ids []uuid.UUID) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *ModIdeaMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddProductOptionIDs adds the "product_options" edge to the ModProductOption entity by ids.
func (m *ModIdeaMutation) AddProductOptionIDs(ids ...uuid.UUID) {
	if m.product_options == nil {
		m.product_options = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.product_options[ids[i]] = struct{}{}
	}
}

// ClearProductOptions clears the "product_options" edge to the ModProductOption entity.
func (m *ModIdeaMutation) ClearProductOptions() {
	m.clearedproduct_options = true
}

// ProductOptionsCleared reports if the "product_options" edge to the ModProductOption entity was cleared.
func (m *ModIdeaMutation) ProductOptionsCleared() bool {
	return m.clearedproduct_options
}

// RemoveProductOptionIDs removes the "product_options" edge to the ModProductOption entity by IDs.
func (m *ModIdeaMutation) RemoveProductOptionIDs(ids ...uuid.UUID) {
	if m.removedproduct_options == nil {
		m.removedproduct_options = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.product_options, ids[i])
		m.removedproduct_options[ids[i]] = struct{}{}
	}
}

// RemovedProductOptions returns the removed IDs of the "product_options" edge to the ModProductOption entity.
func (m *ModIdeaMutation) RemovedProductOptionsIDs() (ids []uuid.UUID) {
	for id := range m.removedproduct_options {
		ids = append(ids, id)
	}
	return
}

// ProductOptionsIDs returns the "product_options" edge IDs in the mutation.
func (m *ModIdeaMutation) ProductOptionsIDs() (ids []uuid.UUID) {
	for id := range m.product_options {
		ids = append(ids, id)
	}
	return
}

// ResetProductOptions resets all changes to the "product_options" edge.
func (m *ModIdeaMutation) ResetProductOptions() {
	m.product_options = nil
	m.clearedproduct_options = false
	m.removedproduct_options = nil
}

// Where appends a list predicates to the ModIdeaMutation builder.
func (m *ModIdeaMutation) Where(ps ...predicate.ModIdea) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ModIdeaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ModIdeaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ModIdea, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ModIdeaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ModIdeaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ModIdea).
func (m *ModIdeaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModIdeaMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, modidea.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, modidea.FieldUpdateTime)
	}
	if m.title != nil {
		fields = append(fields, modidea.FieldTitle)
	}
	if m.category != nil {
		fields = append(fields, modidea.FieldCategory)
	}
	if m.description != nil {
		fields = append(fields, modidea.FieldDescription)
	}
	if m.stage != nil {
		fields = append(fields, modidea.FieldStage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModIdeaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case modidea.FieldCreateTime:
		return m.CreateTime()
	case modidea.FieldUpdateTime:
		return m.UpdateTime()
	case modidea.FieldTitle:
		return m.Title()
	case modidea.FieldCategory:
		return m.Category()
	case modidea.FieldDescription:
		return m.Description()
	case modidea.FieldStage:
		return m.Stage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModIdeaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case modidea.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case modidea.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case modidea.FieldTitle:
		return m.OldTitle(ctx)
	case modidea.FieldCategory:
		return m.OldCategory(ctx)
	case modidea.FieldDescription:
		return m.OldDescription(ctx)
	case modidea.FieldStage:
		return m.OldStage(ctx)
	}
	return nil, fmt.Errorf("unknown ModIdea field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModIdeaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case modidea.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case modidea.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case modidea.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case modidea.FieldCategory:
		v, ok := value.(modidea.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case modidea.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case modidea.FieldStage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStage(v)
		return nil
	}
	return fmt.Errorf("unknown ModIdea field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModIdeaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModIdeaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModIdeaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ModIdea numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModIdeaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(modidea.FieldDescription) {
		fields = append(fields, modidea.FieldDescription)
	}
	if m.FieldCleared(modidea.FieldStage) {
		fields = append(fields, modidea.FieldStage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModIdeaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModIdeaMutation) ClearField(name string) error {
	switch name {
	case modidea.FieldDescription:
		m.ClearDescription()
		return nil
	case modidea.FieldStage:
		m.ClearStage()
		return nil
	}
	return fmt.Errorf("unknown ModIdea nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModIdeaMutation) ResetField(name string) error {
	switch name {
	case modidea.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case modidea.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case modidea.FieldTitle:
		m.ResetTitle()
		return nil
	case modidea.FieldCategory:
		m.ResetCategory()
		return nil
	case modidea.FieldDescription:
		m.ResetDescription()
		return nil
	case modidea.FieldStage:
		m.ResetStage()
		return nil
	}
	return fmt.Errorf("unknown ModIdea field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModIdeaMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.car != nil {
		edges = append(edges, modidea.EdgeCar)
	}
	if m.tasks != nil {
		edges = append(edges, modidea.EdgeTasks)
	}
	if m.product_options != nil {
		edges = append(edges, modidea.EdgeProductOptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModIdeaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case modidea.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case modidea.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case modidea.EdgeProductOptions:
		ids := make([]ent.Value, 0, len(m.product_options))
		for id := range m.product_options {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModIdeaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtasks != nil {
		edges = append(edges, modidea.EdgeTasks)
	}
	if m.removedproduct_options != nil {
		edges = append(edges, modidea.EdgeProductOptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModIdeaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case modidea.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case modidea.EdgeProductOptions:
		ids := make([]ent.Value, 0, len(m.removedproduct_options))
		for id := range m.removedproduct_options {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModIdeaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcar {
		edges = append(edges, modidea.EdgeCar)
	}
	if m.clearedtasks {
		edges = append(edges, modidea.EdgeTasks)
	}
	if m.clearedproduct_options {
		edges = append(edges, modidea.EdgeProductOptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModIdeaMutation) EdgeCleared(name string) bool {
	switch name {
	case modidea.EdgeCar:
		return m.clearedcar
	case modidea.EdgeTasks:
		return m.clearedtasks
	case modidea.EdgeProductOptions:
		return m.clearedproduct_options
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModIdeaMutation) ClearEdge(name string) error {
	switch name {
	case modidea.EdgeCar:
		m.ClearCar()
		return nil
	}
	return fmt.Errorf("unknown ModIdea unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModIdeaMutation) ResetEdge(name string) error {
	switch name {
	case modidea.EdgeCar:
		m.ResetCar()
		return nil
	case modidea.EdgeTasks:
		m.ResetTasks()
		return nil
	case modidea.EdgeProductOptions:
		m.ResetProductOptions()
		return nil
	}
	return fmt.Errorf("unknown ModIdea edge %s", name)
}

// ModProductOptionMutation represents an operation that mutates the ModProductOption nodes in the graph.
type ModProductOptionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	vendor        *string
	name          *string
	link          *string
	price         *float64
	addprice      *float64
	notes         *string
	pros          *[]string
	appendpros    []string
	cons          *[]string
	appendcons    []string
	specs         *map[string]string
	clearedFields map[string]struct{}
	idea          *uuid.UUID
	clearedidea   bool
	done          bool
	oldValue      func(context.Context) (*ModProductOption, error)
	predicates    []predicate.ModProductOption
}

var _ ent.Mutation = (*ModProductOptionMutation)(nil)

// modproductoptionOption allows management of the mutation configuration using functional options.
type modproductoptionOption func(*ModProductOptionMutation)

// newModProductOptionMutation creates new mutation for the ModProductOption entity.
func newModProductOptionMutation(c config, op Op, opts ...modproductoptionOption) *ModProductOptionMutation {
	m := &ModProductOptionMutation{
		config:        c,
		op:            op,
		typ:           TypeModProductOption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModProductOptionID sets the ID field of the mutation.
func withModProductOptionID(id uuid.UUID) modproductoptionOption {
	return func(m *ModProductOptionMutation) {
		var (
			err   error
			once  sync.Once
			value *ModProductOption
		)
		m.oldValue = func(ctx context.Context) (*ModProductOption, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ModProductOption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withModProductOption sets the old ModProductOption of the mutation.
func withModProductOption(node *ModProductOption) modproductoptionOption {
	return func(m *ModProductOptionMutation) {
		m.oldValue = func(context.Context) (*ModProductOption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModProductOptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModProductOptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ModProductOption entities.
func (m *ModProductOptionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ModProductOptionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ModProductOptionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ModProductOption.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ModProductOptionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ModProductOptionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ModProductOption entity.
// If the ModProductOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModProductOptionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ModProductOptionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ModProductOptionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ModProductOptionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ModProductOption entity.
// If the ModProductOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModProductOptionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ModProductOptionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetVendor sets the "vendor" field.
func (m *ModProductOptionMutation) SetVendor(s string) {
	m.vendor = &s
}

// Vendor returns the value of the "vendor" field in the mutation.
func (m *ModProductOptionMutation) Vendor() (r string, exists bool) {
	v := m.vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldVendor returns the old "vendor" field's value of the ModProductOption entity.
// If the ModProductOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModProductOptionMutation) OldVendor(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendor: %w", err)
	}
	return oldValue.Vendor, nil
}

// ClearVendor clears the value of the "vendor" field.
func (m *ModProductOptionMutation) ClearVendor() {
	m.vendor = nil
	m.clearedFields[modproductoption.FieldVendor] = struct{}{}
}

// VendorCleared returns if the "vendor" field was cleared in this mutation.
func (m *ModProductOptionMutation) VendorCleared() bool {
	_, ok := m.clearedFields[modproductoption.FieldVendor]
	return ok
}

// ResetVendor resets all changes to the "vendor" field.
func (m *ModProductOptionMutation) ResetVendor() {
	m.vendor = nil
	delete(m.clearedFields, modproductoption.FieldVendor)
}

// SetName sets the "name" field.
func (m *ModProductOptionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ModProductOptionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ModProductOption entity.
// If the ModProductOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModProductOptionMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ModProductOptionMutation) ClearName() {
	m.name = nil
	m.clearedFields[modproductoption.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ModProductOptionMutation) NameCleared() bool {
	_, ok := m.clearedFields[modproductoption.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ModProductOptionMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, modproductoption.FieldName)
}

// SetLink sets the "link" field.
func (m *ModProductOptionMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *ModProductOptionMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the ModProductOption entity.
// If the ModProductOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModProductOptionMutation) OldLink(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "link" field.
func (m *ModProductOptionMutation) ClearLink() {
	m.link = nil
	m.clearedFields[modproductoption.FieldLink] = struct{}{}
}

// LinkCleared returns if the "link" field was cleared in this mutation.
func (m *ModProductOptionMutation) LinkCleared() bool {
	_, ok := m.clearedFields[modproductoption.FieldLink]
	return ok
}

// ResetLink resets all changes to the "link" field.
func (m *ModProductOptionMutation) ResetLink() {
	m.link = nil
	delete(m.clearedFields, modproductoption.FieldLink)
}

// SetPrice sets the "price" field.
func (m *ModProductOptionMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ModProductOptionMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the ModProductOption entity.
// If the ModProductOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModProductOptionMutation) OldPrice(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *ModProductOptionMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ModProductOptionMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *ModProductOptionMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[modproductoption.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *ModProductOptionMutation) PriceCleared() bool {
	_, ok := m.clearedFields[modproductoption.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *ModProductOptionMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, modproductoption.FieldPrice)
}

// SetNotes sets the "notes" field.
func (m *ModProductOptionMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *ModProductOptionMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the ModProductOption entity.
// If the ModProductOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModProductOptionMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *ModProductOptionMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[modproductoption.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *ModProductOptionMutation) NotesCleared() bool {
	_, ok := m.clearedFields[modproductoption.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *ModProductOptionMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, modproductoption.FieldNotes)
}

// SetPros sets the "pros" field.
func (m *ModProductOptionMutation) SetPros(s []string) {
	m.pros = &s
	m.appendpros = nil
}

// Pros returns the value of the "pros" field in the mutation.
func (m *ModProductOptionMutation) Pros() (r []string, exists bool) {
	v := m.pros
	if v == nil {
		return
	}
	return *v, true
}

// OldPros returns the old "pros" field's value of the ModProductOption entity.
// If the ModProductOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModProductOptionMutation) OldPros(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPros is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPros requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPros: %w", err)
	}
	return oldValue.Pros, nil
}

// AppendPros adds s to the "pros" field.
func (m *ModProductOptionMutation) AppendPros(s []string) {
	m.appendpros = append(m.appendpros, s...)
}

// AppendedPros returns the list of values that were appended to the "pros" field in this mutation.
func (m *ModProductOptionMutation) AppendedPros() ([]string, bool) {
	if len(m.appendpros) == 0 {
		return nil, false
	}
	return m.appendpros, true
}

// ClearPros clears the value of the "pros" field.
func (m *ModProductOptionMutation) ClearPros() {
	m.pros = nil
	m.appendpros = nil
	m.clearedFields[modproductoption.FieldPros] = struct{}{}
}

// ProsCleared returns if the "pros" field was cleared in this mutation.
func (m *ModProductOptionMutation) ProsCleared() bool {
	_, ok := m.clearedFields[modproductoption.FieldPros]
	return ok
}

// ResetPros resets all changes to the "pros" field.
func (m *ModProductOptionMutation) ResetPros() {
	m.pros = nil
	m.appendpros = nil
	delete(m.clearedFields, modproductoption.FieldPros)
}

// SetCons sets the "cons" field.
func (m *ModProductOptionMutation) SetCons(s []string) {
	m.cons = &s
	m.appendcons = nil
}

// Cons returns the value of the "cons" field in the mutation.
func (m *ModProductOptionMutation) Cons() (r []string, exists bool) {
	v := m.cons
	if v == nil {
		return
	}
	return *v, true
}

// OldCons returns the old "cons" field's value of the ModProductOption entity.
// If the ModProductOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModProductOptionMutation) OldCons(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCons is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCons requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCons: %w", err)
	}
	return oldValue.Cons, nil
}

// AppendCons adds s to the "cons" field.
func (m *ModProductOptionMutation) AppendCons(s []string) {
	m.appendcons = append(m.appendcons, s...)
}

// AppendedCons returns the list of values that were appended to the "cons" field in this mutation.
func (m *ModProductOptionMutation) AppendedCons() ([]string, bool) {
	if len(m.appendcons) == 0 {
		return nil, false
	}
	return m.appendcons, true
}

// ClearCons clears the value of the "cons" field.
func (m *ModProductOptionMutation) ClearCons() {
	m.cons = nil
	m.appendcons = nil
	m.clearedFields[modproductoption.FieldCons] = struct{}{}
}

// ConsCleared returns if the "cons" field was cleared in this mutation.
func (m *ModProductOptionMutation) ConsCleared() bool {
	_, ok := m.clearedFields[modproductoption.FieldCons]
	return ok
}

// ResetCons resets all changes to the "cons" field.
func (m *ModProductOptionMutation) ResetCons() {
	m.cons = nil
	m.appendcons = nil
	delete(m.clearedFields, modproductoption.FieldCons)
}

// SetSpecs sets the "specs" field.
func (m *ModProductOptionMutation) SetSpecs(value map[string]string) {
	m.specs = &value
}

// Specs returns the value of the "specs" field in the mutation.
func (m *ModProductOptionMutation) Specs() (r map[string]string, exists bool) {
	v := m.specs
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecs returns the old "specs" field's value of the ModProductOption entity.
// If the ModProductOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModProductOptionMutation) OldSpecs(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecs: %w", err)
	}
	return oldValue.Specs, nil
}

// ClearSpecs clears the value of the "specs" field.
func (m *ModProductOptionMutation) ClearSpecs() {
	m.specs = nil
	m.clearedFields[modproductoption.FieldSpecs] = struct{}{}
}

// SpecsCleared returns if the "specs" field was cleared in this mutation.
func (m *ModProductOptionMutation) SpecsCleared() bool {
	_, ok := m.clearedFields[modproductoption.FieldSpecs]
	return ok
}

// ResetSpecs resets all changes to the "specs" field.
func (m *ModProductOptionMutation) ResetSpecs() {
	m.specs = nil
	delete(m.clearedFields, modproductoption.FieldSpecs)
}

// SetIdeaID sets the "idea" edge to the ModIdea entity by id.
func (m *ModProductOptionMutation) SetIdeaID(id uuid.UUID) {
	m.idea = &id
}

// ClearIdea clears the "idea" edge to the ModIdea entity.
func (m *ModProductOptionMutation) ClearIdea() {
	m.clearedidea = true
}

// IdeaCleared reports if the "idea" edge to the ModIdea entity was cleared.
func (m *ModProductOptionMutation) IdeaCleared() bool {
	return m.clearedidea
}

// IdeaID returns the "idea" edge ID in the mutation.
func (m *ModProductOptionMutation) IdeaID() (id uuid.UUID, exists bool) {
	if m.idea != nil {
		return *m.idea, true
	}
	return
}

// IdeaIDs returns the "idea" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IdeaID instead. It exists only for internal usage by the builders.
func (m *ModProductOptionMutation) IdeaIDs() (ids []uuid.UUID) {
	if id := m.idea; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIdea resets all changes to the "idea" edge.
func (m *ModProductOptionMutation) ResetIdea() {
	m.idea = nil
	m.clearedidea = false
}

// Where appends a list predicates to the ModProductOptionMutation builder.
func (m *ModProductOptionMutation) Where(ps ...predicate.ModProductOption) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ModProductOptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ModProductOptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ModProductOption, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ModProductOptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ModProductOptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ModProductOption).
func (m *ModProductOptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModProductOptionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, modproductoption.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, modproductoption.FieldUpdateTime)
	}
	if m.vendor != nil {
		fields = append(fields, modproductoption.FieldVendor)
	}
	if m.name != nil {
		fields = append(fields, modproductoption.FieldName)
	}
	if m.link != nil {
		fields = append(fields, modproductoption.FieldLink)
	}
	if m.price != nil {
		fields = append(fields, modproductoption.FieldPrice)
	}
	if m.notes != nil {
		fields = append(fields, modproductoption.FieldNotes)
	}
	if m.pros != nil {
		fields = append(fields, modproductoption.FieldPros)
	}
	if m.cons != nil {
		fields = append(fields, modproductoption.FieldCons)
	}
	if m.specs != nil {
		fields = append(fields, modproductoption.FieldSpecs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModProductOptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case modproductoption.FieldCreateTime:
		return m.CreateTime()
	case modproductoption.FieldUpdateTime:
		return m.UpdateTime()
	case modproductoption.FieldVendor:
		return m.Vendor()
	case modproductoption.FieldName:
		return m.Name()
	case modproductoption.FieldLink:
		return m.Link()
	case modproductoption.FieldPrice:
		return m.Price()
	case modproductoption.FieldNotes:
		return m.Notes()
	case modproductoption.FieldPros:
		return m.Pros()
	case modproductoption.FieldCons:
		return m.Cons()
	case modproductoption.FieldSpecs:
		return m.Specs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModProductOptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case modproductoption.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case modproductoption.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case modproductoption.FieldVendor:
		return m.OldVendor(ctx)
	case modproductoption.FieldName:
		return m.OldName(ctx)
	case modproductoption.FieldLink:
		return m.OldLink(ctx)
	case modproductoption.FieldPrice:
		return m.OldPrice(ctx)
	case modproductoption.FieldNotes:
		return m.OldNotes(ctx)
	case modproductoption.FieldPros:
		return m.OldPros(ctx)
	case modproductoption.FieldCons:
		return m.OldCons(ctx)
	case modproductoption.FieldSpecs:
		return m.OldSpecs(ctx)
	}
	return nil, fmt.Errorf("unknown ModProductOption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModProductOptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case modproductoption.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case modproductoption.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case modproductoption.FieldVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendor(v)
		return nil
	case modproductoption.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case modproductoption.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case modproductoption.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case modproductoption.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case modproductoption.FieldPros:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPros(v)
		return nil
	case modproductoption.FieldCons:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCons(v)
		return nil
	case modproductoption.FieldSpecs:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecs(v)
		return nil
	}
	return fmt.Errorf("unknown ModProductOption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModProductOptionMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, modproductoption.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModProductOptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case modproductoption.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModProductOptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case modproductoption.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown ModProductOption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModProductOptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(modproductoption.FieldVendor) {
		fields = append(fields, modproductoption.FieldVendor)
	}
	if m.FieldCleared(modproductoption.FieldName) {
		fields = append(fields, modproductoption.FieldName)
	}
	if m.FieldCleared(modproductoption.FieldLink) {
		fields = append(fields, modproductoption.FieldLink)
	}
	if m.FieldCleared(modproductoption.FieldPrice) {
		fields = append(fields, modproductoption.FieldPrice)
	}
	if m.FieldCleared(modproductoption.FieldNotes) {
		fields = append(fields, modproductoption.FieldNotes)
	}
	if m.FieldCleared(modproductoption.FieldPros) {
		fields = append(fields, modproductoption.FieldPros)
	}
	if m.FieldCleared(modproductoption.FieldCons) {
		fields = append(fields, modproductoption.FieldCons)
	}
	if m.FieldCleared(modproductoption.FieldSpecs) {
		fields = append(fields, modproductoption.FieldSpecs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModProductOptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModProductOptionMutation) ClearField(name string) error {
	switch name {
	case modproductoption.FieldVendor:
		m.ClearVendor()
		return nil
	case modproductoption.FieldName:
		m.ClearName()
		return nil
	case modproductoption.FieldLink:
		m.ClearLink()
		return nil
	case modproductoption.FieldPrice:
		m.ClearPrice()
		return nil
	case modproductoption.FieldNotes:
		m.ClearNotes()
		return nil
	case modproductoption.FieldPros:
		m.ClearPros()
		return nil
	case modproductoption.FieldCons:
		m.ClearCons()
		return nil
	case modproductoption.FieldSpecs:
		m.ClearSpecs()
		return nil
	}
	return fmt.Errorf("unknown ModProductOption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModProductOptionMutation) ResetField(name string) error {
	switch name {
	case modproductoption.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case modproductoption.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case modproductoption.FieldVendor:
		m.ResetVendor()
		return nil
	case modproductoption.FieldName:
		m.ResetName()
		return nil
	case modproductoption.FieldLink:
		m.ResetLink()
		return nil
	case modproductoption.FieldPrice:
		m.ResetPrice()
		return nil
	case modproductoption.FieldNotes:
		m.ResetNotes()
		return nil
	case modproductoption.FieldPros:
		m.ResetPros()
		return nil
	case modproductoption.FieldCons:
		m.ResetCons()
		return nil
	case modproductoption.FieldSpecs:
		m.ResetSpecs()
		return nil
	}
	return fmt.Errorf("unknown ModProductOption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModProductOptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.idea != nil {
		edges = append(edges, modproductoption.EdgeIdea)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModProductOptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case modproductoption.EdgeIdea:
		if id := m.idea; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModProductOptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModProductOptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModProductOptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedidea {
		edges = append(edges, modproductoption.EdgeIdea)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModProductOptionMutation) EdgeCleared(name string) bool {
	switch name {
	case modproductoption.EdgeIdea:
		return m.clearedidea
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModProductOptionMutation) ClearEdge(name string) error {
	switch name {
	case modproductoption.EdgeIdea:
		m.ClearIdea()
		return nil
	}
	return fmt.Errorf("unknown ModProductOption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModProductOptionMutation) ResetEdge(name string) error {
	switch name {
	case modproductoption.EdgeIdea:
		m.ResetIdea()
		return nil
	}
	return fmt.Errorf("unknown ModProductOption edge %s", name)
}

// OdometerReadingMutation represents an operation that mutates the OdometerReading nodes in the graph.
type OdometerReadingMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	create_time        *time.Time
	update_time        *time.Time
	reading_km         *float64
	addreading_km      *float64
	reading_time       *time.Time
	notes              *string
	clearedFields      map[string]struct{}
	car                *uuid.UUID
	clearedcar         bool
	fuel_up            *uuid.UUID
	clearedfuel_up     bool
	service_log        *uuid.UUID
	clearedservice_log bool
	done               bool
	oldValue           func(context.Context) (*OdometerReading, error)
	predicates         []predicate.OdometerReading
}

var _ ent.Mutation = (*OdometerReadingMutation)(nil)

// odometerreadingOption allows management of the mutation configuration using functional options.
type odometerreadingOption func(*OdometerReadingMutation)

// newOdometerReadingMutation creates new mutation for the OdometerReading entity.
func newOdometerReadingMutation(c config, op Op, opts ...odometerreadingOption) *OdometerReadingMutation {
	m := &OdometerReadingMutation{
		config:        c,
		op:            op,
		typ:           TypeOdometerReading,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOdometerReadingID sets the ID field of the mutation.
func withOdometerReadingID(id uuid.UUID) odometerreadingOption {
	return func(m *OdometerReadingMutation) {
		var (
			err   error
			once  sync.Once
			value *OdometerReading
		)
		m.oldValue = func(ctx context.Context) (*OdometerReading, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OdometerReading.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOdometerReading sets the old OdometerReading of the mutation.
func withOdometerReading(node *OdometerReading) odometerreadingOption {
	return func(m *OdometerReadingMutation) {
		m.oldValue = func(context.Context) (*OdometerReading, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OdometerReadingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OdometerReadingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OdometerReading entities.
func (m *OdometerReadingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OdometerReadingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OdometerReadingMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OdometerReading.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *OdometerReadingMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OdometerReadingMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OdometerReading entity.
// If the OdometerReading object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OdometerReadingMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OdometerReadingMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OdometerReadingMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OdometerReadingMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OdometerReading entity.
// If the OdometerReading object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OdometerReadingMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OdometerReadingMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetReadingKm sets the "reading_km" field.
func (m *OdometerReadingMutation) SetReadingKm(f float64) {
	m.reading_km = &f
	m.addreading_km = nil
}

// ReadingKm returns the value of the "reading_km" field in the mutation.
func (m *OdometerReadingMutation) ReadingKm() (r float64, exists bool) {
	v := m.reading_km
	if v == nil {
		return
	}
	return *v, true
}

// OldReadingKm returns the old "reading_km" field's value of the OdometerReading entity.
// If the OdometerReading object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OdometerReadingMutation) OldReadingKm(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadingKm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadingKm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadingKm: %w", err)
	}
	return oldValue.ReadingKm, nil
}

// AddReadingKm adds f to the "reading_km" field.
func (m *OdometerReadingMutation) AddReadingKm(f float64) {
	if m.addreading_km != nil {
		*m.addreading_km += f
	} else {
		m.addreading_km = &f
	}
}

// AddedReadingKm returns the value that was added to the "reading_km" field in this mutation.
func (m *OdometerReadingMutation) AddedReadingKm() (r float64, exists bool) {
	v := m.addreading_km
	if v == nil {
		return
	}
	return *v, true
}

// ResetReadingKm resets all changes to the "reading_km" field.
func (m *OdometerReadingMutation) ResetReadingKm() {
	m.reading_km = nil
	m.addreading_km = nil
}

// SetReadingTime sets the "reading_time" field.
func (m *OdometerReadingMutation) SetReadingTime(t time.Time) {
	m.reading_time = &t
}

// ReadingTime returns the value of the "reading_time" field in the mutation.
func (m *OdometerReadingMutation) ReadingTime() (r time.Time, exists bool) {
	v := m.reading_time
	if v == nil {
		return
	}
	return *v, true
}

// OldReadingTime returns the old "reading_time" field's value of the OdometerReading entity.
// If the OdometerReading object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OdometerReadingMutation) OldReadingTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadingTime: %w", err)
	}
	return oldValue.ReadingTime, nil
}

// ResetReadingTime resets all changes to the "reading_time" field.
func (m *OdometerReadingMutation) ResetReadingTime() {
	m.reading_time = nil
}

// SetNotes sets the "notes" field.
func (m *OdometerReadingMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *OdometerReadingMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the OdometerReading entity.
// If the OdometerReading object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OdometerReadingMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *OdometerReadingMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[odometerreading.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *OdometerReadingMutation) NotesCleared() bool {
	_, ok := m.clearedFields[odometerreading.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *OdometerReadingMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, odometerreading.FieldNotes)
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *OdometerReadingMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *OdometerReadingMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *OdometerReadingMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *OdometerReadingMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *OdometerReadingMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *OdometerReadingMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// SetFuelUpID sets the "fuel_up" edge to the FuelUp entity by id.
func (m *OdometerReadingMutation) SetFuelUpID(id uuid.UUID) {
	m.fuel_up = &id
}

// ClearFuelUp clears the "fuel_up" edge to the FuelUp entity.
func (m *OdometerReadingMutation) ClearFuelUp() {
	m.clearedfuel_up = true
}

// FuelUpCleared reports if the "fuel_up" edge to the FuelUp entity was cleared.
func (m *OdometerReadingMutation) FuelUpCleared() bool {
	return m.clearedfuel_up
}

// FuelUpID returns the "fuel_up" edge ID in the mutation.
func (m *OdometerReadingMutation) FuelUpID() (id uuid.UUID, exists bool) {
	if m.fuel_up != nil {
		return *m.fuel_up, true
	}
	return
}

// FuelUpIDs returns the "fuel_up" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FuelUpID instead. It exists only for internal usage by the builders.
func (m *OdometerReadingMutation) FuelUpIDs() (ids []uuid.UUID) {
	if id := m.fuel_up; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFuelUp resets all changes to the "fuel_up" edge.
func (m *OdometerReadingMutation) ResetFuelUp() {
	m.fuel_up = nil
	m.clearedfuel_up = false
}

// SetServiceLogID sets the "service_log" edge to the ServiceLog entity by id.
func (m *OdometerReadingMutation) SetServiceLogID(id uuid.UUID) {
	m.service_log = &id
}

// ClearServiceLog clears the "service_log" edge to the ServiceLog entity.
func (m *OdometerReadingMutation) ClearServiceLog() {
	m.clearedservice_log = true
}

// ServiceLogCleared reports if the "service_log" edge to the ServiceLog entity was cleared.
func (m *OdometerReadingMutation) ServiceLogCleared() bool {
	return m.clearedservice_log
}

// ServiceLogID returns the "service_log" edge ID in the mutation.
func (m *OdometerReadingMutation) ServiceLogID() (id uuid.UUID, exists bool) {
	if m.service_log != nil {
		return *m.service_log, true
	}
	return
}

// ServiceLogIDs returns the "service_log" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceLogID instead. It exists only for internal usage by the builders.
func (m *OdometerReadingMutation) ServiceLogIDs() (ids []uuid.UUID) {
	if id := m.service_log; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceLog resets all changes to the "service_log" edge.
func (m *OdometerReadingMutation) ResetServiceLog() {
	m.service_log = nil
	m.clearedservice_log = false
}

// Where appends a list predicates to the OdometerReadingMutation builder.
func (m *OdometerReadingMutation) Where(ps ...predicate.OdometerReading) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OdometerReadingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OdometerReadingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OdometerReading, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OdometerReadingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OdometerReadingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OdometerReading).
func (m *OdometerReadingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OdometerReadingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, odometerreading.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, odometerreading.FieldUpdateTime)
	}
	if m.reading_km != nil {
		fields = append(fields, odometerreading.FieldReadingKm)
	}
	if m.reading_time != nil {
		fields = append(fields, odometerreading.FieldReadingTime)
	}
	if m.notes != nil {
		fields = append(fields, odometerreading.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OdometerReadingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case odometerreading.FieldCreateTime:
		return m.CreateTime()
	case odometerreading.FieldUpdateTime:
		return m.UpdateTime()
	case odometerreading.FieldReadingKm:
		return m.ReadingKm()
	case odometerreading.FieldReadingTime:
		return m.ReadingTime()
	case odometerreading.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OdometerReadingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case odometerreading.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case odometerreading.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case odometerreading.FieldReadingKm:
		return m.OldReadingKm(ctx)
	case odometerreading.FieldReadingTime:
		return m.OldReadingTime(ctx)
	case odometerreading.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown OdometerReading field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OdometerReadingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case odometerreading.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case odometerreading.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case odometerreading.FieldReadingKm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadingKm(v)
		return nil
	case odometerreading.FieldReadingTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadingTime(v)
		return nil
	case odometerreading.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown OdometerReading field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OdometerReadingMutation) AddedFields() []string {
	var fields []string
	if m.addreading_km != nil {
		fields = append(fields, odometerreading.FieldReadingKm)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OdometerReadingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case odometerreading.FieldReadingKm:
		return m.AddedReadingKm()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OdometerReadingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case odometerreading.FieldReadingKm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReadingKm(v)
		return nil
	}
	return fmt.Errorf("unknown OdometerReading numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OdometerReadingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(odometerreading.FieldNotes) {
		fields = append(fields, odometerreading.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OdometerReadingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OdometerReadingMutation) ClearField(name string) error {
	switch name {
	case odometerreading.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown OdometerReading nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OdometerReadingMutation) ResetField(name string) error {
	switch name {
	case odometerreading.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case odometerreading.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case odometerreading.FieldReadingKm:
		m.ResetReadingKm()
		return nil
	case odometerreading.FieldReadingTime:
		m.ResetReadingTime()
		return nil
	case odometerreading.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown OdometerReading field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OdometerReadingMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.car != nil {
		edges = append(edges, odometerreading.EdgeCar)
	}
	if m.fuel_up != nil {
		edges = append(edges, odometerreading.EdgeFuelUp)
	}
	if m.service_log != nil {
		edges = append(edges, odometerreading.EdgeServiceLog)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OdometerReadingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case odometerreading.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case odometerreading.EdgeFuelUp:
		if id := m.fuel_up; id != nil {
			return []ent.Value{*id}
		}
	case odometerreading.EdgeServiceLog:
		if id := m.service_log; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OdometerReadingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OdometerReadingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OdometerReadingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcar {
		edges = append(edges, odometerreading.EdgeCar)
	}
	if m.clearedfuel_up {
		edges = append(edges, odometerreading.EdgeFuelUp)
	}
	if m.clearedservice_log {
		edges = append(edges, odometerreading.EdgeServiceLog)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OdometerReadingMutation) EdgeCleared(name string) bool {
	switch name {
	case odometerreading.EdgeCar:
		return m.clearedcar
	case odometerreading.EdgeFuelUp:
		return m.clearedfuel_up
	case odometerreading.EdgeServiceLog:
		return m.clearedservice_log
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OdometerReadingMutation) ClearEdge(name string) error {
	switch name {
	case odometerreading.EdgeCar:
		m.ClearCar()
		return nil
	case odometerreading.EdgeFuelUp:
		m.ClearFuelUp()
		return nil
	case odometerreading.EdgeServiceLog:
		m.ClearServiceLog()
		return nil
	}
	return fmt.Errorf("unknown OdometerReading unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OdometerReadingMutation) ResetEdge(name string) error {
	switch name {
	case odometerreading.EdgeCar:
		m.ResetCar()
		return nil
	case odometerreading.EdgeFuelUp:
		m.ResetFuelUp()
		return nil
	case odometerreading.EdgeServiceLog:
		m.ResetServiceLog()
		return nil
	}
	return fmt.Errorf("unknown OdometerReading edge %s", name)
}

// ProfileMutation represents an operation that mutates the Profile nodes in the graph.
type ProfileMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	username      *string
	first_name    *string
	last_name     *string
	picture       *uuid.UUID
	visibility    *profile.Visibility
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Profile, error)
	predicates    []predicate.Profile
}

var _ ent.Mutation = (*ProfileMutation)(nil)

// profileOption allows management of the mutation configuration using functional options.
type profileOption func(*ProfileMutation)

// newProfileMutation creates new mutation for the Profile entity.
func newProfileMutation(c config, op Op, opts ...profileOption) *ProfileMutation {
	m := &ProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfileID sets the ID field of the mutation.
func withProfileID(id uuid.UUID) profileOption {
	return func(m *ProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *Profile
		)
		m.oldValue = func(ctx context.Context) (*Profile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Profile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfile sets the old Profile of the mutation.
func withProfile(node *Profile) profileOption {
	return func(m *ProfileMutation) {
		m.oldValue = func(context.Context) (*Profile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Profile entities.
func (m *ProfileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Profile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ProfileMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProfileMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProfileMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProfileMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProfileMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProfileMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUsername sets the "username" field.
func (m *ProfileMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *ProfileMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *ProfileMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[profile.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *ProfileMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[profile.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *ProfileMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, profile.FieldUsername)
}

// SetFirstName sets the "first_name" field.
func (m *ProfileMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *ProfileMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldFirstName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *ProfileMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[profile.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *ProfileMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[profile.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *ProfileMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, profile.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *ProfileMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *ProfileMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldLastName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *ProfileMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[profile.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *ProfileMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[profile.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *ProfileMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, profile.FieldLastName)
}

// SetPicture sets the "picture" field.
func (m *ProfileMutation) SetPicture(u uuid.UUID) {
	m.picture = &u
}

// Picture returns the value of the "picture" field in the mutation.
func (m *ProfileMutation) Picture() (r uuid.UUID, exists bool) {
	v := m.picture
	if v == nil {
		return
	}
	return *v, true
}

// OldPicture returns the old "picture" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldPicture(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicture: %w", err)
	}
	return oldValue.Picture, nil
}

// ClearPicture clears the value of the "picture" field.
func (m *ProfileMutation) ClearPicture() {
	m.picture = nil
	m.clearedFields[profile.FieldPicture] = struct{}{}
}

// PictureCleared returns if the "picture" field was cleared in this mutation.
func (m *ProfileMutation) PictureCleared() bool {
	_, ok := m.clearedFields[profile.FieldPicture]
	return ok
}

// ResetPicture resets all changes to the "picture" field.
func (m *ProfileMutation) ResetPicture() {
	m.picture = nil
	delete(m.clearedFields, profile.FieldPicture)
}

// SetVisibility sets the "visibility" field.
func (m *ProfileMutation) SetVisibility(pr profile.Visibility) {
	m.visibility = &pr
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *ProfileMutation) Visibility() (r profile.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldVisibility(ctx context.Context) (v profile.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *ProfileMutation) ResetVisibility() {
	m.visibility = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ProfileMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProfileMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProfileMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ProfileMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProfileMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProfileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ProfileMutation builder.
func (m *ProfileMutation) Where(ps ...predicate.Profile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Profile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Profile).
func (m *ProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfileMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, profile.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, profile.FieldUpdateTime)
	}
	if m.username != nil {
		fields = append(fields, profile.FieldUsername)
	}
	if m.first_name != nil {
		fields = append(fields, profile.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, profile.FieldLastName)
	}
	if m.picture != nil {
		fields = append(fields, profile.FieldPicture)
	}
	if m.visibility != nil {
		fields = append(fields, profile.FieldVisibility)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profile.FieldCreateTime:
		return m.CreateTime()
	case profile.FieldUpdateTime:
		return m.UpdateTime()
	case profile.FieldUsername:
		return m.Username()
	case profile.FieldFirstName:
		return m.FirstName()
	case profile.FieldLastName:
		return m.LastName()
	case profile.FieldPicture:
		return m.Picture()
	case profile.FieldVisibility:
		return m.Visibility()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profile.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case profile.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case profile.FieldUsername:
		return m.OldUsername(ctx)
	case profile.FieldFirstName:
		return m.OldFirstName(ctx)
	case profile.FieldLastName:
		return m.OldLastName(ctx)
	case profile.FieldPicture:
		return m.OldPicture(ctx)
	case profile.FieldVisibility:
		return m.OldVisibility(ctx)
	}
	return nil, fmt.Errorf("unknown Profile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profile.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case profile.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case profile.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case profile.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case profile.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case profile.FieldPicture:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicture(v)
		return nil
	case profile.FieldVisibility:
		v, ok := value.(profile.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Profile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(profile.FieldUsername) {
		fields = append(fields, profile.FieldUsername)
	}
	if m.FieldCleared(profile.FieldFirstName) {
		fields = append(fields, profile.FieldFirstName)
	}
	if m.FieldCleared(profile.FieldLastName) {
		fields = append(fields, profile.FieldLastName)
	}
	if m.FieldCleared(profile.FieldPicture) {
		fields = append(fields, profile.FieldPicture)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfileMutation) ClearField(name string) error {
	switch name {
	case profile.FieldUsername:
		m.ClearUsername()
		return nil
	case profile.FieldFirstName:
		m.ClearFirstName()
		return nil
	case profile.FieldLastName:
		m.ClearLastName()
		return nil
	case profile.FieldPicture:
		m.ClearPicture()
		return nil
	}
	return fmt.Errorf("unknown Profile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfileMutation) ResetField(name string) error {
	switch name {
	case profile.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case profile.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case profile.FieldUsername:
		m.ResetUsername()
		return nil
	case profile.FieldFirstName:
		m.ResetFirstName()
		return nil
	case profile.FieldLastName:
		m.ResetLastName()
		return nil
	case profile.FieldPicture:
		m.ResetPicture()
		return nil
	case profile.FieldVisibility:
		m.ResetVisibility()
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, profile.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, profile.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case profile.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfileMutation) ClearEdge(name string) error {
	switch name {
	case profile.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Profile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfileMutation) ResetEdge(name string) error {
	switch name {
	case profile.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Profile edge %s", name)
}

// ServiceItemMutation represents an operation that mutates the ServiceItem nodes in the graph.
type ServiceItemMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	create_time                *time.Time
	update_time                *time.Time
	label                      *string
	estimated_minutes          *int
	addestimated_minutes       *int
	default_interval_km        *float64
	adddefault_interval_km     *float64
	default_interval_months    *int
	adddefault_interval_months *int
	notes                      *string
	tags                       *[]string
	appendtags                 []string
	clearedFields              map[string]struct{}
	car                        *uuid.UUID
	clearedcar                 bool
	schedules                  map[uuid.UUID]struct{}
	removedschedules           map[uuid.UUID]struct{}
	clearedschedules           bool
	logs                       map[uuid.UUID]struct{}
	removedlogs                map[uuid.UUID]struct{}
	clearedlogs                bool
	done                       bool
	oldValue                   func(context.Context) (*ServiceItem, error)
	predicates                 []predicate.ServiceItem
}

var _ ent.Mutation = (*ServiceItemMutation)(nil)

// serviceitemOption allows management of the mutation configuration using functional options.
type serviceitemOption func(*ServiceItemMutation)

// newServiceItemMutation creates new mutation for the ServiceItem entity.
func newServiceItemMutation(c config, op Op, opts ...serviceitemOption) *ServiceItemMutation {
	m := &ServiceItemMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceItemID sets the ID field of the mutation.
func withServiceItemID(id uuid.UUID) serviceitemOption {
	return func(m *ServiceItemMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceItem
		)
		m.oldValue = func(ctx context.Context) (*ServiceItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceItem sets the old ServiceItem of the mutation.
func withServiceItem(node *ServiceItem) serviceitemOption {
	return func(m *ServiceItemMutation) {
		m.oldValue = func(context.Context) (*ServiceItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceItem entities.
func (m *ServiceItemMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceItemMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceItemMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ServiceItemMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ServiceItemMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ServiceItem entity.
// If the ServiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceItemMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ServiceItemMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ServiceItemMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ServiceItemMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ServiceItem entity.
// If the ServiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceItemMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ServiceItemMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetLabel sets the "label" field.
func (m *ServiceItemMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *ServiceItemMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the ServiceItem entity.
// If the ServiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceItemMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *ServiceItemMutation) ResetLabel() {
	m.label = nil
}

// SetEstimatedMinutes sets the "estimated_minutes" field.
func (m *ServiceItemMutation) SetEstimatedMinutes(i int) {
	m.estimated_minutes = &i
	m.addestimated_minutes = nil
}

// EstimatedMinutes returns the value of the "estimated_minutes" field in the mutation.
func (m *ServiceItemMutation) EstimatedMinutes() (r int, exists bool) {
	v := m.estimated_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedMinutes returns the old "estimated_minutes" field's value of the ServiceItem entity.
// If the ServiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceItemMutation) OldEstimatedMinutes(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedMinutes: %w", err)
	}
	return oldValue.EstimatedMinutes, nil
}

// AddEstimatedMinutes adds i to the "estimated_minutes" field.
func (m *ServiceItemMutation) AddEstimatedMinutes(i int) {
	if m.addestimated_minutes != nil {
		*m.addestimated_minutes += i
	} else {
		m.addestimated_minutes = &i
	}
}

// AddedEstimatedMinutes returns the value that was added to the "estimated_minutes" field in this mutation.
func (m *ServiceItemMutation) AddedEstimatedMinutes() (r int, exists bool) {
	v := m.addestimated_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimatedMinutes clears the value of the "estimated_minutes" field.
func (m *ServiceItemMutation) ClearEstimatedMinutes() {
	m.estimated_minutes = nil
	m.addestimated_minutes = nil
	m.clearedFields[serviceitem.FieldEstimatedMinutes] = struct{}{}
}

// EstimatedMinutesCleared returns if the "estimated_minutes" field was cleared in this mutation.
func (m *ServiceItemMutation) EstimatedMinutesCleared() bool {
	_, ok := m.clearedFields[serviceitem.FieldEstimatedMinutes]
	return ok
}

// ResetEstimatedMinutes resets all changes to the "estimated_minutes" field.
func (m *ServiceItemMutation) ResetEstimatedMinutes() {
	m.estimated_minutes = nil
	m.addestimated_minutes = nil
	delete(m.clearedFields, serviceitem.FieldEstimatedMinutes)
}

// SetDefaultIntervalKm sets the "default_interval_km" field.
func (m *ServiceItemMutation) SetDefaultIntervalKm(f float64) {
	m.default_interval_km = &f
	m.adddefault_interval_km = nil
}

// DefaultIntervalKm returns the value of the "default_interval_km" field in the mutation.
func (m *ServiceItemMutation) DefaultIntervalKm() (r float64, exists bool) {
	v := m.default_interval_km
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultIntervalKm returns the old "default_interval_km" field's value of the ServiceItem entity.
// If the ServiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceItemMutation) OldDefaultIntervalKm(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultIntervalKm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultIntervalKm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultIntervalKm: %w", err)
	}
	return oldValue.DefaultIntervalKm, nil
}

// AddDefaultIntervalKm adds f to the "default_interval_km" field.
func (m *ServiceItemMutation) AddDefaultIntervalKm(f float64) {
	if m.adddefault_interval_km != nil {
		*m.adddefault_interval_km += f
	} else {
		m.adddefault_interval_km = &f
	}
}

// AddedDefaultIntervalKm returns the value that was added to the "default_interval_km" field in this mutation.
func (m *ServiceItemMutation) AddedDefaultIntervalKm() (r float64, exists bool) {
	v := m.adddefault_interval_km
	if v == nil {
		return
	}
	return *v, true
}

// ClearDefaultIntervalKm clears the value of the "default_interval_km" field.
func (m *ServiceItemMutation) ClearDefaultIntervalKm() {
	m.default_interval_km = nil
	m.adddefault_interval_km = nil
	m.clearedFields[serviceitem.FieldDefaultIntervalKm] = struct{}{}
}

// DefaultIntervalKmCleared returns if the "default_interval_km" field was cleared in this mutation.
func (m *ServiceItemMutation) DefaultIntervalKmCleared() bool {
	_, ok := m.clearedFields[serviceitem.FieldDefaultIntervalKm]
	return ok
}

// ResetDefaultIntervalKm resets all changes to the "default_interval_km" field.
func (m *ServiceItemMutation) ResetDefaultIntervalKm() {
	m.default_interval_km = nil
	m.adddefault_interval_km = nil
	delete(m.clearedFields, serviceitem.FieldDefaultIntervalKm)
}

// SetDefaultIntervalMonths sets the "default_interval_months" field.
func (m *ServiceItemMutation) SetDefaultIntervalMonths(i int) {
	m.default_interval_months = &i
	m.adddefault_interval_months = nil
}

// DefaultIntervalMonths returns the value of the "default_interval_months" field in the mutation.
func (m *ServiceItemMutation) DefaultIntervalMonths() (r int, exists bool) {
	v := m.default_interval_months
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultIntervalMonths returns the old "default_interval_months" field's value of the ServiceItem entity.
// If the ServiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceItemMutation) OldDefaultIntervalMonths(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultIntervalMonths is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultIntervalMonths requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultIntervalMonths: %w", err)
	}
	return oldValue.DefaultIntervalMonths, nil
}

// AddDefaultIntervalMonths adds i to the "default_interval_months" field.
func (m *ServiceItemMutation) AddDefaultIntervalMonths(i int) {
	if m.adddefault_interval_months != nil {
		*m.adddefault_interval_months += i
	} else {
		m.adddefault_interval_months = &i
	}
}

// AddedDefaultIntervalMonths returns the value that was added to the "default_interval_months" field in this mutation.
func (m *ServiceItemMutation) AddedDefaultIntervalMonths() (r int, exists bool) {
	v := m.adddefault_interval_months
	if v == nil {
		return
	}
	return *v, true
}

// ClearDefaultIntervalMonths clears the value of the "default_interval_months" field.
func (m *ServiceItemMutation) ClearDefaultIntervalMonths() {
	m.default_interval_months = nil
	m.adddefault_interval_months = nil
	m.clearedFields[serviceitem.FieldDefaultIntervalMonths] = struct{}{}
}

// DefaultIntervalMonthsCleared returns if the "default_interval_months" field was cleared in this mutation.
func (m *ServiceItemMutation) DefaultIntervalMonthsCleared() bool {
	_, ok := m.clearedFields[serviceitem.FieldDefaultIntervalMonths]
	return ok
}

// ResetDefaultIntervalMonths resets all changes to the "default_interval_months" field.
func (m *ServiceItemMutation) ResetDefaultIntervalMonths() {
	m.default_interval_months = nil
	m.adddefault_interval_months = nil
	delete(m.clearedFields, serviceitem.FieldDefaultIntervalMonths)
}

// SetNotes sets the "notes" field.
func (m *ServiceItemMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *ServiceItemMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the ServiceItem entity.
// If the ServiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceItemMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *ServiceItemMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[serviceitem.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *ServiceItemMutation) NotesCleared() bool {
	_, ok := m.clearedFields[serviceitem.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *ServiceItemMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, serviceitem.FieldNotes)
}

// SetTags sets the "tags" field.
func (m *ServiceItemMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ServiceItemMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ServiceItem entity.
// If the ServiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceItemMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ServiceItemMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ServiceItemMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *ServiceItemMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *ServiceItemMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *ServiceItemMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *ServiceItemMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *ServiceItemMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *ServiceItemMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *ServiceItemMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// AddScheduleIDs adds the "schedules" edge to the ServiceSchedule entity by ids.
func (m *ServiceItemMutation) AddScheduleIDs(ids ...uuid.UUID) {
	if m.schedules == nil {
		m.schedules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.schedules[ids[i]] = struct{}{}
	}
}

// ClearSchedules clears the "schedules" edge to the ServiceSchedule entity.
func (m *ServiceItemMutation) ClearSchedules() {
	m.clearedschedules = true
}

// SchedulesCleared reports if the "schedules" edge to the ServiceSchedule entity was cleared.
func (m *ServiceItemMutation) SchedulesCleared() bool {
	return m.clearedschedules
}

// RemoveScheduleIDs removes the "schedules" edge to the ServiceSchedule entity by IDs.
func (m *ServiceItemMutation) RemoveScheduleIDs(ids ...uuid.UUID) {
	if m.removedschedules == nil {
		m.removedschedules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.schedules, ids[i])
		m.removedschedules[ids[i]] = struct{}{}
	}
}

// RemovedSchedules returns the removed IDs of the "schedules" edge to the ServiceSchedule entity.
func (m *ServiceItemMutation) RemovedSchedulesIDs() (ids []uuid.UUID) {
	for id := range m.removedschedules {
		ids = append(ids, id)
	}
	return
}

// SchedulesIDs returns the "schedules" edge IDs in the mutation.
func (m *ServiceItemMutation) SchedulesIDs() (ids []uuid.UUID) {
	for id := range m.schedules {
		ids = append(ids, id)
	}
	return
}

// ResetSchedules resets all changes to the "schedules" edge.
func (m *ServiceItemMutation) ResetSchedules() {
	m.schedules = nil
	m.clearedschedules = false
	m.removedschedules = nil
}

// AddLogIDs adds the "logs" edge to the ServiceLog entity by ids.
func (m *ServiceItemMutation) AddLogIDs(ids ...uuid.UUID) {
	if m.logs == nil {
		m.logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the ServiceLog entity.
func (m *ServiceItemMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the ServiceLog entity was cleared.
func (m *ServiceItemMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the ServiceLog entity by IDs.
func (m *ServiceItemMutation) RemoveLogIDs(ids ...uuid.UUID) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the ServiceLog entity.
func (m *ServiceItemMutation) RemovedLogsIDs() (ids []uuid.UUID) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *ServiceItemMutation) LogsIDs() (ids []uuid.UUID) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *ServiceItemMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// Where appends a list predicates to the ServiceItemMutation builder.
func (m *ServiceItemMutation) Where(ps ...predicate.ServiceItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceItem).
func (m *ServiceItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceItemMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, serviceitem.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, serviceitem.FieldUpdateTime)
	}
	if m.label != nil {
		fields = append(fields, serviceitem.FieldLabel)
	}
	if m.estimated_minutes != nil {
		fields = append(fields, serviceitem.FieldEstimatedMinutes)
	}
	if m.default_interval_km != nil {
		fields = append(fields, serviceitem.FieldDefaultIntervalKm)
	}
	if m.default_interval_months != nil {
		fields = append(fields, serviceitem.FieldDefaultIntervalMonths)
	}
	if m.notes != nil {
		fields = append(fields, serviceitem.FieldNotes)
	}
	if m.tags != nil {
		fields = append(fields, serviceitem.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serviceitem.FieldCreateTime:
		return m.CreateTime()
	case serviceitem.FieldUpdateTime:
		return m.UpdateTime()
	case serviceitem.FieldLabel:
		return m.Label()
	case serviceitem.FieldEstimatedMinutes:
		return m.EstimatedMinutes()
	case serviceitem.FieldDefaultIntervalKm:
		return m.DefaultIntervalKm()
	case serviceitem.FieldDefaultIntervalMonths:
		return m.DefaultIntervalMonths()
	case serviceitem.FieldNotes:
		return m.Notes()
	case serviceitem.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serviceitem.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case serviceitem.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case serviceitem.FieldLabel:
		return m.OldLabel(ctx)
	case serviceitem.FieldEstimatedMinutes:
		return m.OldEstimatedMinutes(ctx)
	case serviceitem.FieldDefaultIntervalKm:
		return m.OldDefaultIntervalKm(ctx)
	case serviceitem.FieldDefaultIntervalMonths:
		return m.OldDefaultIntervalMonths(ctx)
	case serviceitem.FieldNotes:
		return m.OldNotes(ctx)
	case serviceitem.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serviceitem.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case serviceitem.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case serviceitem.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case serviceitem.FieldEstimatedMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedMinutes(v)
		return nil
	case serviceitem.FieldDefaultIntervalKm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultIntervalKm(v)
		return nil
	case serviceitem.FieldDefaultIntervalMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultIntervalMonths(v)
		return nil
	case serviceitem.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case serviceitem.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceItemMutation) AddedFields() []string {
	var fields []string
	if m.addestimated_minutes != nil {
		fields = append(fields, serviceitem.FieldEstimatedMinutes)
	}
	if m.adddefault_interval_km != nil {
		fields = append(fields, serviceitem.FieldDefaultIntervalKm)
	}
	if m.adddefault_interval_months != nil {
		fields = append(fields, serviceitem.FieldDefaultIntervalMonths)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case serviceitem.FieldEstimatedMinutes:
		return m.AddedEstimatedMinutes()
	case serviceitem.FieldDefaultIntervalKm:
		return m.AddedDefaultIntervalKm()
	case serviceitem.FieldDefaultIntervalMonths:
		return m.AddedDefaultIntervalMonths()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case serviceitem.FieldEstimatedMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedMinutes(v)
		return nil
	case serviceitem.FieldDefaultIntervalKm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultIntervalKm(v)
		return nil
	case serviceitem.FieldDefaultIntervalMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultIntervalMonths(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(serviceitem.FieldEstimatedMinutes) {
		fields = append(fields, serviceitem.FieldEstimatedMinutes)
	}
	if m.FieldCleared(serviceitem.FieldDefaultIntervalKm) {
		fields = append(fields, serviceitem.FieldDefaultIntervalKm)
	}
	if m.FieldCleared(serviceitem.FieldDefaultIntervalMonths) {
		fields = append(fields, serviceitem.FieldDefaultIntervalMonths)
	}
	if m.FieldCleared(serviceitem.FieldNotes) {
		fields = append(fields, serviceitem.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceItemMutation) ClearField(name string) error {
	switch name {
	case serviceitem.FieldEstimatedMinutes:
		m.ClearEstimatedMinutes()
		return nil
	case serviceitem.FieldDefaultIntervalKm:
		m.ClearDefaultIntervalKm()
		return nil
	case serviceitem.FieldDefaultIntervalMonths:
		m.ClearDefaultIntervalMonths()
		return nil
	case serviceitem.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown ServiceItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceItemMutation) ResetField(name string) error {
	switch name {
	case serviceitem.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case serviceitem.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case serviceitem.FieldLabel:
		m.ResetLabel()
		return nil
	case serviceitem.FieldEstimatedMinutes:
		m.ResetEstimatedMinutes()
		return nil
	case serviceitem.FieldDefaultIntervalKm:
		m.ResetDefaultIntervalKm()
		return nil
	case serviceitem.FieldDefaultIntervalMonths:
		m.ResetDefaultIntervalMonths()
		return nil
	case serviceitem.FieldNotes:
		m.ResetNotes()
		return nil
	case serviceitem.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown ServiceItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.car != nil {
		edges = append(edges, serviceitem.EdgeCar)
	}
	if m.schedules != nil {
		edges = append(edges, serviceitem.EdgeSchedules)
	}
	if m.logs != nil {
		edges = append(edges, serviceitem.EdgeLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serviceitem.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case serviceitem.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.schedules))
		for id := range m.schedules {
			ids = append(ids, id)
		}
		return ids
	case serviceitem.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedschedules != nil {
		edges = append(edges, serviceitem.EdgeSchedules)
	}
	if m.removedlogs != nil {
		edges = append(edges, serviceitem.EdgeLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case serviceitem.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.removedschedules))
		for id := range m.removedschedules {
			ids = append(ids, id)
		}
		return ids
	case serviceitem.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcar {
		edges = append(edges, serviceitem.EdgeCar)
	}
	if m.clearedschedules {
		edges = append(edges, serviceitem.EdgeSchedules)
	}
	if m.clearedlogs {
		edges = append(edges, serviceitem.EdgeLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceItemMutation) EdgeCleared(name string) bool {
	switch name {
	case serviceitem.EdgeCar:
		return m.clearedcar
	case serviceitem.EdgeSchedules:
		return m.clearedschedules
	case serviceitem.EdgeLogs:
		return m.clearedlogs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceItemMutation) ClearEdge(name string) error {
	switch name {
	case serviceitem.EdgeCar:
		m.ClearCar()
		return nil
	}
	return fmt.Errorf("unknown ServiceItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceItemMutation) ResetEdge(name string) error {
	switch name {
	case serviceitem.EdgeCar:
		m.ResetCar()
		return nil
	case serviceitem.EdgeSchedules:
		m.ResetSchedules()
		return nil
	case serviceitem.EdgeLogs:
		m.ResetLogs()
		return nil
	}
	return fmt.Errorf("unknown ServiceItem edge %s", name)
}

// ServiceLogMutation represents an operation that mutates the ServiceLog nodes in the graph.
type ServiceLogMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	create_time             *time.Time
	update_time             *time.Time
	date_performed          *time.Time
	performed_by            *string
	notes                   *string
	clearedFields           map[string]struct{}
	car                     *uuid.UUID
	clearedcar              bool
	items                   map[uuid.UUID]struct{}
	removeditems            map[uuid.UUID]struct{}
	cleareditems            bool
	schedule                *uuid.UUID
	clearedschedule         bool
	odometer_reading        *uuid.UUID
	clearedodometer_reading bool
	expense                 *uuid.UUID
	clearedexpense          bool
	documents               map[uuid.UUID]struct{}
	removeddocuments        map[uuid.UUID]struct{}
	cleareddocuments        bool
	done                    bool
	oldValue                func(context.Context) (*ServiceLog, error)
	predicates              []predicate.ServiceLog
}

var _ ent.Mutation = (*ServiceLogMutation)(nil)

// servicelogOption allows management of the mutation configuration using functional options.
type servicelogOption func(*ServiceLogMutation)

// newServiceLogMutation creates new mutation for the ServiceLog entity.
func newServiceLogMutation(c config, op Op, opts ...servicelogOption) *ServiceLogMutation {
	m := &ServiceLogMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceLogID sets the ID field of the mutation.
func withServiceLogID(id uuid.UUID) servicelogOption {
	return func(m *ServiceLogMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceLog
		)
		m.oldValue = func(ctx context.Context) (*ServiceLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceLog sets the old ServiceLog of the mutation.
func withServiceLog(node *ServiceLog) servicelogOption {
	return func(m *ServiceLogMutation) {
		m.oldValue = func(context.Context) (*ServiceLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceLog entities.
func (m *ServiceLogMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceLogMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceLogMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ServiceLogMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ServiceLogMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ServiceLog entity.
// If the ServiceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceLogMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ServiceLogMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ServiceLogMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ServiceLogMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ServiceLog entity.
// If the ServiceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceLogMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ServiceLogMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDatePerformed sets the "date_performed" field.
func (m *ServiceLogMutation) SetDatePerformed(t time.Time) {
	m.date_performed = &t
}

// DatePerformed returns the value of the "date_performed" field in the mutation.
func (m *ServiceLogMutation) DatePerformed() (r time.Time, exists bool) {
	v := m.date_performed
	if v == nil {
		return
	}
	return *v, true
}

// OldDatePerformed returns the old "date_performed" field's value of the ServiceLog entity.
// If the ServiceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceLogMutation) OldDatePerformed(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatePerformed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatePerformed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatePerformed: %w", err)
	}
	return oldValue.DatePerformed, nil
}

// ResetDatePerformed resets all changes to the "date_performed" field.
func (m *ServiceLogMutation) ResetDatePerformed() {
	m.date_performed = nil
}

// SetPerformedBy sets the "performed_by" field.
func (m *ServiceLogMutation) SetPerformedBy(s string) {
	m.performed_by = &s
}

// PerformedBy returns the value of the "performed_by" field in the mutation.
func (m *ServiceLogMutation) PerformedBy() (r string, exists bool) {
	v := m.performed_by
	if v == nil {
		return
	}
	return *v, true
}

// OldPerformedBy returns the old "performed_by" field's value of the ServiceLog entity.
// If the ServiceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceLogMutation) OldPerformedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerformedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerformedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerformedBy: %w", err)
	}
	return oldValue.PerformedBy, nil
}

// ClearPerformedBy clears the value of the "performed_by" field.
func (m *ServiceLogMutation) ClearPerformedBy() {
	m.performed_by = nil
	m.clearedFields[servicelog.FieldPerformedBy] = struct{}{}
}

// PerformedByCleared returns if the "performed_by" field was cleared in this mutation.
func (m *ServiceLogMutation) PerformedByCleared() bool {
	_, ok := m.clearedFields[servicelog.FieldPerformedBy]
	return ok
}

// ResetPerformedBy resets all changes to the "performed_by" field.
func (m *ServiceLogMutation) ResetPerformedBy() {
	m.performed_by = nil
	delete(m.clearedFields, servicelog.FieldPerformedBy)
}

// SetNotes sets the "notes" field.
func (m *ServiceLogMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *ServiceLogMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the ServiceLog entity.
// If the ServiceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceLogMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *ServiceLogMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[servicelog.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *ServiceLogMutation) NotesCleared() bool {
	_, ok := m.clearedFields[servicelog.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *ServiceLogMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, servicelog.FieldNotes)
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *ServiceLogMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *ServiceLogMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *ServiceLogMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *ServiceLogMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *ServiceLogMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *ServiceLogMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// AddItemIDs adds the "items" edge to the ServiceItem entity by ids.
func (m *ServiceLogMutation) AddItemIDs(ids ...uuid.UUID) {
	if m.items == nil {
		m.items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the ServiceItem entity.
func (m *ServiceLogMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the ServiceItem entity was cleared.
func (m *ServiceLogMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the ServiceItem entity by IDs.
func (m *ServiceLogMutation) RemoveItemIDs(ids ...uuid.UUID) {
	if m.removeditems == nil {
		m.removeditems = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the ServiceItem entity.
func (m *ServiceLogMutation) RemovedItemsIDs() (ids []uuid.UUID) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *ServiceLogMutation) ItemsIDs() (ids []uuid.UUID) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *ServiceLogMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// SetScheduleID sets the "schedule" edge to the ServiceSchedule entity by id.
func (m *ServiceLogMutation) SetScheduleID(id uuid.UUID) {
	m.schedule = &id
}

// ClearSchedule clears the "schedule" edge to the ServiceSchedule entity.
func (m *ServiceLogMutation) ClearSchedule() {
	m.clearedschedule = true
}

// ScheduleCleared reports if the "schedule" edge to the ServiceSchedule entity was cleared.
func (m *ServiceLogMutation) ScheduleCleared() bool {
	return m.clearedschedule
}

// ScheduleID returns the "schedule" edge ID in the mutation.
func (m *ServiceLogMutation) ScheduleID() (id uuid.UUID, exists bool) {
	if m.schedule != nil {
		return *m.schedule, true
	}
	return
}

// ScheduleIDs returns the "schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheduleID instead. It exists only for internal usage by the builders.
func (m *ServiceLogMutation) ScheduleIDs() (ids []uuid.UUID) {
	if id := m.schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchedule resets all changes to the "schedule" edge.
func (m *ServiceLogMutation) ResetSchedule() {
	m.schedule = nil
	m.clearedschedule = false
}

// SetOdometerReadingID sets the "odometer_reading" edge to the OdometerReading entity by id.
func (m *ServiceLogMutation) SetOdometerReadingID(id uuid.UUID) {
	m.odometer_reading = &id
}

// ClearOdometerReading clears the "odometer_reading" edge to the OdometerReading entity.
func (m *ServiceLogMutation) ClearOdometerReading() {
	m.clearedodometer_reading = true
}

// OdometerReadingCleared reports if the "odometer_reading" edge to the OdometerReading entity was cleared.
func (m *ServiceLogMutation) OdometerReadingCleared() bool {
	return m.clearedodometer_reading
}

// OdometerReadingID returns the "odometer_reading" edge ID in the mutation.
func (m *ServiceLogMutation) OdometerReadingID() (id uuid.UUID, exists bool) {
	if m.odometer_reading != nil {
		return *m.odometer_reading, true
	}
	return
}

// OdometerReadingIDs returns the "odometer_reading" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OdometerReadingID instead. It exists only for internal usage by the builders.
func (m *ServiceLogMutation) OdometerReadingIDs() (ids []uuid.UUID) {
	if id := m.odometer_reading; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOdometerReading resets all changes to the "odometer_reading" edge.
func (m *ServiceLogMutation) ResetOdometerReading() {
	m.odometer_reading = nil
	m.clearedodometer_reading = false
}

// SetExpenseID sets the "expense" edge to the Expense entity by id.
func (m *ServiceLogMutation) SetExpenseID(id uuid.UUID) {
	m.expense = &id
}

// ClearExpense clears the "expense" edge to the Expense entity.
func (m *ServiceLogMutation) ClearExpense() {
	m.clearedexpense = true
}

// ExpenseCleared reports if the "expense" edge to the Expense entity was cleared.
func (m *ServiceLogMutation) ExpenseCleared() bool {
	return m.clearedexpense
}

// ExpenseID returns the "expense" edge ID in the mutation.
func (m *ServiceLogMutation) ExpenseID() (id uuid.UUID, exists bool) {
	if m.expense != nil {
		return *m.expense, true
	}
	return
}

// ExpenseIDs returns the "expense" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExpenseID instead. It exists only for internal usage by the builders.
func (m *ServiceLogMutation) ExpenseIDs() (ids []uuid.UUID) {
	if id := m.expense; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExpense resets all changes to the "expense" edge.
func (m *ServiceLogMutation) ResetExpense() {
	m.expense = nil
	m.clearedexpense = false
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *ServiceLogMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *ServiceLogMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *ServiceLogMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *ServiceLogMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *ServiceLogMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *ServiceLogMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *ServiceLogMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// Where appends a list predicates to the ServiceLogMutation builder.
func (m *ServiceLogMutation) Where(ps ...predicate.ServiceLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceLog).
func (m *ServiceLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceLogMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, servicelog.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, servicelog.FieldUpdateTime)
	}
	if m.date_performed != nil {
		fields = append(fields, servicelog.FieldDatePerformed)
	}
	if m.performed_by != nil {
		fields = append(fields, servicelog.FieldPerformedBy)
	}
	if m.notes != nil {
		fields = append(fields, servicelog.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicelog.FieldCreateTime:
		return m.CreateTime()
	case servicelog.FieldUpdateTime:
		return m.UpdateTime()
	case servicelog.FieldDatePerformed:
		return m.DatePerformed()
	case servicelog.FieldPerformedBy:
		return m.PerformedBy()
	case servicelog.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicelog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case servicelog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case servicelog.FieldDatePerformed:
		return m.OldDatePerformed(ctx)
	case servicelog.FieldPerformedBy:
		return m.OldPerformedBy(ctx)
	case servicelog.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicelog.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case servicelog.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case servicelog.FieldDatePerformed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatePerformed(v)
		return nil
	case servicelog.FieldPerformedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerformedBy(v)
		return nil
	case servicelog.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servicelog.FieldPerformedBy) {
		fields = append(fields, servicelog.FieldPerformedBy)
	}
	if m.FieldCleared(servicelog.FieldNotes) {
		fields = append(fields, servicelog.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceLogMutation) ClearField(name string) error {
	switch name {
	case servicelog.FieldPerformedBy:
		m.ClearPerformedBy()
		return nil
	case servicelog.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown ServiceLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceLogMutation) ResetField(name string) error {
	switch name {
	case servicelog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case servicelog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case servicelog.FieldDatePerformed:
		m.ResetDatePerformed()
		return nil
	case servicelog.FieldPerformedBy:
		m.ResetPerformedBy()
		return nil
	case servicelog.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown ServiceLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.car != nil {
		edges = append(edges, servicelog.EdgeCar)
	}
	if m.items != nil {
		edges = append(edges, servicelog.EdgeItems)
	}
	if m.schedule != nil {
		edges = append(edges, servicelog.EdgeSchedule)
	}
	if m.odometer_reading != nil {
		edges = append(edges, servicelog.EdgeOdometerReading)
	}
	if m.expense != nil {
		edges = append(edges, servicelog.EdgeExpense)
	}
	if m.documents != nil {
		edges = append(edges, servicelog.EdgeDocuments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servicelog.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case servicelog.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case servicelog.EdgeSchedule:
		if id := m.schedule; id != nil {
			return []ent.Value{*id}
		}
	case servicelog.EdgeOdometerReading:
		if id := m.odometer_reading; id != nil {
			return []ent.Value{*id}
		}
	case servicelog.EdgeExpense:
		if id := m.expense; id != nil {
			return []ent.Value{*id}
		}
	case servicelog.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removeditems != nil {
		edges = append(edges, servicelog.EdgeItems)
	}
	if m.removeddocuments != nil {
		edges = append(edges, servicelog.EdgeDocuments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceLogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case servicelog.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	case servicelog.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcar {
		edges = append(edges, servicelog.EdgeCar)
	}
	if m.cleareditems {
		edges = append(edges, servicelog.EdgeItems)
	}
	if m.clearedschedule {
		edges = append(edges, servicelog.EdgeSchedule)
	}
	if m.clearedodometer_reading {
		edges = append(edges, servicelog.EdgeOdometerReading)
	}
	if m.clearedexpense {
		edges = append(edges, servicelog.EdgeExpense)
	}
	if m.cleareddocuments {
		edges = append(edges, servicelog.EdgeDocuments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceLogMutation) EdgeCleared(name string) bool {
	switch name {
	case servicelog.EdgeCar:
		return m.clearedcar
	case servicelog.EdgeItems:
		return m.cleareditems
	case servicelog.EdgeSchedule:
		return m.clearedschedule
	case servicelog.EdgeOdometerReading:
		return m.clearedodometer_reading
	case servicelog.EdgeExpense:
		return m.clearedexpense
	case servicelog.EdgeDocuments:
		return m.cleareddocuments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceLogMutation) ClearEdge(name string) error {
	switch name {
	case servicelog.EdgeCar:
		m.ClearCar()
		return nil
	case servicelog.EdgeSchedule:
		m.ClearSchedule()
		return nil
	case servicelog.EdgeOdometerReading:
		m.ClearOdometerReading()
		return nil
	case servicelog.EdgeExpense:
		m.ClearExpense()
		return nil
	}
	return fmt.Errorf("unknown ServiceLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceLogMutation) ResetEdge(name string) error {
	switch name {
	case servicelog.EdgeCar:
		m.ResetCar()
		return nil
	case servicelog.EdgeItems:
		m.ResetItems()
		return nil
	case servicelog.EdgeSchedule:
		m.ResetSchedule()
		return nil
	case servicelog.EdgeOdometerReading:
		m.ResetOdometerReading()
		return nil
	case servicelog.EdgeExpense:
		m.ResetExpense()
		return nil
	case servicelog.EdgeDocuments:
		m.ResetDocuments()
		return nil
	}
	return fmt.Errorf("unknown ServiceLog edge %s", name)
}

// ServiceScheduleMutation represents an operation that mutates the ServiceSchedule nodes in the graph.
type ServiceScheduleMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	create_time            *time.Time
	update_time            *time.Time
	title                  *string
	repeat_every_km        *float64
	addrepeat_every_km     *float64
	starts_at_km           *float64
	addstarts_at_km        *float64
	repeat_every_months    *int
	addrepeat_every_months *int
	starts_at_months       *int
	addstarts_at_months    *int
	notes                  *string
	archived               *bool
	clearedFields          map[string]struct{}
	car                    *uuid.UUID
	clearedcar             bool
	items                  map[uuid.UUID]struct{}
	removeditems           map[uuid.UUID]struct{}
	cleareditems           bool
	logs                   map[uuid.UUID]struct{}
	removedlogs            map[uuid.UUID]struct{}
	clearedlogs            bool
	done                   bool
	oldValue               func(context.Context) (*ServiceSchedule, error)
	predicates             []predicate.ServiceSchedule
}

var _ ent.Mutation = (*ServiceScheduleMutation)(nil)

// servicescheduleOption allows management of the mutation configuration using functional options.
type servicescheduleOption func(*ServiceScheduleMutation)

// newServiceScheduleMutation creates new mutation for the ServiceSchedule entity.
func newServiceScheduleMutation(c config, op Op, opts ...servicescheduleOption) *ServiceScheduleMutation {
	m := &ServiceScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceScheduleID sets the ID field of the mutation.
func withServiceScheduleID(id uuid.UUID) servicescheduleOption {
	return func(m *ServiceScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceSchedule
		)
		m.oldValue = func(ctx context.Context) (*ServiceSchedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceSchedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceSchedule sets the old ServiceSchedule of the mutation.
func withServiceSchedule(node *ServiceSchedule) servicescheduleOption {
	return func(m *ServiceScheduleMutation) {
		m.oldValue = func(context.Context) (*ServiceSchedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceSchedule entities.
func (m *ServiceScheduleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceScheduleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceScheduleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceSchedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ServiceScheduleMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ServiceScheduleMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ServiceSchedule entity.
// If the ServiceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceScheduleMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ServiceScheduleMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ServiceScheduleMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ServiceScheduleMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ServiceSchedule entity.
// If the ServiceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceScheduleMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ServiceScheduleMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTitle sets the "title" field.
func (m *ServiceScheduleMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ServiceScheduleMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ServiceSchedule entity.
// If the ServiceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceScheduleMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ServiceScheduleMutation) ResetTitle() {
	m.title = nil
}

// SetRepeatEveryKm sets the "repeat_every_km" field.
func (m *ServiceScheduleMutation) SetRepeatEveryKm(f float64) {
	m.repeat_every_km = &f
	m.addrepeat_every_km = nil
}

// RepeatEveryKm returns the value of the "repeat_every_km" field in the mutation.
func (m *ServiceScheduleMutation) RepeatEveryKm() (r float64, exists bool) {
	v := m.repeat_every_km
	if v == nil {
		return
	}
	return *v, true
}

// OldRepeatEveryKm returns the old "repeat_every_km" field's value of the ServiceSchedule entity.
// If the ServiceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceScheduleMutation) OldRepeatEveryKm(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepeatEveryKm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepeatEveryKm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepeatEveryKm: %w", err)
	}
	return oldValue.RepeatEveryKm, nil
}

// AddRepeatEveryKm adds f to the "repeat_every_km" field.
func (m *ServiceScheduleMutation) AddRepeatEveryKm(f float64) {
	if m.addrepeat_every_km != nil {
		*m.addrepeat_every_km += f
	} else {
		m.addrepeat_every_km = &f
	}
}

// AddedRepeatEveryKm returns the value that was added to the "repeat_every_km" field in this mutation.
func (m *ServiceScheduleMutation) AddedRepeatEveryKm() (r float64, exists bool) {
	v := m.addrepeat_every_km
	if v == nil {
		return
	}
	return *v, true
}

// ClearRepeatEveryKm clears the value of the "repeat_every_km" field.
func (m *ServiceScheduleMutation) ClearRepeatEveryKm() {
	m.repeat_every_km = nil
	m.addrepeat_every_km = nil
	m.clearedFields[serviceschedule.FieldRepeatEveryKm] = struct{}{}
}

// RepeatEveryKmCleared returns if the "repeat_every_km" field was cleared in this mutation.
func (m *ServiceScheduleMutation) RepeatEveryKmCleared() bool {
	_, ok := m.clearedFields[serviceschedule.FieldRepeatEveryKm]
	return ok
}

// ResetRepeatEveryKm resets all changes to the "repeat_every_km" field.
func (m *ServiceScheduleMutation) ResetRepeatEveryKm() {
	m.repeat_every_km = nil
	m.addrepeat_every_km = nil
	delete(m.clearedFields, serviceschedule.FieldRepeatEveryKm)
}

// SetStartsAtKm sets the "starts_at_km" field.
func (m *ServiceScheduleMutation) SetStartsAtKm(f float64) {
	m.starts_at_km = &f
	m.addstarts_at_km = nil
}

// StartsAtKm returns the value of the "starts_at_km" field in the mutation.
func (m *ServiceScheduleMutation) StartsAtKm() (r float64, exists bool) {
	v := m.starts_at_km
	if v == nil {
		return
	}
	return *v, true
}

// OldStartsAtKm returns the old "starts_at_km" field's value of the ServiceSchedule entity.
// If the ServiceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceScheduleMutation) OldStartsAtKm(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartsAtKm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartsAtKm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartsAtKm: %w", err)
	}
	return oldValue.StartsAtKm, nil
}

// AddStartsAtKm adds f to the "starts_at_km" field.
func (m *ServiceScheduleMutation) AddStartsAtKm(f float64) {
	if m.addstarts_at_km != nil {
		*m.addstarts_at_km += f
	} else {
		m.addstarts_at_km = &f
	}
}

// AddedStartsAtKm returns the value that was added to the "starts_at_km" field in this mutation.
func (m *ServiceScheduleMutation) AddedStartsAtKm() (r float64, exists bool) {
	v := m.addstarts_at_km
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartsAtKm clears the value of the "starts_at_km" field.
func (m *ServiceScheduleMutation) ClearStartsAtKm() {
	m.starts_at_km = nil
	m.addstarts_at_km = nil
	m.clearedFields[serviceschedule.FieldStartsAtKm] = struct{}{}
}

// StartsAtKmCleared returns if the "starts_at_km" field was cleared in this mutation.
func (m *ServiceScheduleMutation) StartsAtKmCleared() bool {
	_, ok := m.clearedFields[serviceschedule.FieldStartsAtKm]
	return ok
}

// ResetStartsAtKm resets all changes to the "starts_at_km" field.
func (m *ServiceScheduleMutation) ResetStartsAtKm() {
	m.starts_at_km = nil
	m.addstarts_at_km = nil
	delete(m.clearedFields, serviceschedule.FieldStartsAtKm)
}

// SetRepeatEveryMonths sets the "repeat_every_months" field.
func (m *ServiceScheduleMutation) SetRepeatEveryMonths(i int) {
	m.repeat_every_months = &i
	m.addrepeat_every_months = nil
}

// RepeatEveryMonths returns the value of the "repeat_every_months" field in the mutation.
func (m *ServiceScheduleMutation) RepeatEveryMonths() (r int, exists bool) {
	v := m.repeat_every_months
	if v == nil {
		return
	}
	return *v, true
}

// OldRepeatEveryMonths returns the old "repeat_every_months" field's value of the ServiceSchedule entity.
// If the ServiceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceScheduleMutation) OldRepeatEveryMonths(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepeatEveryMonths is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepeatEveryMonths requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepeatEveryMonths: %w", err)
	}
	return oldValue.RepeatEveryMonths, nil
}

// AddRepeatEveryMonths adds i to the "repeat_every_months" field.
func (m *ServiceScheduleMutation) AddRepeatEveryMonths(i int) {
	if m.addrepeat_every_months != nil {
		*m.addrepeat_every_months += i
	} else {
		m.addrepeat_every_months = &i
	}
}

// AddedRepeatEveryMonths returns the value that was added to the "repeat_every_months" field in this mutation.
func (m *ServiceScheduleMutation) AddedRepeatEveryMonths() (r int, exists bool) {
	v := m.addrepeat_every_months
	if v == nil {
		return
	}
	return *v, true
}

// ClearRepeatEveryMonths clears the value of the "repeat_every_months" field.
func (m *ServiceScheduleMutation) ClearRepeatEveryMonths() {
	m.repeat_every_months = nil
	m.addrepeat_every_months = nil
	m.clearedFields[serviceschedule.FieldRepeatEveryMonths] = struct{}{}
}

// RepeatEveryMonthsCleared returns if the "repeat_every_months" field was cleared in this mutation.
func (m *ServiceScheduleMutation) RepeatEveryMonthsCleared() bool {
	_, ok := m.clearedFields[serviceschedule.FieldRepeatEveryMonths]
	return ok
}

// ResetRepeatEveryMonths resets all changes to the "repeat_every_months" field.
func (m *ServiceScheduleMutation) ResetRepeatEveryMonths() {
	m.repeat_every_months = nil
	m.addrepeat_every_months = nil
	delete(m.clearedFields, serviceschedule.FieldRepeatEveryMonths)
}

// SetStartsAtMonths sets the "starts_at_months" field.
func (m *ServiceScheduleMutation) SetStartsAtMonths(i int) {
	m.starts_at_months = &i
	m.addstarts_at_months = nil
}

// StartsAtMonths returns the value of the "starts_at_months" field in the mutation.
func (m *ServiceScheduleMutation) StartsAtMonths() (r int, exists bool) {
	v := m.starts_at_months
	if v == nil {
		return
	}
	return *v, true
}

// OldStartsAtMonths returns the old "starts_at_months" field's value of the ServiceSchedule entity.
// If the ServiceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceScheduleMutation) OldStartsAtMonths(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartsAtMonths is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartsAtMonths requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartsAtMonths: %w", err)
	}
	return oldValue.StartsAtMonths, nil
}

// AddStartsAtMonths adds i to the "starts_at_months" field.
func (m *ServiceScheduleMutation) AddStartsAtMonths(i int) {
	if m.addstarts_at_months != nil {
		*m.addstarts_at_months += i
	} else {
		m.addstarts_at_months = &i
	}
}

// AddedStartsAtMonths returns the value that was added to the "starts_at_months" field in this mutation.
func (m *ServiceScheduleMutation) AddedStartsAtMonths() (r int, exists bool) {
	v := m.addstarts_at_months
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartsAtMonths clears the value of the "starts_at_months" field.
func (m *ServiceScheduleMutation) ClearStartsAtMonths() {
	m.starts_at_months = nil
	m.addstarts_at_months = nil
	m.clearedFields[serviceschedule.FieldStartsAtMonths] = struct{}{}
}

// StartsAtMonthsCleared returns if the "starts_at_months" field was cleared in this mutation.
func (m *ServiceScheduleMutation) StartsAtMonthsCleared() bool {
	_, ok := m.clearedFields[serviceschedule.FieldStartsAtMonths]
	return ok
}

// ResetStartsAtMonths resets all changes to the "starts_at_months" field.
func (m *ServiceScheduleMutation) ResetStartsAtMonths() {
	m.starts_at_months = nil
	m.addstarts_at_months = nil
	delete(m.clearedFields, serviceschedule.FieldStartsAtMonths)
}

// SetNotes sets the "notes" field.
func (m *ServiceScheduleMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *ServiceScheduleMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the ServiceSchedule entity.
// If the ServiceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceScheduleMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *ServiceScheduleMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[serviceschedule.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *ServiceScheduleMutation) NotesCleared() bool {
	_, ok := m.clearedFields[serviceschedule.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *ServiceScheduleMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, serviceschedule.FieldNotes)
}

// SetArchived sets the "archived" field.
func (m *ServiceScheduleMutation) SetArchived(b bool) {
	m.archived = &b
}

// Archived returns the value of the "archived" field in the mutation.
func (m *ServiceScheduleMutation) Archived() (r bool, exists bool) {
	v := m.archived
	if v == nil {
		return
	}
	return *v, true
}

// OldArchived returns the old "archived" field's value of the ServiceSchedule entity.
// If the ServiceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceScheduleMutation) OldArchived(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchived is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchived requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchived: %w", err)
	}
	return oldValue.Archived, nil
}

// ResetArchived resets all changes to the "archived" field.
func (m *ServiceScheduleMutation) ResetArchived() {
	m.archived = nil
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *ServiceScheduleMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *ServiceScheduleMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *ServiceScheduleMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *ServiceScheduleMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *ServiceScheduleMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *ServiceScheduleMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// AddItemIDs adds the "items" edge to the ServiceItem entity by ids.
func (m *ServiceScheduleMutation) AddItemIDs(ids ...uuid.UUID) {
	if m.items == nil {
		m.items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the ServiceItem entity.
func (m *ServiceScheduleMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the ServiceItem entity was cleared.
func (m *ServiceScheduleMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the ServiceItem entity by IDs.
func (m *ServiceScheduleMutation) RemoveItemIDs(ids ...uuid.UUID) {
	if m.removeditems == nil {
		m.removeditems = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the ServiceItem entity.
func (m *ServiceScheduleMutation) RemovedItemsIDs() (ids []uuid.UUID) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *ServiceScheduleMutation) ItemsIDs() (ids []uuid.UUID) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *ServiceScheduleMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// AddLogIDs adds the "logs" edge to the ServiceLog entity by ids.
func (m *ServiceScheduleMutation) AddLogIDs(ids ...uuid.UUID) {
	if m.logs == nil {
		m.logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the ServiceLog entity.
func (m *ServiceScheduleMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the ServiceLog entity was cleared.
func (m *ServiceScheduleMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the ServiceLog entity by IDs.
func (m *ServiceScheduleMutation) RemoveLogIDs(ids ...uuid.UUID) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the ServiceLog entity.
func (m *ServiceScheduleMutation) RemovedLogsIDs() (ids []uuid.UUID) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *ServiceScheduleMutation) LogsIDs() (ids []uuid.UUID) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *ServiceScheduleMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// Where appends a list predicates to the ServiceScheduleMutation builder.
func (m *ServiceScheduleMutation) Where(ps ...predicate.ServiceSchedule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceScheduleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceScheduleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceSchedule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceScheduleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceScheduleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceSchedule).
func (m *ServiceScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceScheduleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, serviceschedule.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, serviceschedule.FieldUpdateTime)
	}
	if m.title != nil {
		fields = append(fields, serviceschedule.FieldTitle)
	}
	if m.repeat_every_km != nil {
		fields = append(fields, serviceschedule.FieldRepeatEveryKm)
	}
	if m.starts_at_km != nil {
		fields = append(fields, serviceschedule.FieldStartsAtKm)
	}
	if m.repeat_every_months != nil {
		fields = append(fields, serviceschedule.FieldRepeatEveryMonths)
	}
	if m.starts_at_months != nil {
		fields = append(fields, serviceschedule.FieldStartsAtMonths)
	}
	if m.notes != nil {
		fields = append(fields, serviceschedule.FieldNotes)
	}
	if m.archived != nil {
		fields = append(fields, serviceschedule.FieldArchived)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serviceschedule.FieldCreateTime:
		return m.CreateTime()
	case serviceschedule.FieldUpdateTime:
		return m.UpdateTime()
	case serviceschedule.FieldTitle:
		return m.Title()
	case serviceschedule.FieldRepeatEveryKm:
		return m.RepeatEveryKm()
	case serviceschedule.FieldStartsAtKm:
		return m.StartsAtKm()
	case serviceschedule.FieldRepeatEveryMonths:
		return m.RepeatEveryMonths()
	case serviceschedule.FieldStartsAtMonths:
		return m.StartsAtMonths()
	case serviceschedule.FieldNotes:
		return m.Notes()
	case serviceschedule.FieldArchived:
		return m.Archived()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serviceschedule.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case serviceschedule.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case serviceschedule.FieldTitle:
		return m.OldTitle(ctx)
	case serviceschedule.FieldRepeatEveryKm:
		return m.OldRepeatEveryKm(ctx)
	case serviceschedule.FieldStartsAtKm:
		return m.OldStartsAtKm(ctx)
	case serviceschedule.FieldRepeatEveryMonths:
		return m.OldRepeatEveryMonths(ctx)
	case serviceschedule.FieldStartsAtMonths:
		return m.OldStartsAtMonths(ctx)
	case serviceschedule.FieldNotes:
		return m.OldNotes(ctx)
	case serviceschedule.FieldArchived:
		return m.OldArchived(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceSchedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serviceschedule.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case serviceschedule.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case serviceschedule.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case serviceschedule.FieldRepeatEveryKm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepeatEveryKm(v)
		return nil
	case serviceschedule.FieldStartsAtKm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartsAtKm(v)
		return nil
	case serviceschedule.FieldRepeatEveryMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepeatEveryMonths(v)
		return nil
	case serviceschedule.FieldStartsAtMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartsAtMonths(v)
		return nil
	case serviceschedule.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case serviceschedule.FieldArchived:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchived(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceSchedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceScheduleMutation) AddedFields() []string {
	var fields []string
	if m.addrepeat_every_km != nil {
		fields = append(fields, serviceschedule.FieldRepeatEveryKm)
	}
	if m.addstarts_at_km != nil {
		fields = append(fields, serviceschedule.FieldStartsAtKm)
	}
	if m.addrepeat_every_months != nil {
		fields = append(fields, serviceschedule.FieldRepeatEveryMonths)
	}
	if m.addstarts_at_months != nil {
		fields = append(fields, serviceschedule.FieldStartsAtMonths)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceScheduleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case serviceschedule.FieldRepeatEveryKm:
		return m.AddedRepeatEveryKm()
	case serviceschedule.FieldStartsAtKm:
		return m.AddedStartsAtKm()
	case serviceschedule.FieldRepeatEveryMonths:
		return m.AddedRepeatEveryMonths()
	case serviceschedule.FieldStartsAtMonths:
		return m.AddedStartsAtMonths()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case serviceschedule.FieldRepeatEveryKm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRepeatEveryKm(v)
		return nil
	case serviceschedule.FieldStartsAtKm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartsAtKm(v)
		return nil
	case serviceschedule.FieldRepeatEveryMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRepeatEveryMonths(v)
		return nil
	case serviceschedule.FieldStartsAtMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartsAtMonths(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceSchedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceScheduleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(serviceschedule.FieldRepeatEveryKm) {
		fields = append(fields, serviceschedule.FieldRepeatEveryKm)
	}
	if m.FieldCleared(serviceschedule.FieldStartsAtKm) {
		fields = append(fields, serviceschedule.FieldStartsAtKm)
	}
	if m.FieldCleared(serviceschedule.FieldRepeatEveryMonths) {
		fields = append(fields, serviceschedule.FieldRepeatEveryMonths)
	}
	if m.FieldCleared(serviceschedule.FieldStartsAtMonths) {
		fields = append(fields, serviceschedule.FieldStartsAtMonths)
	}
	if m.FieldCleared(serviceschedule.FieldNotes) {
		fields = append(fields, serviceschedule.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceScheduleMutation) ClearField(name string) error {
	switch name {
	case serviceschedule.FieldRepeatEveryKm:
		m.ClearRepeatEveryKm()
		return nil
	case serviceschedule.FieldStartsAtKm:
		m.ClearStartsAtKm()
		return nil
	case serviceschedule.FieldRepeatEveryMonths:
		m.ClearRepeatEveryMonths()
		return nil
	case serviceschedule.FieldStartsAtMonths:
		m.ClearStartsAtMonths()
		return nil
	case serviceschedule.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown ServiceSchedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceScheduleMutation) ResetField(name string) error {
	switch name {
	case serviceschedule.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case serviceschedule.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case serviceschedule.FieldTitle:
		m.ResetTitle()
		return nil
	case serviceschedule.FieldRepeatEveryKm:
		m.ResetRepeatEveryKm()
		return nil
	case serviceschedule.FieldStartsAtKm:
		m.ResetStartsAtKm()
		return nil
	case serviceschedule.FieldRepeatEveryMonths:
		m.ResetRepeatEveryMonths()
		return nil
	case serviceschedule.FieldStartsAtMonths:
		m.ResetStartsAtMonths()
		return nil
	case serviceschedule.FieldNotes:
		m.ResetNotes()
		return nil
	case serviceschedule.FieldArchived:
		m.ResetArchived()
		return nil
	}
	return fmt.Errorf("unknown ServiceSchedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.car != nil {
		edges = append(edges, serviceschedule.EdgeCar)
	}
	if m.items != nil {
		edges = append(edges, serviceschedule.EdgeItems)
	}
	if m.logs != nil {
		edges = append(edges, serviceschedule.EdgeLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serviceschedule.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case serviceschedule.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case serviceschedule.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeditems != nil {
		edges = append(edges, serviceschedule.EdgeItems)
	}
	if m.removedlogs != nil {
		edges = append(edges, serviceschedule.EdgeLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceScheduleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case serviceschedule.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	case serviceschedule.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcar {
		edges = append(edges, serviceschedule.EdgeCar)
	}
	if m.cleareditems {
		edges = append(edges, serviceschedule.EdgeItems)
	}
	if m.clearedlogs {
		edges = append(edges, serviceschedule.EdgeLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case serviceschedule.EdgeCar:
		return m.clearedcar
	case serviceschedule.EdgeItems:
		return m.cleareditems
	case serviceschedule.EdgeLogs:
		return m.clearedlogs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceScheduleMutation) ClearEdge(name string) error {
	switch name {
	case serviceschedule.EdgeCar:
		m.ClearCar()
		return nil
	}
	return fmt.Errorf("unknown ServiceSchedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceScheduleMutation) ResetEdge(name string) error {
	switch name {
	case serviceschedule.EdgeCar:
		m.ResetCar()
		return nil
	case serviceschedule.EdgeItems:
		m.ResetItems()
		return nil
	case serviceschedule.EdgeLogs:
		m.ResetLogs()
		return nil
	}
	return fmt.Errorf("unknown ServiceSchedule edge %s", name)
}

// SubscriptionMutation represents an operation that mutates the Subscription nodes in the graph.
type SubscriptionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	create_time             *time.Time
	update_time             *time.Time
	stripe_subscription_id  *string
	tier                    *subscription.Tier
	status                  *subscription.Status
	canceled_at             *time.Time
	cancel_at_period_end    *bool
	trial_end               *time.Time
	affiliate_6mo_code      *string
	affiliate_12mo_code     *string
	clearedFields           map[string]struct{}
	user                    *uuid.UUID
	cleareduser             bool
	checkout_session        *uuid.UUID
	clearedcheckout_session bool
	done                    bool
	oldValue                func(context.Context) (*Subscription, error)
	predicates              []predicate.Subscription
}

var _ ent.Mutation = (*SubscriptionMutation)(nil)

// subscriptionOption allows management of the mutation configuration using functional options.
type subscriptionOption func(*SubscriptionMutation)

// newSubscriptionMutation creates new mutation for the Subscription entity.
func newSubscriptionMutation(c config, op Op, opts ...subscriptionOption) *SubscriptionMutation {
	m := &SubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionID sets the ID field of the mutation.
func withSubscriptionID(id uuid.UUID) subscriptionOption {
	return func(m *SubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Subscription
		)
		m.oldValue = func(ctx context.Context) (*Subscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscription sets the old Subscription of the mutation.
func withSubscription(node *Subscription) subscriptionOption {
	return func(m *SubscriptionMutation) {
		m.oldValue = func(context.Context) (*Subscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subscription entities.
func (m *SubscriptionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscriptionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SubscriptionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SubscriptionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SubscriptionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SubscriptionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SubscriptionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SubscriptionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStripeSubscriptionID sets the "stripe_subscription_id" field.
func (m *SubscriptionMutation) SetStripeSubscriptionID(s string) {
	m.stripe_subscription_id = &s
}

// StripeSubscriptionID returns the value of the "stripe_subscription_id" field in the mutation.
func (m *SubscriptionMutation) StripeSubscriptionID() (r string, exists bool) {
	v := m.stripe_subscription_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeSubscriptionID returns the old "stripe_subscription_id" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldStripeSubscriptionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeSubscriptionID: %w", err)
	}
	return oldValue.StripeSubscriptionID, nil
}

// ClearStripeSubscriptionID clears the value of the "stripe_subscription_id" field.
func (m *SubscriptionMutation) ClearStripeSubscriptionID() {
	m.stripe_subscription_id = nil
	m.clearedFields[subscription.FieldStripeSubscriptionID] = struct{}{}
}

// StripeSubscriptionIDCleared returns if the "stripe_subscription_id" field was cleared in this mutation.
func (m *SubscriptionMutation) StripeSubscriptionIDCleared() bool {
	_, ok := m.clearedFields[subscription.FieldStripeSubscriptionID]
	return ok
}

// ResetStripeSubscriptionID resets all changes to the "stripe_subscription_id" field.
func (m *SubscriptionMutation) ResetStripeSubscriptionID() {
	m.stripe_subscription_id = nil
	delete(m.clearedFields, subscription.FieldStripeSubscriptionID)
}

// SetTier sets the "tier" field.
func (m *SubscriptionMutation) SetTier(s subscription.Tier) {
	m.tier = &s
}

// Tier returns the value of the "tier" field in the mutation.
func (m *SubscriptionMutation) Tier() (r subscription.Tier, exists bool) {
	v := m.tier
	if v == nil {
		return
	}
	return *v, true
}

// OldTier returns the old "tier" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldTier(ctx context.Context) (v subscription.Tier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTier: %w", err)
	}
	return oldValue.Tier, nil
}

// ResetTier resets all changes to the "tier" field.
func (m *SubscriptionMutation) ResetTier() {
	m.tier = nil
}

// SetStatus sets the "status" field.
func (m *SubscriptionMutation) SetStatus(s subscription.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SubscriptionMutation) Status() (r subscription.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldStatus(ctx context.Context) (v subscription.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SubscriptionMutation) ResetStatus() {
	m.status = nil
}

// SetCanceledAt sets the "canceled_at" field.
func (m *SubscriptionMutation) SetCanceledAt(t time.Time) {
	m.canceled_at = &t
}

// CanceledAt returns the value of the "canceled_at" field in the mutation.
func (m *SubscriptionMutation) CanceledAt() (r time.Time, exists bool) {
	v := m.canceled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCanceledAt returns the old "canceled_at" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCanceledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanceledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanceledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanceledAt: %w", err)
	}
	return oldValue.CanceledAt, nil
}

// ClearCanceledAt clears the value of the "canceled_at" field.
func (m *SubscriptionMutation) ClearCanceledAt() {
	m.canceled_at = nil
	m.clearedFields[subscription.FieldCanceledAt] = struct{}{}
}

// CanceledAtCleared returns if the "canceled_at" field was cleared in this mutation.
func (m *SubscriptionMutation) CanceledAtCleared() bool {
	_, ok := m.clearedFields[subscription.FieldCanceledAt]
	return ok
}

// ResetCanceledAt resets all changes to the "canceled_at" field.
func (m *SubscriptionMutation) ResetCanceledAt() {
	m.canceled_at = nil
	delete(m.clearedFields, subscription.FieldCanceledAt)
}

// SetCancelAtPeriodEnd sets the "cancel_at_period_end" field.
func (m *SubscriptionMutation) SetCancelAtPeriodEnd(b bool) {
	m.cancel_at_period_end = &b
}

// CancelAtPeriodEnd returns the value of the "cancel_at_period_end" field in the mutation.
func (m *SubscriptionMutation) CancelAtPeriodEnd() (r bool, exists bool) {
	v := m.cancel_at_period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelAtPeriodEnd returns the old "cancel_at_period_end" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldCancelAtPeriodEnd(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelAtPeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelAtPeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelAtPeriodEnd: %w", err)
	}
	return oldValue.CancelAtPeriodEnd, nil
}

// ResetCancelAtPeriodEnd resets all changes to the "cancel_at_period_end" field.
func (m *SubscriptionMutation) ResetCancelAtPeriodEnd() {
	m.cancel_at_period_end = nil
}

// SetTrialEnd sets the "trial_end" field.
func (m *SubscriptionMutation) SetTrialEnd(t time.Time) {
	m.trial_end = &t
}

// TrialEnd returns the value of the "trial_end" field in the mutation.
func (m *SubscriptionMutation) TrialEnd() (r time.Time, exists bool) {
	v := m.trial_end
	if v == nil {
		return
	}
	return *v, true
}

// OldTrialEnd returns the old "trial_end" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldTrialEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrialEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrialEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrialEnd: %w", err)
	}
	return oldValue.TrialEnd, nil
}

// ClearTrialEnd clears the value of the "trial_end" field.
func (m *SubscriptionMutation) ClearTrialEnd() {
	m.trial_end = nil
	m.clearedFields[subscription.FieldTrialEnd] = struct{}{}
}

// TrialEndCleared returns if the "trial_end" field was cleared in this mutation.
func (m *SubscriptionMutation) TrialEndCleared() bool {
	_, ok := m.clearedFields[subscription.FieldTrialEnd]
	return ok
}

// ResetTrialEnd resets all changes to the "trial_end" field.
func (m *SubscriptionMutation) ResetTrialEnd() {
	m.trial_end = nil
	delete(m.clearedFields, subscription.FieldTrialEnd)
}

// SetAffiliate6moCode sets the "affiliate_6mo_code" field.
func (m *SubscriptionMutation) SetAffiliate6moCode(s string) {
	m.affiliate_6mo_code = &s
}

// Affiliate6moCode returns the value of the "affiliate_6mo_code" field in the mutation.
func (m *SubscriptionMutation) Affiliate6moCode() (r string, exists bool) {
	v := m.affiliate_6mo_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAffiliate6moCode returns the old "affiliate_6mo_code" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldAffiliate6moCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAffiliate6moCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAffiliate6moCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAffiliate6moCode: %w", err)
	}
	return oldValue.Affiliate6moCode, nil
}

// ClearAffiliate6moCode clears the value of the "affiliate_6mo_code" field.
func (m *SubscriptionMutation) ClearAffiliate6moCode() {
	m.affiliate_6mo_code = nil
	m.clearedFields[subscription.FieldAffiliate6moCode] = struct{}{}
}

// Affiliate6moCodeCleared returns if the "affiliate_6mo_code" field was cleared in this mutation.
func (m *SubscriptionMutation) Affiliate6moCodeCleared() bool {
	_, ok := m.clearedFields[subscription.FieldAffiliate6moCode]
	return ok
}

// ResetAffiliate6moCode resets all changes to the "affiliate_6mo_code" field.
func (m *SubscriptionMutation) ResetAffiliate6moCode() {
	m.affiliate_6mo_code = nil
	delete(m.clearedFields, subscription.FieldAffiliate6moCode)
}

// SetAffiliate12moCode sets the "affiliate_12mo_code" field.
func (m *SubscriptionMutation) SetAffiliate12moCode(s string) {
	m.affiliate_12mo_code = &s
}

// Affiliate12moCode returns the value of the "affiliate_12mo_code" field in the mutation.
func (m *SubscriptionMutation) Affiliate12moCode() (r string, exists bool) {
	v := m.affiliate_12mo_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAffiliate12moCode returns the old "affiliate_12mo_code" field's value of the Subscription entity.
// If the Subscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionMutation) OldAffiliate12moCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAffiliate12moCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAffiliate12moCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAffiliate12moCode: %w", err)
	}
	return oldValue.Affiliate12moCode, nil
}

// ClearAffiliate12moCode clears the value of the "affiliate_12mo_code" field.
func (m *SubscriptionMutation) ClearAffiliate12moCode() {
	m.affiliate_12mo_code = nil
	m.clearedFields[subscription.FieldAffiliate12moCode] = struct{}{}
}

// Affiliate12moCodeCleared returns if the "affiliate_12mo_code" field was cleared in this mutation.
func (m *SubscriptionMutation) Affiliate12moCodeCleared() bool {
	_, ok := m.clearedFields[subscription.FieldAffiliate12moCode]
	return ok
}

// ResetAffiliate12moCode resets all changes to the "affiliate_12mo_code" field.
func (m *SubscriptionMutation) ResetAffiliate12moCode() {
	m.affiliate_12mo_code = nil
	delete(m.clearedFields, subscription.FieldAffiliate12moCode)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *SubscriptionMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *SubscriptionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *SubscriptionMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SubscriptionMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetCheckoutSessionID sets the "checkout_session" edge to the CheckoutSession entity by id.
func (m *SubscriptionMutation) SetCheckoutSessionID(id uuid.UUID) {
	m.checkout_session = &id
}

// ClearCheckoutSession clears the "checkout_session" edge to the CheckoutSession entity.
func (m *SubscriptionMutation) ClearCheckoutSession() {
	m.clearedcheckout_session = true
}

// CheckoutSessionCleared reports if the "checkout_session" edge to the CheckoutSession entity was cleared.
func (m *SubscriptionMutation) CheckoutSessionCleared() bool {
	return m.clearedcheckout_session
}

// CheckoutSessionID returns the "checkout_session" edge ID in the mutation.
func (m *SubscriptionMutation) CheckoutSessionID() (id uuid.UUID, exists bool) {
	if m.checkout_session != nil {
		return *m.checkout_session, true
	}
	return
}

// CheckoutSessionIDs returns the "checkout_session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CheckoutSessionID instead. It exists only for internal usage by the builders.
func (m *SubscriptionMutation) CheckoutSessionIDs() (ids []uuid.UUID) {
	if id := m.checkout_session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCheckoutSession resets all changes to the "checkout_session" edge.
func (m *SubscriptionMutation) ResetCheckoutSession() {
	m.checkout_session = nil
	m.clearedcheckout_session = false
}

// Where appends a list predicates to the SubscriptionMutation builder.
func (m *SubscriptionMutation) Where(ps ...predicate.Subscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subscription).
func (m *SubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, subscription.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, subscription.FieldUpdateTime)
	}
	if m.stripe_subscription_id != nil {
		fields = append(fields, subscription.FieldStripeSubscriptionID)
	}
	if m.tier != nil {
		fields = append(fields, subscription.FieldTier)
	}
	if m.status != nil {
		fields = append(fields, subscription.FieldStatus)
	}
	if m.canceled_at != nil {
		fields = append(fields, subscription.FieldCanceledAt)
	}
	if m.cancel_at_period_end != nil {
		fields = append(fields, subscription.FieldCancelAtPeriodEnd)
	}
	if m.trial_end != nil {
		fields = append(fields, subscription.FieldTrialEnd)
	}
	if m.affiliate_6mo_code != nil {
		fields = append(fields, subscription.FieldAffiliate6moCode)
	}
	if m.affiliate_12mo_code != nil {
		fields = append(fields, subscription.FieldAffiliate12moCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscription.FieldCreateTime:
		return m.CreateTime()
	case subscription.FieldUpdateTime:
		return m.UpdateTime()
	case subscription.FieldStripeSubscriptionID:
		return m.StripeSubscriptionID()
	case subscription.FieldTier:
		return m.Tier()
	case subscription.FieldStatus:
		return m.Status()
	case subscription.FieldCanceledAt:
		return m.CanceledAt()
	case subscription.FieldCancelAtPeriodEnd:
		return m.CancelAtPeriodEnd()
	case subscription.FieldTrialEnd:
		return m.TrialEnd()
	case subscription.FieldAffiliate6moCode:
		return m.Affiliate6moCode()
	case subscription.FieldAffiliate12moCode:
		return m.Affiliate12moCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscription.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case subscription.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case subscription.FieldStripeSubscriptionID:
		return m.OldStripeSubscriptionID(ctx)
	case subscription.FieldTier:
		return m.OldTier(ctx)
	case subscription.FieldStatus:
		return m.OldStatus(ctx)
	case subscription.FieldCanceledAt:
		return m.OldCanceledAt(ctx)
	case subscription.FieldCancelAtPeriodEnd:
		return m.OldCancelAtPeriodEnd(ctx)
	case subscription.FieldTrialEnd:
		return m.OldTrialEnd(ctx)
	case subscription.FieldAffiliate6moCode:
		return m.OldAffiliate6moCode(ctx)
	case subscription.FieldAffiliate12moCode:
		return m.OldAffiliate12moCode(ctx)
	}
	return nil, fmt.Errorf("unknown Subscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscription.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case subscription.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case subscription.FieldStripeSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeSubscriptionID(v)
		return nil
	case subscription.FieldTier:
		v, ok := value.(subscription.Tier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTier(v)
		return nil
	case subscription.FieldStatus:
		v, ok := value.(subscription.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case subscription.FieldCanceledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanceledAt(v)
		return nil
	case subscription.FieldCancelAtPeriodEnd:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelAtPeriodEnd(v)
		return nil
	case subscription.FieldTrialEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrialEnd(v)
		return nil
	case subscription.FieldAffiliate6moCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAffiliate6moCode(v)
		return nil
	case subscription.FieldAffiliate12moCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAffiliate12moCode(v)
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscription.FieldStripeSubscriptionID) {
		fields = append(fields, subscription.FieldStripeSubscriptionID)
	}
	if m.FieldCleared(subscription.FieldCanceledAt) {
		fields = append(fields, subscription.FieldCanceledAt)
	}
	if m.FieldCleared(subscription.FieldTrialEnd) {
		fields = append(fields, subscription.FieldTrialEnd)
	}
	if m.FieldCleared(subscription.FieldAffiliate6moCode) {
		fields = append(fields, subscription.FieldAffiliate6moCode)
	}
	if m.FieldCleared(subscription.FieldAffiliate12moCode) {
		fields = append(fields, subscription.FieldAffiliate12moCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionMutation) ClearField(name string) error {
	switch name {
	case subscription.FieldStripeSubscriptionID:
		m.ClearStripeSubscriptionID()
		return nil
	case subscription.FieldCanceledAt:
		m.ClearCanceledAt()
		return nil
	case subscription.FieldTrialEnd:
		m.ClearTrialEnd()
		return nil
	case subscription.FieldAffiliate6moCode:
		m.ClearAffiliate6moCode()
		return nil
	case subscription.FieldAffiliate12moCode:
		m.ClearAffiliate12moCode()
		return nil
	}
	return fmt.Errorf("unknown Subscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionMutation) ResetField(name string) error {
	switch name {
	case subscription.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case subscription.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case subscription.FieldStripeSubscriptionID:
		m.ResetStripeSubscriptionID()
		return nil
	case subscription.FieldTier:
		m.ResetTier()
		return nil
	case subscription.FieldStatus:
		m.ResetStatus()
		return nil
	case subscription.FieldCanceledAt:
		m.ResetCanceledAt()
		return nil
	case subscription.FieldCancelAtPeriodEnd:
		m.ResetCancelAtPeriodEnd()
		return nil
	case subscription.FieldTrialEnd:
		m.ResetTrialEnd()
		return nil
	case subscription.FieldAffiliate6moCode:
		m.ResetAffiliate6moCode()
		return nil
	case subscription.FieldAffiliate12moCode:
		m.ResetAffiliate12moCode()
		return nil
	}
	return fmt.Errorf("unknown Subscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, subscription.EdgeUser)
	}
	if m.checkout_session != nil {
		edges = append(edges, subscription.EdgeCheckoutSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscription.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case subscription.EdgeCheckoutSession:
		if id := m.checkout_session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, subscription.EdgeUser)
	}
	if m.clearedcheckout_session {
		edges = append(edges, subscription.EdgeCheckoutSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case subscription.EdgeUser:
		return m.cleareduser
	case subscription.EdgeCheckoutSession:
		return m.clearedcheckout_session
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case subscription.EdgeUser:
		m.ClearUser()
		return nil
	case subscription.EdgeCheckoutSession:
		m.ClearCheckoutSession()
		return nil
	}
	return fmt.Errorf("unknown Subscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case subscription.EdgeUser:
		m.ResetUser()
		return nil
	case subscription.EdgeCheckoutSession:
		m.ResetCheckoutSession()
		return nil
	}
	return fmt.Errorf("unknown Subscription edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	create_time      *time.Time
	update_time      *time.Time
	status           *task.Status
	title            *string
	description      *string
	rank             *float64
	addrank          *float64
	estimate         *float64
	addestimate      *float64
	priority         *task.Priority
	effort           *task.Effort
	difficulty       *task.Difficulty
	category         *task.Category
	budget           *float64
	addbudget        *float64
	parts_needed     *string
	clearedFields    map[string]struct{}
	car              *uuid.UUID
	clearedcar       bool
	parent           *uuid.UUID
	clearedparent    bool
	subtasks         map[uuid.UUID]struct{}
	removedsubtasks  map[uuid.UUID]struct{}
	clearedsubtasks  bool
	mod_ideas        map[uuid.UUID]struct{}
	removedmod_ideas map[uuid.UUID]struct{}
	clearedmod_ideas bool
	done             bool
	oldValue         func(context.Context) (*Task, error)
	predicates       []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id uuid.UUID) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TaskMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TaskMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TaskMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TaskMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TaskMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TaskMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *TaskMutation) SetStatus(t task.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskMutation) Status() (r task.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStatus(ctx context.Context) (v task.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskMutation) ResetStatus() {
	m.status = nil
}

// SetTitle sets the "title" field.
func (m *TaskMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TaskMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TaskMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *TaskMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TaskMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TaskMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[task.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TaskMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[task.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TaskMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, task.FieldDescription)
}

// SetRank sets the "rank" field.
func (m *TaskMutation) SetRank(f float64) {
	m.rank = &f
	m.addrank = nil
}

// Rank returns the value of the "rank" field in the mutation.
func (m *TaskMutation) Rank() (r float64, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRank(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds f to the "rank" field.
func (m *TaskMutation) AddRank(f float64) {
	if m.addrank != nil {
		*m.addrank += f
	} else {
		m.addrank = &f
	}
}

// AddedRank returns the value that was added to the "rank" field in this mutation.
func (m *TaskMutation) AddedRank() (r float64, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ResetRank resets all changes to the "rank" field.
func (m *TaskMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
}

// SetEstimate sets the "estimate" field.
func (m *TaskMutation) SetEstimate(f float64) {
	m.estimate = &f
	m.addestimate = nil
}

// Estimate returns the value of the "estimate" field in the mutation.
func (m *TaskMutation) Estimate() (r float64, exists bool) {
	v := m.estimate
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimate returns the old "estimate" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldEstimate(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimate: %w", err)
	}
	return oldValue.Estimate, nil
}

// AddEstimate adds f to the "estimate" field.
func (m *TaskMutation) AddEstimate(f float64) {
	if m.addestimate != nil {
		*m.addestimate += f
	} else {
		m.addestimate = &f
	}
}

// AddedEstimate returns the value that was added to the "estimate" field in this mutation.
func (m *TaskMutation) AddedEstimate() (r float64, exists bool) {
	v := m.addestimate
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimate clears the value of the "estimate" field.
func (m *TaskMutation) ClearEstimate() {
	m.estimate = nil
	m.addestimate = nil
	m.clearedFields[task.FieldEstimate] = struct{}{}
}

// EstimateCleared returns if the "estimate" field was cleared in this mutation.
func (m *TaskMutation) EstimateCleared() bool {
	_, ok := m.clearedFields[task.FieldEstimate]
	return ok
}

// ResetEstimate resets all changes to the "estimate" field.
func (m *TaskMutation) ResetEstimate() {
	m.estimate = nil
	m.addestimate = nil
	delete(m.clearedFields, task.FieldEstimate)
}

// SetPriority sets the "priority" field.
func (m *TaskMutation) SetPriority(t task.Priority) {
	m.priority = &t
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TaskMutation) Priority() (r task.Priority, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPriority(ctx context.Context) (v *task.Priority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ClearPriority clears the value of the "priority" field.
func (m *TaskMutation) ClearPriority() {
	m.priority = nil
	m.clearedFields[task.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *TaskMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[task.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *TaskMutation) ResetPriority() {
	m.priority = nil
	delete(m.clearedFields, task.FieldPriority)
}

// SetEffort sets the "effort" field.
func (m *TaskMutation) SetEffort(t task.Effort) {
	m.effort = &t
}

// Effort returns the value of the "effort" field in the mutation.
func (m *TaskMutation) Effort() (r task.Effort, exists bool) {
	v := m.effort
	if v == nil {
		return
	}
	return *v, true
}

// OldEffort returns the old "effort" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldEffort(ctx context.Context) (v *task.Effort, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffort: %w", err)
	}
	return oldValue.Effort, nil
}

// ClearEffort clears the value of the "effort" field.
func (m *TaskMutation) ClearEffort() {
	m.effort = nil
	m.clearedFields[task.FieldEffort] = struct{}{}
}

// EffortCleared returns if the "effort" field was cleared in this mutation.
func (m *TaskMutation) EffortCleared() bool {
	_, ok := m.clearedFields[task.FieldEffort]
	return ok
}

// ResetEffort resets all changes to the "effort" field.
func (m *TaskMutation) ResetEffort() {
	m.effort = nil
	delete(m.clearedFields, task.FieldEffort)
}

// SetDifficulty sets the "difficulty" field.
func (m *TaskMutation) SetDifficulty(t task.Difficulty) {
	m.difficulty = &t
}

// Difficulty returns the value of the "difficulty" field in the mutation.
func (m *TaskMutation) Difficulty() (r task.Difficulty, exists bool) {
	v := m.difficulty
	if v == nil {
		return
	}
	return *v, true
}

// OldDifficulty returns the old "difficulty" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDifficulty(ctx context.Context) (v *task.Difficulty, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDifficulty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDifficulty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDifficulty: %w", err)
	}
	return oldValue.Difficulty, nil
}

// ClearDifficulty clears the value of the "difficulty" field.
func (m *TaskMutation) ClearDifficulty() {
	m.difficulty = nil
	m.clearedFields[task.FieldDifficulty] = struct{}{}
}

// DifficultyCleared returns if the "difficulty" field was cleared in this mutation.
func (m *TaskMutation) DifficultyCleared() bool {
	_, ok := m.clearedFields[task.FieldDifficulty]
	return ok
}

// ResetDifficulty resets all changes to the "difficulty" field.
func (m *TaskMutation) ResetDifficulty() {
	m.difficulty = nil
	delete(m.clearedFields, task.FieldDifficulty)
}

// SetCategory sets the "category" field.
func (m *TaskMutation) SetCategory(t task.Category) {
	m.category = &t
}

// Category returns the value of the "category" field in the mutation.
func (m *TaskMutation) Category() (r task.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCategory(ctx context.Context) (v *task.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *TaskMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[task.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *TaskMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[task.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *TaskMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, task.FieldCategory)
}

// SetBudget sets the "budget" field.
func (m *TaskMutation) SetBudget(f float64) {
	m.budget = &f
	m.addbudget = nil
}

// Budget returns the value of the "budget" field in the mutation.
func (m *TaskMutation) Budget() (r float64, exists bool) {
	v := m.budget
	if v == nil {
		return
	}
	return *v, true
}

// OldBudget returns the old "budget" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldBudget(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBudget is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBudget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBudget: %w", err)
	}
	return oldValue.Budget, nil
}

// AddBudget adds f to the "budget" field.
func (m *TaskMutation) AddBudget(f float64) {
	if m.addbudget != nil {
		*m.addbudget += f
	} else {
		m.addbudget = &f
	}
}

// AddedBudget returns the value that was added to the "budget" field in this mutation.
func (m *TaskMutation) AddedBudget() (r float64, exists bool) {
	v := m.addbudget
	if v == nil {
		return
	}
	return *v, true
}

// ClearBudget clears the value of the "budget" field.
func (m *TaskMutation) ClearBudget() {
	m.budget = nil
	m.addbudget = nil
	m.clearedFields[task.FieldBudget] = struct{}{}
}

// BudgetCleared returns if the "budget" field was cleared in this mutation.
func (m *TaskMutation) BudgetCleared() bool {
	_, ok := m.clearedFields[task.FieldBudget]
	return ok
}

// ResetBudget resets all changes to the "budget" field.
func (m *TaskMutation) ResetBudget() {
	m.budget = nil
	m.addbudget = nil
	delete(m.clearedFields, task.FieldBudget)
}

// SetPartsNeeded sets the "parts_needed" field.
func (m *TaskMutation) SetPartsNeeded(s string) {
	m.parts_needed = &s
}

// PartsNeeded returns the value of the "parts_needed" field in the mutation.
func (m *TaskMutation) PartsNeeded() (r string, exists bool) {
	v := m.parts_needed
	if v == nil {
		return
	}
	return *v, true
}

// OldPartsNeeded returns the old "parts_needed" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPartsNeeded(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPartsNeeded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPartsNeeded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPartsNeeded: %w", err)
	}
	return oldValue.PartsNeeded, nil
}

// ClearPartsNeeded clears the value of the "parts_needed" field.
func (m *TaskMutation) ClearPartsNeeded() {
	m.parts_needed = nil
	m.clearedFields[task.FieldPartsNeeded] = struct{}{}
}

// PartsNeededCleared returns if the "parts_needed" field was cleared in this mutation.
func (m *TaskMutation) PartsNeededCleared() bool {
	_, ok := m.clearedFields[task.FieldPartsNeeded]
	return ok
}

// ResetPartsNeeded resets all changes to the "parts_needed" field.
func (m *TaskMutation) ResetPartsNeeded() {
	m.parts_needed = nil
	delete(m.clearedFields, task.FieldPartsNeeded)
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *TaskMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *TaskMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *TaskMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *TaskMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *TaskMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// SetParentID sets the "parent" edge to the Task entity by id.
func (m *TaskMutation) SetParentID(id uuid.UUID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Task entity.
func (m *TaskMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Task entity was cleared.
func (m *TaskMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *TaskMutation) ParentID() (id uuid.UUID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *TaskMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddSubtaskIDs adds the "subtasks" edge to the Task entity by ids.
func (m *TaskMutation) AddSubtaskIDs(ids ...uuid.UUID) {
	if m.subtasks == nil {
		m.subtasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.subtasks[ids[i]] = struct{}{}
	}
}

// ClearSubtasks clears the "subtasks" edge to the Task entity.
func (m *TaskMutation) ClearSubtasks() {
	m.clearedsubtasks = true
}

// SubtasksCleared reports if the "subtasks" edge to the Task entity was cleared.
func (m *TaskMutation) SubtasksCleared() bool {
	return m.clearedsubtasks
}

// RemoveSubtaskIDs removes the "subtasks" edge to the Task entity by IDs.
func (m *TaskMutation) RemoveSubtaskIDs(ids ...uuid.UUID) {
	if m.removedsubtasks == nil {
		m.removedsubtasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.subtasks, ids[i])
		m.removedsubtasks[ids[i]] = struct{}{}
	}
}

// RemovedSubtasks returns the removed IDs of the "subtasks" edge to the Task entity.
func (m *TaskMutation) RemovedSubtasksIDs() (ids []uuid.UUID) {
	for id := range m.removedsubtasks {
		ids = append(ids, id)
	}
	return
}

// SubtasksIDs returns the "subtasks" edge IDs in the mutation.
func (m *TaskMutation) SubtasksIDs() (ids []uuid.UUID) {
	for id := range m.subtasks {
		ids = append(ids, id)
	}
	return
}

// ResetSubtasks resets all changes to the "subtasks" edge.
func (m *TaskMutation) ResetSubtasks() {
	m.subtasks = nil
	m.clearedsubtasks = false
	m.removedsubtasks = nil
}

// AddModIdeaIDs adds the "mod_ideas" edge to the ModIdea entity by ids.
func (m *TaskMutation) AddModIdeaIDs(ids ...uuid.UUID) {
	if m.mod_ideas == nil {
		m.mod_ideas = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.mod_ideas[ids[i]] = struct{}{}
	}
}

// ClearModIdeas clears the "mod_ideas" edge to the ModIdea entity.
func (m *TaskMutation) ClearModIdeas() {
	m.clearedmod_ideas = true
}

// ModIdeasCleared reports if the "mod_ideas" edge to the ModIdea entity was cleared.
func (m *TaskMutation) ModIdeasCleared() bool {
	return m.clearedmod_ideas
}

// RemoveModIdeaIDs removes the "mod_ideas" edge to the ModIdea entity by IDs.
func (m *TaskMutation) RemoveModIdeaIDs(ids ...uuid.UUID) {
	if m.removedmod_ideas == nil {
		m.removedmod_ideas = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.mod_ideas, ids[i])
		m.removedmod_ideas[ids[i]] = struct{}{}
	}
}

// RemovedModIdeas returns the removed IDs of the "mod_ideas" edge to the ModIdea entity.
func (m *TaskMutation) RemovedModIdeasIDs() (ids []uuid.UUID) {
	for id := range m.removedmod_ideas {
		ids = append(ids, id)
	}
	return
}

// ModIdeasIDs returns the "mod_ideas" edge IDs in the mutation.
func (m *TaskMutation) ModIdeasIDs() (ids []uuid.UUID) {
	for id := range m.mod_ideas {
		ids = append(ids, id)
	}
	return
}

// ResetModIdeas resets all changes to the "mod_ideas" edge.
func (m *TaskMutation) ResetModIdeas() {
	m.mod_ideas = nil
	m.clearedmod_ideas = false
	m.removedmod_ideas = nil
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.create_time != nil {
		fields = append(fields, task.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, task.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, task.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, task.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, task.FieldDescription)
	}
	if m.rank != nil {
		fields = append(fields, task.FieldRank)
	}
	if m.estimate != nil {
		fields = append(fields, task.FieldEstimate)
	}
	if m.priority != nil {
		fields = append(fields, task.FieldPriority)
	}
	if m.effort != nil {
		fields = append(fields, task.FieldEffort)
	}
	if m.difficulty != nil {
		fields = append(fields, task.FieldDifficulty)
	}
	if m.category != nil {
		fields = append(fields, task.FieldCategory)
	}
	if m.budget != nil {
		fields = append(fields, task.FieldBudget)
	}
	if m.parts_needed != nil {
		fields = append(fields, task.FieldPartsNeeded)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldCreateTime:
		return m.CreateTime()
	case task.FieldUpdateTime:
		return m.UpdateTime()
	case task.FieldStatus:
		return m.Status()
	case task.FieldTitle:
		return m.Title()
	case task.FieldDescription:
		return m.Description()
	case task.FieldRank:
		return m.Rank()
	case task.FieldEstimate:
		return m.Estimate()
	case task.FieldPriority:
		return m.Priority()
	case task.FieldEffort:
		return m.Effort()
	case task.FieldDifficulty:
		return m.Difficulty()
	case task.FieldCategory:
		return m.Category()
	case task.FieldBudget:
		return m.Budget()
	case task.FieldPartsNeeded:
		return m.PartsNeeded()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case task.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case task.FieldStatus:
		return m.OldStatus(ctx)
	case task.FieldTitle:
		return m.OldTitle(ctx)
	case task.FieldDescription:
		return m.OldDescription(ctx)
	case task.FieldRank:
		return m.OldRank(ctx)
	case task.FieldEstimate:
		return m.OldEstimate(ctx)
	case task.FieldPriority:
		return m.OldPriority(ctx)
	case task.FieldEffort:
		return m.OldEffort(ctx)
	case task.FieldDifficulty:
		return m.OldDifficulty(ctx)
	case task.FieldCategory:
		return m.OldCategory(ctx)
	case task.FieldBudget:
		return m.OldBudget(ctx)
	case task.FieldPartsNeeded:
		return m.OldPartsNeeded(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case task.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case task.FieldStatus:
		v, ok := value.(task.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case task.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case task.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case task.FieldRank:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case task.FieldEstimate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimate(v)
		return nil
	case task.FieldPriority:
		v, ok := value.(task.Priority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case task.FieldEffort:
		v, ok := value.(task.Effort)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffort(v)
		return nil
	case task.FieldDifficulty:
		v, ok := value.(task.Difficulty)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDifficulty(v)
		return nil
	case task.FieldCategory:
		v, ok := value.(task.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case task.FieldBudget:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBudget(v)
		return nil
	case task.FieldPartsNeeded:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPartsNeeded(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	if m.addrank != nil {
		fields = append(fields, task.FieldRank)
	}
	if m.addestimate != nil {
		fields = append(fields, task.FieldEstimate)
	}
	if m.addbudget != nil {
		fields = append(fields, task.FieldBudget)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case task.FieldRank:
		return m.AddedRank()
	case task.FieldEstimate:
		return m.AddedEstimate()
	case task.FieldBudget:
		return m.AddedBudget()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case task.FieldRank:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	case task.FieldEstimate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimate(v)
		return nil
	case task.FieldBudget:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBudget(v)
		return nil
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldDescription) {
		fields = append(fields, task.FieldDescription)
	}
	if m.FieldCleared(task.FieldEstimate) {
		fields = append(fields, task.FieldEstimate)
	}
	if m.FieldCleared(task.FieldPriority) {
		fields = append(fields, task.FieldPriority)
	}
	if m.FieldCleared(task.FieldEffort) {
		fields = append(fields, task.FieldEffort)
	}
	if m.FieldCleared(task.FieldDifficulty) {
		fields = append(fields, task.FieldDifficulty)
	}
	if m.FieldCleared(task.FieldCategory) {
		fields = append(fields, task.FieldCategory)
	}
	if m.FieldCleared(task.FieldBudget) {
		fields = append(fields, task.FieldBudget)
	}
	if m.FieldCleared(task.FieldPartsNeeded) {
		fields = append(fields, task.FieldPartsNeeded)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldDescription:
		m.ClearDescription()
		return nil
	case task.FieldEstimate:
		m.ClearEstimate()
		return nil
	case task.FieldPriority:
		m.ClearPriority()
		return nil
	case task.FieldEffort:
		m.ClearEffort()
		return nil
	case task.FieldDifficulty:
		m.ClearDifficulty()
		return nil
	case task.FieldCategory:
		m.ClearCategory()
		return nil
	case task.FieldBudget:
		m.ClearBudget()
		return nil
	case task.FieldPartsNeeded:
		m.ClearPartsNeeded()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case task.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case task.FieldStatus:
		m.ResetStatus()
		return nil
	case task.FieldTitle:
		m.ResetTitle()
		return nil
	case task.FieldDescription:
		m.ResetDescription()
		return nil
	case task.FieldRank:
		m.ResetRank()
		return nil
	case task.FieldEstimate:
		m.ResetEstimate()
		return nil
	case task.FieldPriority:
		m.ResetPriority()
		return nil
	case task.FieldEffort:
		m.ResetEffort()
		return nil
	case task.FieldDifficulty:
		m.ResetDifficulty()
		return nil
	case task.FieldCategory:
		m.ResetCategory()
		return nil
	case task.FieldBudget:
		m.ResetBudget()
		return nil
	case task.FieldPartsNeeded:
		m.ResetPartsNeeded()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.car != nil {
		edges = append(edges, task.EdgeCar)
	}
	if m.parent != nil {
		edges = append(edges, task.EdgeParent)
	}
	if m.subtasks != nil {
		edges = append(edges, task.EdgeSubtasks)
	}
	if m.mod_ideas != nil {
		edges = append(edges, task.EdgeModIdeas)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeSubtasks:
		ids := make([]ent.Value, 0, len(m.subtasks))
		for id := range m.subtasks {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeModIdeas:
		ids := make([]ent.Value, 0, len(m.mod_ideas))
		for id := range m.mod_ideas {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedsubtasks != nil {
		edges = append(edges, task.EdgeSubtasks)
	}
	if m.removedmod_ideas != nil {
		edges = append(edges, task.EdgeModIdeas)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeSubtasks:
		ids := make([]ent.Value, 0, len(m.removedsubtasks))
		for id := range m.removedsubtasks {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeModIdeas:
		ids := make([]ent.Value, 0, len(m.removedmod_ideas))
		for id := range m.removedmod_ideas {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcar {
		edges = append(edges, task.EdgeCar)
	}
	if m.clearedparent {
		edges = append(edges, task.EdgeParent)
	}
	if m.clearedsubtasks {
		edges = append(edges, task.EdgeSubtasks)
	}
	if m.clearedmod_ideas {
		edges = append(edges, task.EdgeModIdeas)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeCar:
		return m.clearedcar
	case task.EdgeParent:
		return m.clearedparent
	case task.EdgeSubtasks:
		return m.clearedsubtasks
	case task.EdgeModIdeas:
		return m.clearedmod_ideas
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeCar:
		m.ClearCar()
		return nil
	case task.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeCar:
		m.ResetCar()
		return nil
	case task.EdgeParent:
		m.ResetParent()
		return nil
	case task.EdgeSubtasks:
		m.ResetSubtasks()
		return nil
	case task.EdgeModIdeas:
		m.ResetModIdeas()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	create_time                 *time.Time
	update_time                 *time.Time
	email                       *string
	stripe_customer_id          *string
	stripe_account_id           *string
	stripe_account_capabilities *map[string]string
	affiliate_6mo_code          *string
	affiliate_12mo_code         *string
	clearedFields               map[string]struct{}
	cars                        map[uuid.UUID]struct{}
	removedcars                 map[uuid.UUID]struct{}
	clearedcars                 bool
	profile                     *uuid.UUID
	clearedprofile              bool
	settings                    *uuid.UUID
	clearedsettings             bool
	subscriptions               map[uuid.UUID]struct{}
	removedsubscriptions        map[uuid.UUID]struct{}
	clearedsubscriptions        bool
	checkout_sessions           map[uuid.UUID]struct{}
	removedcheckout_sessions    map[uuid.UUID]struct{}
	clearedcheckout_sessions    bool
	done                        bool
	oldValue                    func(context.Context) (*User, error)
	predicates                  []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetStripeCustomerID sets the "stripe_customer_id" field.
func (m *UserMutation) SetStripeCustomerID(s string) {
	m.stripe_customer_id = &s
}

// StripeCustomerID returns the value of the "stripe_customer_id" field in the mutation.
func (m *UserMutation) StripeCustomerID() (r string, exists bool) {
	v := m.stripe_customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeCustomerID returns the old "stripe_customer_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStripeCustomerID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeCustomerID: %w", err)
	}
	return oldValue.StripeCustomerID, nil
}

// ClearStripeCustomerID clears the value of the "stripe_customer_id" field.
func (m *UserMutation) ClearStripeCustomerID() {
	m.stripe_customer_id = nil
	m.clearedFields[user.FieldStripeCustomerID] = struct{}{}
}

// StripeCustomerIDCleared returns if the "stripe_customer_id" field was cleared in this mutation.
func (m *UserMutation) StripeCustomerIDCleared() bool {
	_, ok := m.clearedFields[user.FieldStripeCustomerID]
	return ok
}

// ResetStripeCustomerID resets all changes to the "stripe_customer_id" field.
func (m *UserMutation) ResetStripeCustomerID() {
	m.stripe_customer_id = nil
	delete(m.clearedFields, user.FieldStripeCustomerID)
}

// SetStripeAccountID sets the "stripe_account_id" field.
func (m *UserMutation) SetStripeAccountID(s string) {
	m.stripe_account_id = &s
}

// StripeAccountID returns the value of the "stripe_account_id" field in the mutation.
func (m *UserMutation) StripeAccountID() (r string, exists bool) {
	v := m.stripe_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeAccountID returns the old "stripe_account_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStripeAccountID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeAccountID: %w", err)
	}
	return oldValue.StripeAccountID, nil
}

// ClearStripeAccountID clears the value of the "stripe_account_id" field.
func (m *UserMutation) ClearStripeAccountID() {
	m.stripe_account_id = nil
	m.clearedFields[user.FieldStripeAccountID] = struct{}{}
}

// StripeAccountIDCleared returns if the "stripe_account_id" field was cleared in this mutation.
func (m *UserMutation) StripeAccountIDCleared() bool {
	_, ok := m.clearedFields[user.FieldStripeAccountID]
	return ok
}

// ResetStripeAccountID resets all changes to the "stripe_account_id" field.
func (m *UserMutation) ResetStripeAccountID() {
	m.stripe_account_id = nil
	delete(m.clearedFields, user.FieldStripeAccountID)
}

// SetStripeAccountCapabilities sets the "stripe_account_capabilities" field.
func (m *UserMutation) SetStripeAccountCapabilities(value map[string]string) {
	m.stripe_account_capabilities = &value
}

// StripeAccountCapabilities returns the value of the "stripe_account_capabilities" field in the mutation.
func (m *UserMutation) StripeAccountCapabilities() (r map[string]string, exists bool) {
	v := m.stripe_account_capabilities
	if v == nil {
		return
	}
	return *v, true
}

// OldStripeAccountCapabilities returns the old "stripe_account_capabilities" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStripeAccountCapabilities(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStripeAccountCapabilities is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStripeAccountCapabilities requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStripeAccountCapabilities: %w", err)
	}
	return oldValue.StripeAccountCapabilities, nil
}

// ClearStripeAccountCapabilities clears the value of the "stripe_account_capabilities" field.
func (m *UserMutation) ClearStripeAccountCapabilities() {
	m.stripe_account_capabilities = nil
	m.clearedFields[user.FieldStripeAccountCapabilities] = struct{}{}
}

// StripeAccountCapabilitiesCleared returns if the "stripe_account_capabilities" field was cleared in this mutation.
func (m *UserMutation) StripeAccountCapabilitiesCleared() bool {
	_, ok := m.clearedFields[user.FieldStripeAccountCapabilities]
	return ok
}

// ResetStripeAccountCapabilities resets all changes to the "stripe_account_capabilities" field.
func (m *UserMutation) ResetStripeAccountCapabilities() {
	m.stripe_account_capabilities = nil
	delete(m.clearedFields, user.FieldStripeAccountCapabilities)
}

// SetAffiliate6moCode sets the "affiliate_6mo_code" field.
func (m *UserMutation) SetAffiliate6moCode(s string) {
	m.affiliate_6mo_code = &s
}

// Affiliate6moCode returns the value of the "affiliate_6mo_code" field in the mutation.
func (m *UserMutation) Affiliate6moCode() (r string, exists bool) {
	v := m.affiliate_6mo_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAffiliate6moCode returns the old "affiliate_6mo_code" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAffiliate6moCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAffiliate6moCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAffiliate6moCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAffiliate6moCode: %w", err)
	}
	return oldValue.Affiliate6moCode, nil
}

// ClearAffiliate6moCode clears the value of the "affiliate_6mo_code" field.
func (m *UserMutation) ClearAffiliate6moCode() {
	m.affiliate_6mo_code = nil
	m.clearedFields[user.FieldAffiliate6moCode] = struct{}{}
}

// Affiliate6moCodeCleared returns if the "affiliate_6mo_code" field was cleared in this mutation.
func (m *UserMutation) Affiliate6moCodeCleared() bool {
	_, ok := m.clearedFields[user.FieldAffiliate6moCode]
	return ok
}

// ResetAffiliate6moCode resets all changes to the "affiliate_6mo_code" field.
func (m *UserMutation) ResetAffiliate6moCode() {
	m.affiliate_6mo_code = nil
	delete(m.clearedFields, user.FieldAffiliate6moCode)
}

// SetAffiliate12moCode sets the "affiliate_12mo_code" field.
func (m *UserMutation) SetAffiliate12moCode(s string) {
	m.affiliate_12mo_code = &s
}

// Affiliate12moCode returns the value of the "affiliate_12mo_code" field in the mutation.
func (m *UserMutation) Affiliate12moCode() (r string, exists bool) {
	v := m.affiliate_12mo_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAffiliate12moCode returns the old "affiliate_12mo_code" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAffiliate12moCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAffiliate12moCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAffiliate12moCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAffiliate12moCode: %w", err)
	}
	return oldValue.Affiliate12moCode, nil
}

// ClearAffiliate12moCode clears the value of the "affiliate_12mo_code" field.
func (m *UserMutation) ClearAffiliate12moCode() {
	m.affiliate_12mo_code = nil
	m.clearedFields[user.FieldAffiliate12moCode] = struct{}{}
}

// Affiliate12moCodeCleared returns if the "affiliate_12mo_code" field was cleared in this mutation.
func (m *UserMutation) Affiliate12moCodeCleared() bool {
	_, ok := m.clearedFields[user.FieldAffiliate12moCode]
	return ok
}

// ResetAffiliate12moCode resets all changes to the "affiliate_12mo_code" field.
func (m *UserMutation) ResetAffiliate12moCode() {
	m.affiliate_12mo_code = nil
	delete(m.clearedFields, user.FieldAffiliate12moCode)
}

// AddCarIDs adds the "cars" edge to the Car entity by ids.
func (m *UserMutation) AddCarIDs(ids ...uuid.UUID) {
	if m.cars == nil {
		m.cars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.cars[ids[i]] = struct{}{}
	}
}

// ClearCars clears the "cars" edge to the Car entity.
func (m *UserMutation) ClearCars() {
	m.clearedcars = true
}

// CarsCleared reports if the "cars" edge to the Car entity was cleared.
func (m *UserMutation) CarsCleared() bool {
	return m.clearedcars
}

// RemoveCarIDs removes the "cars" edge to the Car entity by IDs.
func (m *UserMutation) RemoveCarIDs(ids ...uuid.UUID) {
	if m.removedcars == nil {
		m.removedcars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.cars, ids[i])
		m.removedcars[ids[i]] = struct{}{}
	}
}

// RemovedCars returns the removed IDs of the "cars" edge to the Car entity.
func (m *UserMutation) RemovedCarsIDs() (ids []uuid.UUID) {
	for id := range m.removedcars {
		ids = append(ids, id)
	}
	return
}

// CarsIDs returns the "cars" edge IDs in the mutation.
func (m *UserMutation) CarsIDs() (ids []uuid.UUID) {
	for id := range m.cars {
		ids = append(ids, id)
	}
	return
}

// ResetCars resets all changes to the "cars" edge.
func (m *UserMutation) ResetCars() {
	m.cars = nil
	m.clearedcars = false
	m.removedcars = nil
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *UserMutation) SetProfileID(id uuid.UUID) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *UserMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *UserMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *UserMutation) ProfileID() (id uuid.UUID, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ProfileIDs() (ids []uuid.UUID) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *UserMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// SetSettingsID sets the "settings" edge to the UserSettings entity by id.
func (m *UserMutation) SetSettingsID(id uuid.UUID) {
	m.settings = &id
}

// ClearSettings clears the "settings" edge to the UserSettings entity.
func (m *UserMutation) ClearSettings() {
	m.clearedsettings = true
}

// SettingsCleared reports if the "settings" edge to the UserSettings entity was cleared.
func (m *UserMutation) SettingsCleared() bool {
	return m.clearedsettings
}

// SettingsID returns the "settings" edge ID in the mutation.
func (m *UserMutation) SettingsID() (id uuid.UUID, exists bool) {
	if m.settings != nil {
		return *m.settings, true
	}
	return
}

// SettingsIDs returns the "settings" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SettingsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) SettingsIDs() (ids []uuid.UUID) {
	if id := m.settings; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSettings resets all changes to the "settings" edge.
func (m *UserMutation) ResetSettings() {
	m.settings = nil
	m.clearedsettings = false
}

// AddSubscriptionIDs adds the "subscriptions" edge to the Subscription entity by ids.
func (m *UserMutation) AddSubscriptionIDs(ids ...uuid.UUID) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the Subscription entity.
func (m *UserMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the Subscription entity was cleared.
func (m *UserMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the Subscription entity by IDs.
func (m *UserMutation) RemoveSubscriptionIDs(ids ...uuid.UUID) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the Subscription entity.
func (m *UserMutation) RemovedSubscriptionsIDs() (ids []uuid.UUID) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *UserMutation) SubscriptionsIDs() (ids []uuid.UUID) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *UserMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// AddCheckoutSessionIDs adds the "checkout_sessions" edge to the CheckoutSession entity by ids.
func (m *UserMutation) AddCheckoutSessionIDs(ids ...uuid.UUID) {
	if m.checkout_sessions == nil {
		m.checkout_sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.checkout_sessions[ids[i]] = struct{}{}
	}
}

// ClearCheckoutSessions clears the "checkout_sessions" edge to the CheckoutSession entity.
func (m *UserMutation) ClearCheckoutSessions() {
	m.clearedcheckout_sessions = true
}

// CheckoutSessionsCleared reports if the "checkout_sessions" edge to the CheckoutSession entity was cleared.
func (m *UserMutation) CheckoutSessionsCleared() bool {
	return m.clearedcheckout_sessions
}

// RemoveCheckoutSessionIDs removes the "checkout_sessions" edge to the CheckoutSession entity by IDs.
func (m *UserMutation) RemoveCheckoutSessionIDs(ids ...uuid.UUID) {
	if m.removedcheckout_sessions == nil {
		m.removedcheckout_sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.checkout_sessions, ids[i])
		m.removedcheckout_sessions[ids[i]] = struct{}{}
	}
}

// RemovedCheckoutSessions returns the removed IDs of the "checkout_sessions" edge to the CheckoutSession entity.
func (m *UserMutation) RemovedCheckoutSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removedcheckout_sessions {
		ids = append(ids, id)
	}
	return
}

// CheckoutSessionsIDs returns the "checkout_sessions" edge IDs in the mutation.
func (m *UserMutation) CheckoutSessionsIDs() (ids []uuid.UUID) {
	for id := range m.checkout_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetCheckoutSessions resets all changes to the "checkout_sessions" edge.
func (m *UserMutation) ResetCheckoutSessions() {
	m.checkout_sessions = nil
	m.clearedcheckout_sessions = false
	m.removedcheckout_sessions = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.stripe_customer_id != nil {
		fields = append(fields, user.FieldStripeCustomerID)
	}
	if m.stripe_account_id != nil {
		fields = append(fields, user.FieldStripeAccountID)
	}
	if m.stripe_account_capabilities != nil {
		fields = append(fields, user.FieldStripeAccountCapabilities)
	}
	if m.affiliate_6mo_code != nil {
		fields = append(fields, user.FieldAffiliate6moCode)
	}
	if m.affiliate_12mo_code != nil {
		fields = append(fields, user.FieldAffiliate12moCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldEmail:
		return m.Email()
	case user.FieldStripeCustomerID:
		return m.StripeCustomerID()
	case user.FieldStripeAccountID:
		return m.StripeAccountID()
	case user.FieldStripeAccountCapabilities:
		return m.StripeAccountCapabilities()
	case user.FieldAffiliate6moCode:
		return m.Affiliate6moCode()
	case user.FieldAffiliate12moCode:
		return m.Affiliate12moCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldStripeCustomerID:
		return m.OldStripeCustomerID(ctx)
	case user.FieldStripeAccountID:
		return m.OldStripeAccountID(ctx)
	case user.FieldStripeAccountCapabilities:
		return m.OldStripeAccountCapabilities(ctx)
	case user.FieldAffiliate6moCode:
		return m.OldAffiliate6moCode(ctx)
	case user.FieldAffiliate12moCode:
		return m.OldAffiliate12moCode(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldStripeCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeCustomerID(v)
		return nil
	case user.FieldStripeAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeAccountID(v)
		return nil
	case user.FieldStripeAccountCapabilities:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStripeAccountCapabilities(v)
		return nil
	case user.FieldAffiliate6moCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAffiliate6moCode(v)
		return nil
	case user.FieldAffiliate12moCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAffiliate12moCode(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldStripeCustomerID) {
		fields = append(fields, user.FieldStripeCustomerID)
	}
	if m.FieldCleared(user.FieldStripeAccountID) {
		fields = append(fields, user.FieldStripeAccountID)
	}
	if m.FieldCleared(user.FieldStripeAccountCapabilities) {
		fields = append(fields, user.FieldStripeAccountCapabilities)
	}
	if m.FieldCleared(user.FieldAffiliate6moCode) {
		fields = append(fields, user.FieldAffiliate6moCode)
	}
	if m.FieldCleared(user.FieldAffiliate12moCode) {
		fields = append(fields, user.FieldAffiliate12moCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldStripeCustomerID:
		m.ClearStripeCustomerID()
		return nil
	case user.FieldStripeAccountID:
		m.ClearStripeAccountID()
		return nil
	case user.FieldStripeAccountCapabilities:
		m.ClearStripeAccountCapabilities()
		return nil
	case user.FieldAffiliate6moCode:
		m.ClearAffiliate6moCode()
		return nil
	case user.FieldAffiliate12moCode:
		m.ClearAffiliate12moCode()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldStripeCustomerID:
		m.ResetStripeCustomerID()
		return nil
	case user.FieldStripeAccountID:
		m.ResetStripeAccountID()
		return nil
	case user.FieldStripeAccountCapabilities:
		m.ResetStripeAccountCapabilities()
		return nil
	case user.FieldAffiliate6moCode:
		m.ResetAffiliate6moCode()
		return nil
	case user.FieldAffiliate12moCode:
		m.ResetAffiliate12moCode()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cars != nil {
		edges = append(edges, user.EdgeCars)
	}
	if m.profile != nil {
		edges = append(edges, user.EdgeProfile)
	}
	if m.settings != nil {
		edges = append(edges, user.EdgeSettings)
	}
	if m.subscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.checkout_sessions != nil {
		edges = append(edges, user.EdgeCheckoutSessions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCars:
		ids := make([]ent.Value, 0, len(m.cars))
		for id := range m.cars {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeSettings:
		if id := m.settings; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCheckoutSessions:
		ids := make([]ent.Value, 0, len(m.checkout_sessions))
		for id := range m.checkout_sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcars != nil {
		edges = append(edges, user.EdgeCars)
	}
	if m.removedsubscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.removedcheckout_sessions != nil {
		edges = append(edges, user.EdgeCheckoutSessions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCars:
		ids := make([]ent.Value, 0, len(m.removedcars))
		for id := range m.removedcars {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCheckoutSessions:
		ids := make([]ent.Value, 0, len(m.removedcheckout_sessions))
		for id := range m.removedcheckout_sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcars {
		edges = append(edges, user.EdgeCars)
	}
	if m.clearedprofile {
		edges = append(edges, user.EdgeProfile)
	}
	if m.clearedsettings {
		edges = append(edges, user.EdgeSettings)
	}
	if m.clearedsubscriptions {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.clearedcheckout_sessions {
		edges = append(edges, user.EdgeCheckoutSessions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeCars:
		return m.clearedcars
	case user.EdgeProfile:
		return m.clearedprofile
	case user.EdgeSettings:
		return m.clearedsettings
	case user.EdgeSubscriptions:
		return m.clearedsubscriptions
	case user.EdgeCheckoutSessions:
		return m.clearedcheckout_sessions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeProfile:
		m.ClearProfile()
		return nil
	case user.EdgeSettings:
		m.ClearSettings()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeCars:
		m.ResetCars()
		return nil
	case user.EdgeProfile:
		m.ResetProfile()
		return nil
	case user.EdgeSettings:
		m.ResetSettings()
		return nil
	case user.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	case user.EdgeCheckoutSessions:
		m.ResetCheckoutSessions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserSettingsMutation represents an operation that mutates the UserSettings nodes in the graph.
type UserSettingsMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	create_time           *time.Time
	update_time           *time.Time
	currency_code         *string
	fuel_volume_unit      *usersettings.FuelVolumeUnit
	distance_unit         *usersettings.DistanceUnit
	fuel_consumption_unit *usersettings.FuelConsumptionUnit
	temperature_unit      *usersettings.TemperatureUnit
	power_unit            *usersettings.PowerUnit
	torque_unit           *usersettings.TorqueUnit
	clearedFields         map[string]struct{}
	user                  *uuid.UUID
	cleareduser           bool
	done                  bool
	oldValue              func(context.Context) (*UserSettings, error)
	predicates            []predicate.UserSettings
}

var _ ent.Mutation = (*UserSettingsMutation)(nil)

// usersettingsOption allows management of the mutation configuration using functional options.
type usersettingsOption func(*UserSettingsMutation)

// newUserSettingsMutation creates new mutation for the UserSettings entity.
func newUserSettingsMutation(c config, op Op, opts ...usersettingsOption) *UserSettingsMutation {
	m := &UserSettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSettingsID sets the ID field of the mutation.
func withUserSettingsID(id uuid.UUID) usersettingsOption {
	return func(m *UserSettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSettings
		)
		m.oldValue = func(ctx context.Context) (*UserSettings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSettings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSettings sets the old UserSettings of the mutation.
func withUserSettings(node *UserSettings) usersettingsOption {
	return func(m *UserSettingsMutation) {
		m.oldValue = func(context.Context) (*UserSettings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSettings entities.
func (m *UserSettingsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSettingsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSettingsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSettings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserSettingsMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserSettingsMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserSettings entity.
// If the UserSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingsMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserSettingsMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserSettingsMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserSettingsMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserSettings entity.
// If the UserSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingsMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserSettingsMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetCurrencyCode sets the "currency_code" field.
func (m *UserSettingsMutation) SetCurrencyCode(s string) {
	m.currency_code = &s
}

// CurrencyCode returns the value of the "currency_code" field in the mutation.
func (m *UserSettingsMutation) CurrencyCode() (r string, exists bool) {
	v := m.currency_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrencyCode returns the old "currency_code" field's value of the UserSettings entity.
// If the UserSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingsMutation) OldCurrencyCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrencyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrencyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrencyCode: %w", err)
	}
	return oldValue.CurrencyCode, nil
}

// ClearCurrencyCode clears the value of the "currency_code" field.
func (m *UserSettingsMutation) ClearCurrencyCode() {
	m.currency_code = nil
	m.clearedFields[usersettings.FieldCurrencyCode] = struct{}{}
}

// CurrencyCodeCleared returns if the "currency_code" field was cleared in this mutation.
func (m *UserSettingsMutation) CurrencyCodeCleared() bool {
	_, ok := m.clearedFields[usersettings.FieldCurrencyCode]
	return ok
}

// ResetCurrencyCode resets all changes to the "currency_code" field.
func (m *UserSettingsMutation) ResetCurrencyCode() {
	m.currency_code = nil
	delete(m.clearedFields, usersettings.FieldCurrencyCode)
}

// SetFuelVolumeUnit sets the "fuel_volume_unit" field.
func (m *UserSettingsMutation) SetFuelVolumeUnit(uvu usersettings.FuelVolumeUnit) {
	m.fuel_volume_unit = &uvu
}

// FuelVolumeUnit returns the value of the "fuel_volume_unit" field in the mutation.
func (m *UserSettingsMutation) FuelVolumeUnit() (r usersettings.FuelVolumeUnit, exists bool) {
	v := m.fuel_volume_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldFuelVolumeUnit returns the old "fuel_volume_unit" field's value of the UserSettings entity.
// If the UserSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingsMutation) OldFuelVolumeUnit(ctx context.Context) (v *usersettings.FuelVolumeUnit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFuelVolumeUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFuelVolumeUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFuelVolumeUnit: %w", err)
	}
	return oldValue.FuelVolumeUnit, nil
}

// ClearFuelVolumeUnit clears the value of the "fuel_volume_unit" field.
func (m *UserSettingsMutation) ClearFuelVolumeUnit() {
	m.fuel_volume_unit = nil
	m.clearedFields[usersettings.FieldFuelVolumeUnit] = struct{}{}
}

// FuelVolumeUnitCleared returns if the "fuel_volume_unit" field was cleared in this mutation.
func (m *UserSettingsMutation) FuelVolumeUnitCleared() bool {
	_, ok := m.clearedFields[usersettings.FieldFuelVolumeUnit]
	return ok
}

// ResetFuelVolumeUnit resets all changes to the "fuel_volume_unit" field.
func (m *UserSettingsMutation) ResetFuelVolumeUnit() {
	m.fuel_volume_unit = nil
	delete(m.clearedFields, usersettings.FieldFuelVolumeUnit)
}

// SetDistanceUnit sets the "distance_unit" field.
func (m *UserSettingsMutation) SetDistanceUnit(uu usersettings.DistanceUnit) {
	m.distance_unit = &uu
}

// DistanceUnit returns the value of the "distance_unit" field in the mutation.
func (m *UserSettingsMutation) DistanceUnit() (r usersettings.DistanceUnit, exists bool) {
	v := m.distance_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldDistanceUnit returns the old "distance_unit" field's value of the UserSettings entity.
// If the UserSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingsMutation) OldDistanceUnit(ctx context.Context) (v *usersettings.DistanceUnit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistanceUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistanceUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistanceUnit: %w", err)
	}
	return oldValue.DistanceUnit, nil
}

// ClearDistanceUnit clears the value of the "distance_unit" field.
func (m *UserSettingsMutation) ClearDistanceUnit() {
	m.distance_unit = nil
	m.clearedFields[usersettings.FieldDistanceUnit] = struct{}{}
}

// DistanceUnitCleared returns if the "distance_unit" field was cleared in this mutation.
func (m *UserSettingsMutation) DistanceUnitCleared() bool {
	_, ok := m.clearedFields[usersettings.FieldDistanceUnit]
	return ok
}

// ResetDistanceUnit resets all changes to the "distance_unit" field.
func (m *UserSettingsMutation) ResetDistanceUnit() {
	m.distance_unit = nil
	delete(m.clearedFields, usersettings.FieldDistanceUnit)
}

// SetFuelConsumptionUnit sets the "fuel_consumption_unit" field.
func (m *UserSettingsMutation) SetFuelConsumptionUnit(ucu usersettings.FuelConsumptionUnit) {
	m.fuel_consumption_unit = &ucu
}

// FuelConsumptionUnit returns the value of the "fuel_consumption_unit" field in the mutation.
func (m *UserSettingsMutation) FuelConsumptionUnit() (r usersettings.FuelConsumptionUnit, exists bool) {
	v := m.fuel_consumption_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldFuelConsumptionUnit returns the old "fuel_consumption_unit" field's value of the UserSettings entity.
// If the UserSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingsMutation) OldFuelConsumptionUnit(ctx context.Context) (v *usersettings.FuelConsumptionUnit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFuelConsumptionUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFuelConsumptionUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFuelConsumptionUnit: %w", err)
	}
	return oldValue.FuelConsumptionUnit, nil
}

// ClearFuelConsumptionUnit clears the value of the "fuel_consumption_unit" field.
func (m *UserSettingsMutation) ClearFuelConsumptionUnit() {
	m.fuel_consumption_unit = nil
	m.clearedFields[usersettings.FieldFuelConsumptionUnit] = struct{}{}
}

// FuelConsumptionUnitCleared returns if the "fuel_consumption_unit" field was cleared in this mutation.
func (m *UserSettingsMutation) FuelConsumptionUnitCleared() bool {
	_, ok := m.clearedFields[usersettings.FieldFuelConsumptionUnit]
	return ok
}

// ResetFuelConsumptionUnit resets all changes to the "fuel_consumption_unit" field.
func (m *UserSettingsMutation) ResetFuelConsumptionUnit() {
	m.fuel_consumption_unit = nil
	delete(m.clearedFields, usersettings.FieldFuelConsumptionUnit)
}

// SetTemperatureUnit sets the "temperature_unit" field.
func (m *UserSettingsMutation) SetTemperatureUnit(uu usersettings.TemperatureUnit) {
	m.temperature_unit = &uu
}

// TemperatureUnit returns the value of the "temperature_unit" field in the mutation.
func (m *UserSettingsMutation) TemperatureUnit() (r usersettings.TemperatureUnit, exists bool) {
	v := m.temperature_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldTemperatureUnit returns the old "temperature_unit" field's value of the UserSettings entity.
// If the UserSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingsMutation) OldTemperatureUnit(ctx context.Context) (v *usersettings.TemperatureUnit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemperatureUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemperatureUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemperatureUnit: %w", err)
	}
	return oldValue.TemperatureUnit, nil
}

// ClearTemperatureUnit clears the value of the "temperature_unit" field.
func (m *UserSettingsMutation) ClearTemperatureUnit() {
	m.temperature_unit = nil
	m.clearedFields[usersettings.FieldTemperatureUnit] = struct{}{}
}

// TemperatureUnitCleared returns if the "temperature_unit" field was cleared in this mutation.
func (m *UserSettingsMutation) TemperatureUnitCleared() bool {
	_, ok := m.clearedFields[usersettings.FieldTemperatureUnit]
	return ok
}

// ResetTemperatureUnit resets all changes to the "temperature_unit" field.
func (m *UserSettingsMutation) ResetTemperatureUnit() {
	m.temperature_unit = nil
	delete(m.clearedFields, usersettings.FieldTemperatureUnit)
}

// SetPowerUnit sets the "power_unit" field.
func (m *UserSettingsMutation) SetPowerUnit(uu usersettings.PowerUnit) {
	m.power_unit = &uu
}

// PowerUnit returns the value of the "power_unit" field in the mutation.
func (m *UserSettingsMutation) PowerUnit() (r usersettings.PowerUnit, exists bool) {
	v := m.power_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldPowerUnit returns the old "power_unit" field's value of the UserSettings entity.
// If the UserSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingsMutation) OldPowerUnit(ctx context.Context) (v *usersettings.PowerUnit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPowerUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPowerUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPowerUnit: %w", err)
	}
	return oldValue.PowerUnit, nil
}

// ClearPowerUnit clears the value of the "power_unit" field.
func (m *UserSettingsMutation) ClearPowerUnit() {
	m.power_unit = nil
	m.clearedFields[usersettings.FieldPowerUnit] = struct{}{}
}

// PowerUnitCleared returns if the "power_unit" field was cleared in this mutation.
func (m *UserSettingsMutation) PowerUnitCleared() bool {
	_, ok := m.clearedFields[usersettings.FieldPowerUnit]
	return ok
}

// ResetPowerUnit resets all changes to the "power_unit" field.
func (m *UserSettingsMutation) ResetPowerUnit() {
	m.power_unit = nil
	delete(m.clearedFields, usersettings.FieldPowerUnit)
}

// SetTorqueUnit sets the "torque_unit" field.
func (m *UserSettingsMutation) SetTorqueUnit(uu usersettings.TorqueUnit) {
	m.torque_unit = &uu
}

// TorqueUnit returns the value of the "torque_unit" field in the mutation.
func (m *UserSettingsMutation) TorqueUnit() (r usersettings.TorqueUnit, exists bool) {
	v := m.torque_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldTorqueUnit returns the old "torque_unit" field's value of the UserSettings entity.
// If the UserSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSettingsMutation) OldTorqueUnit(ctx context.Context) (v *usersettings.TorqueUnit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTorqueUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTorqueUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTorqueUnit: %w", err)
	}
	return oldValue.TorqueUnit, nil
}

// ClearTorqueUnit clears the value of the "torque_unit" field.
func (m *UserSettingsMutation) ClearTorqueUnit() {
	m.torque_unit = nil
	m.clearedFields[usersettings.FieldTorqueUnit] = struct{}{}
}

// TorqueUnitCleared returns if the "torque_unit" field was cleared in this mutation.
func (m *UserSettingsMutation) TorqueUnitCleared() bool {
	_, ok := m.clearedFields[usersettings.FieldTorqueUnit]
	return ok
}

// ResetTorqueUnit resets all changes to the "torque_unit" field.
func (m *UserSettingsMutation) ResetTorqueUnit() {
	m.torque_unit = nil
	delete(m.clearedFields, usersettings.FieldTorqueUnit)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserSettingsMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserSettingsMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserSettingsMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserSettingsMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserSettingsMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserSettingsMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserSettingsMutation builder.
func (m *UserSettingsMutation) Where(ps ...predicate.UserSettings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSettings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSettings).
func (m *UserSettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSettingsMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, usersettings.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, usersettings.FieldUpdateTime)
	}
	if m.currency_code != nil {
		fields = append(fields, usersettings.FieldCurrencyCode)
	}
	if m.fuel_volume_unit != nil {
		fields = append(fields, usersettings.FieldFuelVolumeUnit)
	}
	if m.distance_unit != nil {
		fields = append(fields, usersettings.FieldDistanceUnit)
	}
	if m.fuel_consumption_unit != nil {
		fields = append(fields, usersettings.FieldFuelConsumptionUnit)
	}
	if m.temperature_unit != nil {
		fields = append(fields, usersettings.FieldTemperatureUnit)
	}
	if m.power_unit != nil {
		fields = append(fields, usersettings.FieldPowerUnit)
	}
	if m.torque_unit != nil {
		fields = append(fields, usersettings.FieldTorqueUnit)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersettings.FieldCreateTime:
		return m.CreateTime()
	case usersettings.FieldUpdateTime:
		return m.UpdateTime()
	case usersettings.FieldCurrencyCode:
		return m.CurrencyCode()
	case usersettings.FieldFuelVolumeUnit:
		return m.FuelVolumeUnit()
	case usersettings.FieldDistanceUnit:
		return m.DistanceUnit()
	case usersettings.FieldFuelConsumptionUnit:
		return m.FuelConsumptionUnit()
	case usersettings.FieldTemperatureUnit:
		return m.TemperatureUnit()
	case usersettings.FieldPowerUnit:
		return m.PowerUnit()
	case usersettings.FieldTorqueUnit:
		return m.TorqueUnit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersettings.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case usersettings.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case usersettings.FieldCurrencyCode:
		return m.OldCurrencyCode(ctx)
	case usersettings.FieldFuelVolumeUnit:
		return m.OldFuelVolumeUnit(ctx)
	case usersettings.FieldDistanceUnit:
		return m.OldDistanceUnit(ctx)
	case usersettings.FieldFuelConsumptionUnit:
		return m.OldFuelConsumptionUnit(ctx)
	case usersettings.FieldTemperatureUnit:
		return m.OldTemperatureUnit(ctx)
	case usersettings.FieldPowerUnit:
		return m.OldPowerUnit(ctx)
	case usersettings.FieldTorqueUnit:
		return m.OldTorqueUnit(ctx)
	}
	return nil, fmt.Errorf("unknown UserSettings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersettings.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case usersettings.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case usersettings.FieldCurrencyCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrencyCode(v)
		return nil
	case usersettings.FieldFuelVolumeUnit:
		v, ok := value.(usersettings.FuelVolumeUnit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFuelVolumeUnit(v)
		return nil
	case usersettings.FieldDistanceUnit:
		v, ok := value.(usersettings.DistanceUnit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistanceUnit(v)
		return nil
	case usersettings.FieldFuelConsumptionUnit:
		v, ok := value.(usersettings.FuelConsumptionUnit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFuelConsumptionUnit(v)
		return nil
	case usersettings.FieldTemperatureUnit:
		v, ok := value.(usersettings.TemperatureUnit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemperatureUnit(v)
		return nil
	case usersettings.FieldPowerUnit:
		v, ok := value.(usersettings.PowerUnit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPowerUnit(v)
		return nil
	case usersettings.FieldTorqueUnit:
		v, ok := value.(usersettings.TorqueUnit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTorqueUnit(v)
		return nil
	}
	return fmt.Errorf("unknown UserSettings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSettings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usersettings.FieldCurrencyCode) {
		fields = append(fields, usersettings.FieldCurrencyCode)
	}
	if m.FieldCleared(usersettings.FieldFuelVolumeUnit) {
		fields = append(fields, usersettings.FieldFuelVolumeUnit)
	}
	if m.FieldCleared(usersettings.FieldDistanceUnit) {
		fields = append(fields, usersettings.FieldDistanceUnit)
	}
	if m.FieldCleared(usersettings.FieldFuelConsumptionUnit) {
		fields = append(fields, usersettings.FieldFuelConsumptionUnit)
	}
	if m.FieldCleared(usersettings.FieldTemperatureUnit) {
		fields = append(fields, usersettings.FieldTemperatureUnit)
	}
	if m.FieldCleared(usersettings.FieldPowerUnit) {
		fields = append(fields, usersettings.FieldPowerUnit)
	}
	if m.FieldCleared(usersettings.FieldTorqueUnit) {
		fields = append(fields, usersettings.FieldTorqueUnit)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSettingsMutation) ClearField(name string) error {
	switch name {
	case usersettings.FieldCurrencyCode:
		m.ClearCurrencyCode()
		return nil
	case usersettings.FieldFuelVolumeUnit:
		m.ClearFuelVolumeUnit()
		return nil
	case usersettings.FieldDistanceUnit:
		m.ClearDistanceUnit()
		return nil
	case usersettings.FieldFuelConsumptionUnit:
		m.ClearFuelConsumptionUnit()
		return nil
	case usersettings.FieldTemperatureUnit:
		m.ClearTemperatureUnit()
		return nil
	case usersettings.FieldPowerUnit:
		m.ClearPowerUnit()
		return nil
	case usersettings.FieldTorqueUnit:
		m.ClearTorqueUnit()
		return nil
	}
	return fmt.Errorf("unknown UserSettings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSettingsMutation) ResetField(name string) error {
	switch name {
	case usersettings.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case usersettings.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case usersettings.FieldCurrencyCode:
		m.ResetCurrencyCode()
		return nil
	case usersettings.FieldFuelVolumeUnit:
		m.ResetFuelVolumeUnit()
		return nil
	case usersettings.FieldDistanceUnit:
		m.ResetDistanceUnit()
		return nil
	case usersettings.FieldFuelConsumptionUnit:
		m.ResetFuelConsumptionUnit()
		return nil
	case usersettings.FieldTemperatureUnit:
		m.ResetTemperatureUnit()
		return nil
	case usersettings.FieldPowerUnit:
		m.ResetPowerUnit()
		return nil
	case usersettings.FieldTorqueUnit:
		m.ResetTorqueUnit()
		return nil
	}
	return fmt.Errorf("unknown UserSettings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usersettings.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSettingsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersettings.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, usersettings.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSettingsMutation) EdgeCleared(name string) bool {
	switch name {
	case usersettings.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSettingsMutation) ClearEdge(name string) error {
	switch name {
	case usersettings.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserSettings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSettingsMutation) ResetEdge(name string) error {
	switch name {
	case usersettings.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserSettings edge %s", name)
}

// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/Dan6erbond/revline/ent/car"
	"github.com/Dan6erbond/revline/ent/dragresult"
	"github.com/Dan6erbond/revline/ent/dragsession"
	"github.com/Dan6erbond/revline/ent/fuelup"
	"github.com/Dan6erbond/revline/ent/media"
	"github.com/Dan6erbond/revline/ent/odometerreading"
	"github.com/Dan6erbond/revline/ent/predicate"
	"github.com/Dan6erbond/revline/ent/profile"
	"github.com/Dan6erbond/revline/ent/serviceitem"
	"github.com/Dan6erbond/revline/ent/servicelog"
	"github.com/Dan6erbond/revline/ent/serviceschedule"
	"github.com/Dan6erbond/revline/ent/user"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCar             = "Car"
	TypeDragResult      = "DragResult"
	TypeDragSession     = "DragSession"
	TypeFuelUp          = "FuelUp"
	TypeMedia           = "Media"
	TypeOdometerReading = "OdometerReading"
	TypeProfile         = "Profile"
	TypeServiceItem     = "ServiceItem"
	TypeServiceLog      = "ServiceLog"
	TypeServiceSchedule = "ServiceSchedule"
	TypeUser            = "User"
)

// CarMutation represents an operation that mutates the Car nodes in the graph.
type CarMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	create_time              *time.Time
	update_time              *time.Time
	name                     *string
	make                     *string
	model                    *string
	_type                    *string
	year                     *int
	addyear                  *int
	trim                     *string
	clearedFields            map[string]struct{}
	owner                    *uuid.UUID
	clearedowner             bool
	drag_sessions            map[uuid.UUID]struct{}
	removeddrag_sessions     map[uuid.UUID]struct{}
	cleareddrag_sessions     bool
	fuel_ups                 map[uuid.UUID]struct{}
	removedfuel_ups          map[uuid.UUID]struct{}
	clearedfuel_ups          bool
	odometer_readings        map[uuid.UUID]struct{}
	removedodometer_readings map[uuid.UUID]struct{}
	clearedodometer_readings bool
	service_items            map[uuid.UUID]struct{}
	removedservice_items     map[uuid.UUID]struct{}
	clearedservice_items     bool
	service_logs             map[uuid.UUID]struct{}
	removedservice_logs      map[uuid.UUID]struct{}
	clearedservice_logs      bool
	service_schedules        map[uuid.UUID]struct{}
	removedservice_schedules map[uuid.UUID]struct{}
	clearedservice_schedules bool
	media                    map[uuid.UUID]struct{}
	removedmedia             map[uuid.UUID]struct{}
	clearedmedia             bool
	banner_image             *uuid.UUID
	clearedbanner_image      bool
	done                     bool
	oldValue                 func(context.Context) (*Car, error)
	predicates               []predicate.Car
}

var _ ent.Mutation = (*CarMutation)(nil)

// carOption allows management of the mutation configuration using functional options.
type carOption func(*CarMutation)

// newCarMutation creates new mutation for the Car entity.
func newCarMutation(c config, op Op, opts ...carOption) *CarMutation {
	m := &CarMutation{
		config:        c,
		op:            op,
		typ:           TypeCar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarID sets the ID field of the mutation.
func withCarID(id uuid.UUID) carOption {
	return func(m *CarMutation) {
		var (
			err   error
			once  sync.Once
			value *Car
		)
		m.oldValue = func(ctx context.Context) (*Car, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Car.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCar sets the old Car of the mutation.
func withCar(node *Car) carOption {
	return func(m *CarMutation) {
		m.oldValue = func(context.Context) (*Car, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Car entities.
func (m *CarMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Car.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CarMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CarMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CarMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CarMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CarMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CarMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *CarMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CarMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CarMutation) ResetName() {
	m.name = nil
}

// SetMake sets the "make" field.
func (m *CarMutation) SetMake(s string) {
	m.make = &s
}

// Make returns the value of the "make" field in the mutation.
func (m *CarMutation) Make() (r string, exists bool) {
	v := m.make
	if v == nil {
		return
	}
	return *v, true
}

// OldMake returns the old "make" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldMake(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMake is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMake requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMake: %w", err)
	}
	return oldValue.Make, nil
}

// ClearMake clears the value of the "make" field.
func (m *CarMutation) ClearMake() {
	m.make = nil
	m.clearedFields[car.FieldMake] = struct{}{}
}

// MakeCleared returns if the "make" field was cleared in this mutation.
func (m *CarMutation) MakeCleared() bool {
	_, ok := m.clearedFields[car.FieldMake]
	return ok
}

// ResetMake resets all changes to the "make" field.
func (m *CarMutation) ResetMake() {
	m.make = nil
	delete(m.clearedFields, car.FieldMake)
}

// SetModel sets the "model" field.
func (m *CarMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *CarMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldModel(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *CarMutation) ClearModel() {
	m.model = nil
	m.clearedFields[car.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *CarMutation) ModelCleared() bool {
	_, ok := m.clearedFields[car.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *CarMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, car.FieldModel)
}

// SetType sets the "type" field.
func (m *CarMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *CarMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *CarMutation) ClearType() {
	m._type = nil
	m.clearedFields[car.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *CarMutation) TypeCleared() bool {
	_, ok := m.clearedFields[car.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *CarMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, car.FieldType)
}

// SetYear sets the "year" field.
func (m *CarMutation) SetYear(i int) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *CarMutation) Year() (r int, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldYear(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *CarMutation) AddYear(i int) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *CarMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ClearYear clears the value of the "year" field.
func (m *CarMutation) ClearYear() {
	m.year = nil
	m.addyear = nil
	m.clearedFields[car.FieldYear] = struct{}{}
}

// YearCleared returns if the "year" field was cleared in this mutation.
func (m *CarMutation) YearCleared() bool {
	_, ok := m.clearedFields[car.FieldYear]
	return ok
}

// ResetYear resets all changes to the "year" field.
func (m *CarMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
	delete(m.clearedFields, car.FieldYear)
}

// SetTrim sets the "trim" field.
func (m *CarMutation) SetTrim(s string) {
	m.trim = &s
}

// Trim returns the value of the "trim" field in the mutation.
func (m *CarMutation) Trim() (r string, exists bool) {
	v := m.trim
	if v == nil {
		return
	}
	return *v, true
}

// OldTrim returns the old "trim" field's value of the Car entity.
// If the Car object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarMutation) OldTrim(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrim is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrim requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrim: %w", err)
	}
	return oldValue.Trim, nil
}

// ClearTrim clears the value of the "trim" field.
func (m *CarMutation) ClearTrim() {
	m.trim = nil
	m.clearedFields[car.FieldTrim] = struct{}{}
}

// TrimCleared returns if the "trim" field was cleared in this mutation.
func (m *CarMutation) TrimCleared() bool {
	_, ok := m.clearedFields[car.FieldTrim]
	return ok
}

// ResetTrim resets all changes to the "trim" field.
func (m *CarMutation) ResetTrim() {
	m.trim = nil
	delete(m.clearedFields, car.FieldTrim)
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *CarMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *CarMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *CarMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *CarMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CarMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *CarMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddDragSessionIDs adds the "drag_sessions" edge to the DragSession entity by ids.
func (m *CarMutation) AddDragSessionIDs(ids ...uuid.UUID) {
	if m.drag_sessions == nil {
		m.drag_sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.drag_sessions[ids[i]] = struct{}{}
	}
}

// ClearDragSessions clears the "drag_sessions" edge to the DragSession entity.
func (m *CarMutation) ClearDragSessions() {
	m.cleareddrag_sessions = true
}

// DragSessionsCleared reports if the "drag_sessions" edge to the DragSession entity was cleared.
func (m *CarMutation) DragSessionsCleared() bool {
	return m.cleareddrag_sessions
}

// RemoveDragSessionIDs removes the "drag_sessions" edge to the DragSession entity by IDs.
func (m *CarMutation) RemoveDragSessionIDs(ids ...uuid.UUID) {
	if m.removeddrag_sessions == nil {
		m.removeddrag_sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.drag_sessions, ids[i])
		m.removeddrag_sessions[ids[i]] = struct{}{}
	}
}

// RemovedDragSessions returns the removed IDs of the "drag_sessions" edge to the DragSession entity.
func (m *CarMutation) RemovedDragSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removeddrag_sessions {
		ids = append(ids, id)
	}
	return
}

// DragSessionsIDs returns the "drag_sessions" edge IDs in the mutation.
func (m *CarMutation) DragSessionsIDs() (ids []uuid.UUID) {
	for id := range m.drag_sessions {
		ids = append(ids, id)
	}
	return
}

// ResetDragSessions resets all changes to the "drag_sessions" edge.
func (m *CarMutation) ResetDragSessions() {
	m.drag_sessions = nil
	m.cleareddrag_sessions = false
	m.removeddrag_sessions = nil
}

// AddFuelUpIDs adds the "fuel_ups" edge to the FuelUp entity by ids.
func (m *CarMutation) AddFuelUpIDs(ids ...uuid.UUID) {
	if m.fuel_ups == nil {
		m.fuel_ups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.fuel_ups[ids[i]] = struct{}{}
	}
}

// ClearFuelUps clears the "fuel_ups" edge to the FuelUp entity.
func (m *CarMutation) ClearFuelUps() {
	m.clearedfuel_ups = true
}

// FuelUpsCleared reports if the "fuel_ups" edge to the FuelUp entity was cleared.
func (m *CarMutation) FuelUpsCleared() bool {
	return m.clearedfuel_ups
}

// RemoveFuelUpIDs removes the "fuel_ups" edge to the FuelUp entity by IDs.
func (m *CarMutation) RemoveFuelUpIDs(ids ...uuid.UUID) {
	if m.removedfuel_ups == nil {
		m.removedfuel_ups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.fuel_ups, ids[i])
		m.removedfuel_ups[ids[i]] = struct{}{}
	}
}

// RemovedFuelUps returns the removed IDs of the "fuel_ups" edge to the FuelUp entity.
func (m *CarMutation) RemovedFuelUpsIDs() (ids []uuid.UUID) {
	for id := range m.removedfuel_ups {
		ids = append(ids, id)
	}
	return
}

// FuelUpsIDs returns the "fuel_ups" edge IDs in the mutation.
func (m *CarMutation) FuelUpsIDs() (ids []uuid.UUID) {
	for id := range m.fuel_ups {
		ids = append(ids, id)
	}
	return
}

// ResetFuelUps resets all changes to the "fuel_ups" edge.
func (m *CarMutation) ResetFuelUps() {
	m.fuel_ups = nil
	m.clearedfuel_ups = false
	m.removedfuel_ups = nil
}

// AddOdometerReadingIDs adds the "odometer_readings" edge to the OdometerReading entity by ids.
func (m *CarMutation) AddOdometerReadingIDs(ids ...uuid.UUID) {
	if m.odometer_readings == nil {
		m.odometer_readings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.odometer_readings[ids[i]] = struct{}{}
	}
}

// ClearOdometerReadings clears the "odometer_readings" edge to the OdometerReading entity.
func (m *CarMutation) ClearOdometerReadings() {
	m.clearedodometer_readings = true
}

// OdometerReadingsCleared reports if the "odometer_readings" edge to the OdometerReading entity was cleared.
func (m *CarMutation) OdometerReadingsCleared() bool {
	return m.clearedodometer_readings
}

// RemoveOdometerReadingIDs removes the "odometer_readings" edge to the OdometerReading entity by IDs.
func (m *CarMutation) RemoveOdometerReadingIDs(ids ...uuid.UUID) {
	if m.removedodometer_readings == nil {
		m.removedodometer_readings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.odometer_readings, ids[i])
		m.removedodometer_readings[ids[i]] = struct{}{}
	}
}

// RemovedOdometerReadings returns the removed IDs of the "odometer_readings" edge to the OdometerReading entity.
func (m *CarMutation) RemovedOdometerReadingsIDs() (ids []uuid.UUID) {
	for id := range m.removedodometer_readings {
		ids = append(ids, id)
	}
	return
}

// OdometerReadingsIDs returns the "odometer_readings" edge IDs in the mutation.
func (m *CarMutation) OdometerReadingsIDs() (ids []uuid.UUID) {
	for id := range m.odometer_readings {
		ids = append(ids, id)
	}
	return
}

// ResetOdometerReadings resets all changes to the "odometer_readings" edge.
func (m *CarMutation) ResetOdometerReadings() {
	m.odometer_readings = nil
	m.clearedodometer_readings = false
	m.removedodometer_readings = nil
}

// AddServiceItemIDs adds the "service_items" edge to the ServiceItem entity by ids.
func (m *CarMutation) AddServiceItemIDs(ids ...uuid.UUID) {
	if m.service_items == nil {
		m.service_items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.service_items[ids[i]] = struct{}{}
	}
}

// ClearServiceItems clears the "service_items" edge to the ServiceItem entity.
func (m *CarMutation) ClearServiceItems() {
	m.clearedservice_items = true
}

// ServiceItemsCleared reports if the "service_items" edge to the ServiceItem entity was cleared.
func (m *CarMutation) ServiceItemsCleared() bool {
	return m.clearedservice_items
}

// RemoveServiceItemIDs removes the "service_items" edge to the ServiceItem entity by IDs.
func (m *CarMutation) RemoveServiceItemIDs(ids ...uuid.UUID) {
	if m.removedservice_items == nil {
		m.removedservice_items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.service_items, ids[i])
		m.removedservice_items[ids[i]] = struct{}{}
	}
}

// RemovedServiceItems returns the removed IDs of the "service_items" edge to the ServiceItem entity.
func (m *CarMutation) RemovedServiceItemsIDs() (ids []uuid.UUID) {
	for id := range m.removedservice_items {
		ids = append(ids, id)
	}
	return
}

// ServiceItemsIDs returns the "service_items" edge IDs in the mutation.
func (m *CarMutation) ServiceItemsIDs() (ids []uuid.UUID) {
	for id := range m.service_items {
		ids = append(ids, id)
	}
	return
}

// ResetServiceItems resets all changes to the "service_items" edge.
func (m *CarMutation) ResetServiceItems() {
	m.service_items = nil
	m.clearedservice_items = false
	m.removedservice_items = nil
}

// AddServiceLogIDs adds the "service_logs" edge to the ServiceLog entity by ids.
func (m *CarMutation) AddServiceLogIDs(ids ...uuid.UUID) {
	if m.service_logs == nil {
		m.service_logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.service_logs[ids[i]] = struct{}{}
	}
}

// ClearServiceLogs clears the "service_logs" edge to the ServiceLog entity.
func (m *CarMutation) ClearServiceLogs() {
	m.clearedservice_logs = true
}

// ServiceLogsCleared reports if the "service_logs" edge to the ServiceLog entity was cleared.
func (m *CarMutation) ServiceLogsCleared() bool {
	return m.clearedservice_logs
}

// RemoveServiceLogIDs removes the "service_logs" edge to the ServiceLog entity by IDs.
func (m *CarMutation) RemoveServiceLogIDs(ids ...uuid.UUID) {
	if m.removedservice_logs == nil {
		m.removedservice_logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.service_logs, ids[i])
		m.removedservice_logs[ids[i]] = struct{}{}
	}
}

// RemovedServiceLogs returns the removed IDs of the "service_logs" edge to the ServiceLog entity.
func (m *CarMutation) RemovedServiceLogsIDs() (ids []uuid.UUID) {
	for id := range m.removedservice_logs {
		ids = append(ids, id)
	}
	return
}

// ServiceLogsIDs returns the "service_logs" edge IDs in the mutation.
func (m *CarMutation) ServiceLogsIDs() (ids []uuid.UUID) {
	for id := range m.service_logs {
		ids = append(ids, id)
	}
	return
}

// ResetServiceLogs resets all changes to the "service_logs" edge.
func (m *CarMutation) ResetServiceLogs() {
	m.service_logs = nil
	m.clearedservice_logs = false
	m.removedservice_logs = nil
}

// AddServiceScheduleIDs adds the "service_schedules" edge to the ServiceSchedule entity by ids.
func (m *CarMutation) AddServiceScheduleIDs(ids ...uuid.UUID) {
	if m.service_schedules == nil {
		m.service_schedules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.service_schedules[ids[i]] = struct{}{}
	}
}

// ClearServiceSchedules clears the "service_schedules" edge to the ServiceSchedule entity.
func (m *CarMutation) ClearServiceSchedules() {
	m.clearedservice_schedules = true
}

// ServiceSchedulesCleared reports if the "service_schedules" edge to the ServiceSchedule entity was cleared.
func (m *CarMutation) ServiceSchedulesCleared() bool {
	return m.clearedservice_schedules
}

// RemoveServiceScheduleIDs removes the "service_schedules" edge to the ServiceSchedule entity by IDs.
func (m *CarMutation) RemoveServiceScheduleIDs(ids ...uuid.UUID) {
	if m.removedservice_schedules == nil {
		m.removedservice_schedules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.service_schedules, ids[i])
		m.removedservice_schedules[ids[i]] = struct{}{}
	}
}

// RemovedServiceSchedules returns the removed IDs of the "service_schedules" edge to the ServiceSchedule entity.
func (m *CarMutation) RemovedServiceSchedulesIDs() (ids []uuid.UUID) {
	for id := range m.removedservice_schedules {
		ids = append(ids, id)
	}
	return
}

// ServiceSchedulesIDs returns the "service_schedules" edge IDs in the mutation.
func (m *CarMutation) ServiceSchedulesIDs() (ids []uuid.UUID) {
	for id := range m.service_schedules {
		ids = append(ids, id)
	}
	return
}

// ResetServiceSchedules resets all changes to the "service_schedules" edge.
func (m *CarMutation) ResetServiceSchedules() {
	m.service_schedules = nil
	m.clearedservice_schedules = false
	m.removedservice_schedules = nil
}

// AddMediumIDs adds the "media" edge to the Media entity by ids.
func (m *CarMutation) AddMediumIDs(ids ...uuid.UUID) {
	if m.media == nil {
		m.media = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.media[ids[i]] = struct{}{}
	}
}

// ClearMedia clears the "media" edge to the Media entity.
func (m *CarMutation) ClearMedia() {
	m.clearedmedia = true
}

// MediaCleared reports if the "media" edge to the Media entity was cleared.
func (m *CarMutation) MediaCleared() bool {
	return m.clearedmedia
}

// RemoveMediumIDs removes the "media" edge to the Media entity by IDs.
func (m *CarMutation) RemoveMediumIDs(ids ...uuid.UUID) {
	if m.removedmedia == nil {
		m.removedmedia = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.media, ids[i])
		m.removedmedia[ids[i]] = struct{}{}
	}
}

// RemovedMedia returns the removed IDs of the "media" edge to the Media entity.
func (m *CarMutation) RemovedMediaIDs() (ids []uuid.UUID) {
	for id := range m.removedmedia {
		ids = append(ids, id)
	}
	return
}

// MediaIDs returns the "media" edge IDs in the mutation.
func (m *CarMutation) MediaIDs() (ids []uuid.UUID) {
	for id := range m.media {
		ids = append(ids, id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *CarMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
	m.removedmedia = nil
}

// SetBannerImageID sets the "banner_image" edge to the Media entity by id.
func (m *CarMutation) SetBannerImageID(id uuid.UUID) {
	m.banner_image = &id
}

// ClearBannerImage clears the "banner_image" edge to the Media entity.
func (m *CarMutation) ClearBannerImage() {
	m.clearedbanner_image = true
}

// BannerImageCleared reports if the "banner_image" edge to the Media entity was cleared.
func (m *CarMutation) BannerImageCleared() bool {
	return m.clearedbanner_image
}

// BannerImageID returns the "banner_image" edge ID in the mutation.
func (m *CarMutation) BannerImageID() (id uuid.UUID, exists bool) {
	if m.banner_image != nil {
		return *m.banner_image, true
	}
	return
}

// BannerImageIDs returns the "banner_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BannerImageID instead. It exists only for internal usage by the builders.
func (m *CarMutation) BannerImageIDs() (ids []uuid.UUID) {
	if id := m.banner_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBannerImage resets all changes to the "banner_image" edge.
func (m *CarMutation) ResetBannerImage() {
	m.banner_image = nil
	m.clearedbanner_image = false
}

// Where appends a list predicates to the CarMutation builder.
func (m *CarMutation) Where(ps ...predicate.Car) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Car, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Car).
func (m *CarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, car.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, car.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, car.FieldName)
	}
	if m.make != nil {
		fields = append(fields, car.FieldMake)
	}
	if m.model != nil {
		fields = append(fields, car.FieldModel)
	}
	if m._type != nil {
		fields = append(fields, car.FieldType)
	}
	if m.year != nil {
		fields = append(fields, car.FieldYear)
	}
	if m.trim != nil {
		fields = append(fields, car.FieldTrim)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case car.FieldCreateTime:
		return m.CreateTime()
	case car.FieldUpdateTime:
		return m.UpdateTime()
	case car.FieldName:
		return m.Name()
	case car.FieldMake:
		return m.Make()
	case car.FieldModel:
		return m.Model()
	case car.FieldType:
		return m.GetType()
	case car.FieldYear:
		return m.Year()
	case car.FieldTrim:
		return m.Trim()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case car.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case car.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case car.FieldName:
		return m.OldName(ctx)
	case car.FieldMake:
		return m.OldMake(ctx)
	case car.FieldModel:
		return m.OldModel(ctx)
	case car.FieldType:
		return m.OldType(ctx)
	case car.FieldYear:
		return m.OldYear(ctx)
	case car.FieldTrim:
		return m.OldTrim(ctx)
	}
	return nil, fmt.Errorf("unknown Car field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case car.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case car.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case car.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case car.FieldMake:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMake(v)
		return nil
	case car.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case car.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case car.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case car.FieldTrim:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrim(v)
		return nil
	}
	return fmt.Errorf("unknown Car field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, car.FieldYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case car.FieldYear:
		return m.AddedYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarMutation) AddField(name string, value ent.Value) error {
	switch name {
	case car.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	}
	return fmt.Errorf("unknown Car numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(car.FieldMake) {
		fields = append(fields, car.FieldMake)
	}
	if m.FieldCleared(car.FieldModel) {
		fields = append(fields, car.FieldModel)
	}
	if m.FieldCleared(car.FieldType) {
		fields = append(fields, car.FieldType)
	}
	if m.FieldCleared(car.FieldYear) {
		fields = append(fields, car.FieldYear)
	}
	if m.FieldCleared(car.FieldTrim) {
		fields = append(fields, car.FieldTrim)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarMutation) ClearField(name string) error {
	switch name {
	case car.FieldMake:
		m.ClearMake()
		return nil
	case car.FieldModel:
		m.ClearModel()
		return nil
	case car.FieldType:
		m.ClearType()
		return nil
	case car.FieldYear:
		m.ClearYear()
		return nil
	case car.FieldTrim:
		m.ClearTrim()
		return nil
	}
	return fmt.Errorf("unknown Car nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarMutation) ResetField(name string) error {
	switch name {
	case car.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case car.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case car.FieldName:
		m.ResetName()
		return nil
	case car.FieldMake:
		m.ResetMake()
		return nil
	case car.FieldModel:
		m.ResetModel()
		return nil
	case car.FieldType:
		m.ResetType()
		return nil
	case car.FieldYear:
		m.ResetYear()
		return nil
	case car.FieldTrim:
		m.ResetTrim()
		return nil
	}
	return fmt.Errorf("unknown Car field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.owner != nil {
		edges = append(edges, car.EdgeOwner)
	}
	if m.drag_sessions != nil {
		edges = append(edges, car.EdgeDragSessions)
	}
	if m.fuel_ups != nil {
		edges = append(edges, car.EdgeFuelUps)
	}
	if m.odometer_readings != nil {
		edges = append(edges, car.EdgeOdometerReadings)
	}
	if m.service_items != nil {
		edges = append(edges, car.EdgeServiceItems)
	}
	if m.service_logs != nil {
		edges = append(edges, car.EdgeServiceLogs)
	}
	if m.service_schedules != nil {
		edges = append(edges, car.EdgeServiceSchedules)
	}
	if m.media != nil {
		edges = append(edges, car.EdgeMedia)
	}
	if m.banner_image != nil {
		edges = append(edges, car.EdgeBannerImage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case car.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case car.EdgeDragSessions:
		ids := make([]ent.Value, 0, len(m.drag_sessions))
		for id := range m.drag_sessions {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeFuelUps:
		ids := make([]ent.Value, 0, len(m.fuel_ups))
		for id := range m.fuel_ups {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeOdometerReadings:
		ids := make([]ent.Value, 0, len(m.odometer_readings))
		for id := range m.odometer_readings {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeServiceItems:
		ids := make([]ent.Value, 0, len(m.service_items))
		for id := range m.service_items {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeServiceLogs:
		ids := make([]ent.Value, 0, len(m.service_logs))
		for id := range m.service_logs {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeServiceSchedules:
		ids := make([]ent.Value, 0, len(m.service_schedules))
		for id := range m.service_schedules {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.media))
		for id := range m.media {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeBannerImage:
		if id := m.banner_image; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removeddrag_sessions != nil {
		edges = append(edges, car.EdgeDragSessions)
	}
	if m.removedfuel_ups != nil {
		edges = append(edges, car.EdgeFuelUps)
	}
	if m.removedodometer_readings != nil {
		edges = append(edges, car.EdgeOdometerReadings)
	}
	if m.removedservice_items != nil {
		edges = append(edges, car.EdgeServiceItems)
	}
	if m.removedservice_logs != nil {
		edges = append(edges, car.EdgeServiceLogs)
	}
	if m.removedservice_schedules != nil {
		edges = append(edges, car.EdgeServiceSchedules)
	}
	if m.removedmedia != nil {
		edges = append(edges, car.EdgeMedia)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case car.EdgeDragSessions:
		ids := make([]ent.Value, 0, len(m.removeddrag_sessions))
		for id := range m.removeddrag_sessions {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeFuelUps:
		ids := make([]ent.Value, 0, len(m.removedfuel_ups))
		for id := range m.removedfuel_ups {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeOdometerReadings:
		ids := make([]ent.Value, 0, len(m.removedodometer_readings))
		for id := range m.removedodometer_readings {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeServiceItems:
		ids := make([]ent.Value, 0, len(m.removedservice_items))
		for id := range m.removedservice_items {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeServiceLogs:
		ids := make([]ent.Value, 0, len(m.removedservice_logs))
		for id := range m.removedservice_logs {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeServiceSchedules:
		ids := make([]ent.Value, 0, len(m.removedservice_schedules))
		for id := range m.removedservice_schedules {
			ids = append(ids, id)
		}
		return ids
	case car.EdgeMedia:
		ids := make([]ent.Value, 0, len(m.removedmedia))
		for id := range m.removedmedia {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedowner {
		edges = append(edges, car.EdgeOwner)
	}
	if m.cleareddrag_sessions {
		edges = append(edges, car.EdgeDragSessions)
	}
	if m.clearedfuel_ups {
		edges = append(edges, car.EdgeFuelUps)
	}
	if m.clearedodometer_readings {
		edges = append(edges, car.EdgeOdometerReadings)
	}
	if m.clearedservice_items {
		edges = append(edges, car.EdgeServiceItems)
	}
	if m.clearedservice_logs {
		edges = append(edges, car.EdgeServiceLogs)
	}
	if m.clearedservice_schedules {
		edges = append(edges, car.EdgeServiceSchedules)
	}
	if m.clearedmedia {
		edges = append(edges, car.EdgeMedia)
	}
	if m.clearedbanner_image {
		edges = append(edges, car.EdgeBannerImage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarMutation) EdgeCleared(name string) bool {
	switch name {
	case car.EdgeOwner:
		return m.clearedowner
	case car.EdgeDragSessions:
		return m.cleareddrag_sessions
	case car.EdgeFuelUps:
		return m.clearedfuel_ups
	case car.EdgeOdometerReadings:
		return m.clearedodometer_readings
	case car.EdgeServiceItems:
		return m.clearedservice_items
	case car.EdgeServiceLogs:
		return m.clearedservice_logs
	case car.EdgeServiceSchedules:
		return m.clearedservice_schedules
	case car.EdgeMedia:
		return m.clearedmedia
	case car.EdgeBannerImage:
		return m.clearedbanner_image
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarMutation) ClearEdge(name string) error {
	switch name {
	case car.EdgeOwner:
		m.ClearOwner()
		return nil
	case car.EdgeBannerImage:
		m.ClearBannerImage()
		return nil
	}
	return fmt.Errorf("unknown Car unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarMutation) ResetEdge(name string) error {
	switch name {
	case car.EdgeOwner:
		m.ResetOwner()
		return nil
	case car.EdgeDragSessions:
		m.ResetDragSessions()
		return nil
	case car.EdgeFuelUps:
		m.ResetFuelUps()
		return nil
	case car.EdgeOdometerReadings:
		m.ResetOdometerReadings()
		return nil
	case car.EdgeServiceItems:
		m.ResetServiceItems()
		return nil
	case car.EdgeServiceLogs:
		m.ResetServiceLogs()
		return nil
	case car.EdgeServiceSchedules:
		m.ResetServiceSchedules()
		return nil
	case car.EdgeMedia:
		m.ResetMedia()
		return nil
	case car.EdgeBannerImage:
		m.ResetBannerImage()
		return nil
	}
	return fmt.Errorf("unknown Car edge %s", name)
}

// DragResultMutation represents an operation that mutates the DragResult nodes in the graph.
type DragResultMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	create_time    *time.Time
	update_time    *time.Time
	unit           *dragresult.Unit
	value          *float64
	addvalue       *float64
	result         *float64
	addresult      *float64
	clearedFields  map[string]struct{}
	session        *uuid.UUID
	clearedsession bool
	done           bool
	oldValue       func(context.Context) (*DragResult, error)
	predicates     []predicate.DragResult
}

var _ ent.Mutation = (*DragResultMutation)(nil)

// dragresultOption allows management of the mutation configuration using functional options.
type dragresultOption func(*DragResultMutation)

// newDragResultMutation creates new mutation for the DragResult entity.
func newDragResultMutation(c config, op Op, opts ...dragresultOption) *DragResultMutation {
	m := &DragResultMutation{
		config:        c,
		op:            op,
		typ:           TypeDragResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDragResultID sets the ID field of the mutation.
func withDragResultID(id uuid.UUID) dragresultOption {
	return func(m *DragResultMutation) {
		var (
			err   error
			once  sync.Once
			value *DragResult
		)
		m.oldValue = func(ctx context.Context) (*DragResult, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DragResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDragResult sets the old DragResult of the mutation.
func withDragResult(node *DragResult) dragresultOption {
	return func(m *DragResultMutation) {
		m.oldValue = func(context.Context) (*DragResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DragResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DragResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DragResult entities.
func (m *DragResultMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DragResultMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DragResultMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DragResult.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *DragResultMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DragResultMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DragResult entity.
// If the DragResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DragResultMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DragResultMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DragResultMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DragResultMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DragResult entity.
// If the DragResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DragResultMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DragResultMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUnit sets the "unit" field.
func (m *DragResultMutation) SetUnit(d dragresult.Unit) {
	m.unit = &d
}

// Unit returns the value of the "unit" field in the mutation.
func (m *DragResultMutation) Unit() (r dragresult.Unit, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the DragResult entity.
// If the DragResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DragResultMutation) OldUnit(ctx context.Context) (v dragresult.Unit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *DragResultMutation) ResetUnit() {
	m.unit = nil
}

// SetValue sets the "value" field.
func (m *DragResultMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *DragResultMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the DragResult entity.
// If the DragResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DragResultMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *DragResultMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *DragResultMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *DragResultMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetResult sets the "result" field.
func (m *DragResultMutation) SetResult(f float64) {
	m.result = &f
	m.addresult = nil
}

// Result returns the value of the "result" field in the mutation.
func (m *DragResultMutation) Result() (r float64, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the DragResult entity.
// If the DragResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DragResultMutation) OldResult(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// AddResult adds f to the "result" field.
func (m *DragResultMutation) AddResult(f float64) {
	if m.addresult != nil {
		*m.addresult += f
	} else {
		m.addresult = &f
	}
}

// AddedResult returns the value that was added to the "result" field in this mutation.
func (m *DragResultMutation) AddedResult() (r float64, exists bool) {
	v := m.addresult
	if v == nil {
		return
	}
	return *v, true
}

// ResetResult resets all changes to the "result" field.
func (m *DragResultMutation) ResetResult() {
	m.result = nil
	m.addresult = nil
}

// SetSessionID sets the "session" edge to the DragSession entity by id.
func (m *DragResultMutation) SetSessionID(id uuid.UUID) {
	m.session = &id
}

// ClearSession clears the "session" edge to the DragSession entity.
func (m *DragResultMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared reports if the "session" edge to the DragSession entity was cleared.
func (m *DragResultMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionID returns the "session" edge ID in the mutation.
func (m *DragResultMutation) SessionID() (id uuid.UUID, exists bool) {
	if m.session != nil {
		return *m.session, true
	}
	return
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *DragResultMutation) SessionIDs() (ids []uuid.UUID) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *DragResultMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// Where appends a list predicates to the DragResultMutation builder.
func (m *DragResultMutation) Where(ps ...predicate.DragResult) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DragResultMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DragResultMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DragResult, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DragResultMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DragResultMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DragResult).
func (m *DragResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DragResultMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, dragresult.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, dragresult.FieldUpdateTime)
	}
	if m.unit != nil {
		fields = append(fields, dragresult.FieldUnit)
	}
	if m.value != nil {
		fields = append(fields, dragresult.FieldValue)
	}
	if m.result != nil {
		fields = append(fields, dragresult.FieldResult)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DragResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dragresult.FieldCreateTime:
		return m.CreateTime()
	case dragresult.FieldUpdateTime:
		return m.UpdateTime()
	case dragresult.FieldUnit:
		return m.Unit()
	case dragresult.FieldValue:
		return m.Value()
	case dragresult.FieldResult:
		return m.Result()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DragResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dragresult.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case dragresult.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case dragresult.FieldUnit:
		return m.OldUnit(ctx)
	case dragresult.FieldValue:
		return m.OldValue(ctx)
	case dragresult.FieldResult:
		return m.OldResult(ctx)
	}
	return nil, fmt.Errorf("unknown DragResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DragResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dragresult.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case dragresult.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case dragresult.FieldUnit:
		v, ok := value.(dragresult.Unit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case dragresult.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case dragresult.FieldResult:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	}
	return fmt.Errorf("unknown DragResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DragResultMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, dragresult.FieldValue)
	}
	if m.addresult != nil {
		fields = append(fields, dragresult.FieldResult)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DragResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dragresult.FieldValue:
		return m.AddedValue()
	case dragresult.FieldResult:
		return m.AddedResult()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DragResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dragresult.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case dragresult.FieldResult:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResult(v)
		return nil
	}
	return fmt.Errorf("unknown DragResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DragResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DragResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DragResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DragResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DragResultMutation) ResetField(name string) error {
	switch name {
	case dragresult.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case dragresult.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case dragresult.FieldUnit:
		m.ResetUnit()
		return nil
	case dragresult.FieldValue:
		m.ResetValue()
		return nil
	case dragresult.FieldResult:
		m.ResetResult()
		return nil
	}
	return fmt.Errorf("unknown DragResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DragResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.session != nil {
		edges = append(edges, dragresult.EdgeSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DragResultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dragresult.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DragResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DragResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DragResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsession {
		edges = append(edges, dragresult.EdgeSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DragResultMutation) EdgeCleared(name string) bool {
	switch name {
	case dragresult.EdgeSession:
		return m.clearedsession
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DragResultMutation) ClearEdge(name string) error {
	switch name {
	case dragresult.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown DragResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DragResultMutation) ResetEdge(name string) error {
	switch name {
	case dragresult.EdgeSession:
		m.ResetSession()
		return nil
	}
	return fmt.Errorf("unknown DragResult edge %s", name)
}

// DragSessionMutation represents an operation that mutates the DragSession nodes in the graph.
type DragSessionMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	create_time    *time.Time
	update_time    *time.Time
	title          *string
	notes          *string
	clearedFields  map[string]struct{}
	car            *uuid.UUID
	clearedcar     bool
	results        map[uuid.UUID]struct{}
	removedresults map[uuid.UUID]struct{}
	clearedresults bool
	done           bool
	oldValue       func(context.Context) (*DragSession, error)
	predicates     []predicate.DragSession
}

var _ ent.Mutation = (*DragSessionMutation)(nil)

// dragsessionOption allows management of the mutation configuration using functional options.
type dragsessionOption func(*DragSessionMutation)

// newDragSessionMutation creates new mutation for the DragSession entity.
func newDragSessionMutation(c config, op Op, opts ...dragsessionOption) *DragSessionMutation {
	m := &DragSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeDragSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDragSessionID sets the ID field of the mutation.
func withDragSessionID(id uuid.UUID) dragsessionOption {
	return func(m *DragSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *DragSession
		)
		m.oldValue = func(ctx context.Context) (*DragSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DragSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDragSession sets the old DragSession of the mutation.
func withDragSession(node *DragSession) dragsessionOption {
	return func(m *DragSessionMutation) {
		m.oldValue = func(context.Context) (*DragSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DragSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DragSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DragSession entities.
func (m *DragSessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DragSessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DragSessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DragSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *DragSessionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DragSessionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DragSession entity.
// If the DragSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DragSessionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DragSessionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DragSessionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DragSessionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DragSession entity.
// If the DragSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DragSessionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DragSessionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTitle sets the "title" field.
func (m *DragSessionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DragSessionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the DragSession entity.
// If the DragSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DragSessionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DragSessionMutation) ResetTitle() {
	m.title = nil
}

// SetNotes sets the "notes" field.
func (m *DragSessionMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *DragSessionMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the DragSession entity.
// If the DragSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DragSessionMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *DragSessionMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[dragsession.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *DragSessionMutation) NotesCleared() bool {
	_, ok := m.clearedFields[dragsession.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *DragSessionMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, dragsession.FieldNotes)
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *DragSessionMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *DragSessionMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *DragSessionMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *DragSessionMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *DragSessionMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *DragSessionMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// AddResultIDs adds the "results" edge to the DragResult entity by ids.
func (m *DragSessionMutation) AddResultIDs(ids ...uuid.UUID) {
	if m.results == nil {
		m.results = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.results[ids[i]] = struct{}{}
	}
}

// ClearResults clears the "results" edge to the DragResult entity.
func (m *DragSessionMutation) ClearResults() {
	m.clearedresults = true
}

// ResultsCleared reports if the "results" edge to the DragResult entity was cleared.
func (m *DragSessionMutation) ResultsCleared() bool {
	return m.clearedresults
}

// RemoveResultIDs removes the "results" edge to the DragResult entity by IDs.
func (m *DragSessionMutation) RemoveResultIDs(ids ...uuid.UUID) {
	if m.removedresults == nil {
		m.removedresults = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.results, ids[i])
		m.removedresults[ids[i]] = struct{}{}
	}
}

// RemovedResults returns the removed IDs of the "results" edge to the DragResult entity.
func (m *DragSessionMutation) RemovedResultsIDs() (ids []uuid.UUID) {
	for id := range m.removedresults {
		ids = append(ids, id)
	}
	return
}

// ResultsIDs returns the "results" edge IDs in the mutation.
func (m *DragSessionMutation) ResultsIDs() (ids []uuid.UUID) {
	for id := range m.results {
		ids = append(ids, id)
	}
	return
}

// ResetResults resets all changes to the "results" edge.
func (m *DragSessionMutation) ResetResults() {
	m.results = nil
	m.clearedresults = false
	m.removedresults = nil
}

// Where appends a list predicates to the DragSessionMutation builder.
func (m *DragSessionMutation) Where(ps ...predicate.DragSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DragSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DragSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DragSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DragSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DragSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DragSession).
func (m *DragSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DragSessionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, dragsession.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, dragsession.FieldUpdateTime)
	}
	if m.title != nil {
		fields = append(fields, dragsession.FieldTitle)
	}
	if m.notes != nil {
		fields = append(fields, dragsession.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DragSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dragsession.FieldCreateTime:
		return m.CreateTime()
	case dragsession.FieldUpdateTime:
		return m.UpdateTime()
	case dragsession.FieldTitle:
		return m.Title()
	case dragsession.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DragSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dragsession.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case dragsession.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case dragsession.FieldTitle:
		return m.OldTitle(ctx)
	case dragsession.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown DragSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DragSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dragsession.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case dragsession.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case dragsession.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dragsession.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown DragSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DragSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DragSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DragSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DragSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DragSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dragsession.FieldNotes) {
		fields = append(fields, dragsession.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DragSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DragSessionMutation) ClearField(name string) error {
	switch name {
	case dragsession.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown DragSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DragSessionMutation) ResetField(name string) error {
	switch name {
	case dragsession.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case dragsession.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case dragsession.FieldTitle:
		m.ResetTitle()
		return nil
	case dragsession.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown DragSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DragSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.car != nil {
		edges = append(edges, dragsession.EdgeCar)
	}
	if m.results != nil {
		edges = append(edges, dragsession.EdgeResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DragSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dragsession.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case dragsession.EdgeResults:
		ids := make([]ent.Value, 0, len(m.results))
		for id := range m.results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DragSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedresults != nil {
		edges = append(edges, dragsession.EdgeResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DragSessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dragsession.EdgeResults:
		ids := make([]ent.Value, 0, len(m.removedresults))
		for id := range m.removedresults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DragSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcar {
		edges = append(edges, dragsession.EdgeCar)
	}
	if m.clearedresults {
		edges = append(edges, dragsession.EdgeResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DragSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case dragsession.EdgeCar:
		return m.clearedcar
	case dragsession.EdgeResults:
		return m.clearedresults
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DragSessionMutation) ClearEdge(name string) error {
	switch name {
	case dragsession.EdgeCar:
		m.ClearCar()
		return nil
	}
	return fmt.Errorf("unknown DragSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DragSessionMutation) ResetEdge(name string) error {
	switch name {
	case dragsession.EdgeCar:
		m.ResetCar()
		return nil
	case dragsession.EdgeResults:
		m.ResetResults()
		return nil
	}
	return fmt.Errorf("unknown DragSession edge %s", name)
}

// FuelUpMutation represents an operation that mutates the FuelUp nodes in the graph.
type FuelUpMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	create_time             *time.Time
	update_time             *time.Time
	occurred_at             *time.Time
	station                 *string
	amount_liters           *float64
	addamount_liters        *float64
	cost                    *float64
	addcost                 *float64
	fuel_category           *fuelup.FuelCategory
	octane_rating           *fuelup.OctaneRating
	is_full_tank            *bool
	notes                   *string
	clearedFields           map[string]struct{}
	car                     *uuid.UUID
	clearedcar              bool
	odometer_reading        *uuid.UUID
	clearedodometer_reading bool
	done                    bool
	oldValue                func(context.Context) (*FuelUp, error)
	predicates              []predicate.FuelUp
}

var _ ent.Mutation = (*FuelUpMutation)(nil)

// fuelupOption allows management of the mutation configuration using functional options.
type fuelupOption func(*FuelUpMutation)

// newFuelUpMutation creates new mutation for the FuelUp entity.
func newFuelUpMutation(c config, op Op, opts ...fuelupOption) *FuelUpMutation {
	m := &FuelUpMutation{
		config:        c,
		op:            op,
		typ:           TypeFuelUp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFuelUpID sets the ID field of the mutation.
func withFuelUpID(id uuid.UUID) fuelupOption {
	return func(m *FuelUpMutation) {
		var (
			err   error
			once  sync.Once
			value *FuelUp
		)
		m.oldValue = func(ctx context.Context) (*FuelUp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FuelUp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFuelUp sets the old FuelUp of the mutation.
func withFuelUp(node *FuelUp) fuelupOption {
	return func(m *FuelUpMutation) {
		m.oldValue = func(context.Context) (*FuelUp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FuelUpMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FuelUpMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FuelUp entities.
func (m *FuelUpMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FuelUpMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FuelUpMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FuelUp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *FuelUpMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *FuelUpMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *FuelUpMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *FuelUpMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *FuelUpMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *FuelUpMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetOccurredAt sets the "occurred_at" field.
func (m *FuelUpMutation) SetOccurredAt(t time.Time) {
	m.occurred_at = &t
}

// OccurredAt returns the value of the "occurred_at" field in the mutation.
func (m *FuelUpMutation) OccurredAt() (r time.Time, exists bool) {
	v := m.occurred_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOccurredAt returns the old "occurred_at" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldOccurredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOccurredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOccurredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccurredAt: %w", err)
	}
	return oldValue.OccurredAt, nil
}

// ResetOccurredAt resets all changes to the "occurred_at" field.
func (m *FuelUpMutation) ResetOccurredAt() {
	m.occurred_at = nil
}

// SetStation sets the "station" field.
func (m *FuelUpMutation) SetStation(s string) {
	m.station = &s
}

// Station returns the value of the "station" field in the mutation.
func (m *FuelUpMutation) Station() (r string, exists bool) {
	v := m.station
	if v == nil {
		return
	}
	return *v, true
}

// OldStation returns the old "station" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldStation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStation: %w", err)
	}
	return oldValue.Station, nil
}

// ResetStation resets all changes to the "station" field.
func (m *FuelUpMutation) ResetStation() {
	m.station = nil
}

// SetAmountLiters sets the "amount_liters" field.
func (m *FuelUpMutation) SetAmountLiters(f float64) {
	m.amount_liters = &f
	m.addamount_liters = nil
}

// AmountLiters returns the value of the "amount_liters" field in the mutation.
func (m *FuelUpMutation) AmountLiters() (r float64, exists bool) {
	v := m.amount_liters
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountLiters returns the old "amount_liters" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldAmountLiters(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountLiters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountLiters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountLiters: %w", err)
	}
	return oldValue.AmountLiters, nil
}

// AddAmountLiters adds f to the "amount_liters" field.
func (m *FuelUpMutation) AddAmountLiters(f float64) {
	if m.addamount_liters != nil {
		*m.addamount_liters += f
	} else {
		m.addamount_liters = &f
	}
}

// AddedAmountLiters returns the value that was added to the "amount_liters" field in this mutation.
func (m *FuelUpMutation) AddedAmountLiters() (r float64, exists bool) {
	v := m.addamount_liters
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmountLiters resets all changes to the "amount_liters" field.
func (m *FuelUpMutation) ResetAmountLiters() {
	m.amount_liters = nil
	m.addamount_liters = nil
}

// SetCost sets the "cost" field.
func (m *FuelUpMutation) SetCost(f float64) {
	m.cost = &f
	m.addcost = nil
}

// Cost returns the value of the "cost" field in the mutation.
func (m *FuelUpMutation) Cost() (r float64, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old "cost" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// AddCost adds f to the "cost" field.
func (m *FuelUpMutation) AddCost(f float64) {
	if m.addcost != nil {
		*m.addcost += f
	} else {
		m.addcost = &f
	}
}

// AddedCost returns the value that was added to the "cost" field in this mutation.
func (m *FuelUpMutation) AddedCost() (r float64, exists bool) {
	v := m.addcost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCost resets all changes to the "cost" field.
func (m *FuelUpMutation) ResetCost() {
	m.cost = nil
	m.addcost = nil
}

// SetFuelCategory sets the "fuel_category" field.
func (m *FuelUpMutation) SetFuelCategory(fc fuelup.FuelCategory) {
	m.fuel_category = &fc
}

// FuelCategory returns the value of the "fuel_category" field in the mutation.
func (m *FuelUpMutation) FuelCategory() (r fuelup.FuelCategory, exists bool) {
	v := m.fuel_category
	if v == nil {
		return
	}
	return *v, true
}

// OldFuelCategory returns the old "fuel_category" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldFuelCategory(ctx context.Context) (v fuelup.FuelCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFuelCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFuelCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFuelCategory: %w", err)
	}
	return oldValue.FuelCategory, nil
}

// ResetFuelCategory resets all changes to the "fuel_category" field.
func (m *FuelUpMutation) ResetFuelCategory() {
	m.fuel_category = nil
}

// SetOctaneRating sets the "octane_rating" field.
func (m *FuelUpMutation) SetOctaneRating(fr fuelup.OctaneRating) {
	m.octane_rating = &fr
}

// OctaneRating returns the value of the "octane_rating" field in the mutation.
func (m *FuelUpMutation) OctaneRating() (r fuelup.OctaneRating, exists bool) {
	v := m.octane_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldOctaneRating returns the old "octane_rating" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldOctaneRating(ctx context.Context) (v *fuelup.OctaneRating, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOctaneRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOctaneRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOctaneRating: %w", err)
	}
	return oldValue.OctaneRating, nil
}

// ClearOctaneRating clears the value of the "octane_rating" field.
func (m *FuelUpMutation) ClearOctaneRating() {
	m.octane_rating = nil
	m.clearedFields[fuelup.FieldOctaneRating] = struct{}{}
}

// OctaneRatingCleared returns if the "octane_rating" field was cleared in this mutation.
func (m *FuelUpMutation) OctaneRatingCleared() bool {
	_, ok := m.clearedFields[fuelup.FieldOctaneRating]
	return ok
}

// ResetOctaneRating resets all changes to the "octane_rating" field.
func (m *FuelUpMutation) ResetOctaneRating() {
	m.octane_rating = nil
	delete(m.clearedFields, fuelup.FieldOctaneRating)
}

// SetIsFullTank sets the "is_full_tank" field.
func (m *FuelUpMutation) SetIsFullTank(b bool) {
	m.is_full_tank = &b
}

// IsFullTank returns the value of the "is_full_tank" field in the mutation.
func (m *FuelUpMutation) IsFullTank() (r bool, exists bool) {
	v := m.is_full_tank
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFullTank returns the old "is_full_tank" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldIsFullTank(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFullTank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFullTank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFullTank: %w", err)
	}
	return oldValue.IsFullTank, nil
}

// ResetIsFullTank resets all changes to the "is_full_tank" field.
func (m *FuelUpMutation) ResetIsFullTank() {
	m.is_full_tank = nil
}

// SetNotes sets the "notes" field.
func (m *FuelUpMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *FuelUpMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the FuelUp entity.
// If the FuelUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FuelUpMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *FuelUpMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[fuelup.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *FuelUpMutation) NotesCleared() bool {
	_, ok := m.clearedFields[fuelup.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *FuelUpMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, fuelup.FieldNotes)
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *FuelUpMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *FuelUpMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *FuelUpMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *FuelUpMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *FuelUpMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *FuelUpMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// SetOdometerReadingID sets the "odometer_reading" edge to the OdometerReading entity by id.
func (m *FuelUpMutation) SetOdometerReadingID(id uuid.UUID) {
	m.odometer_reading = &id
}

// ClearOdometerReading clears the "odometer_reading" edge to the OdometerReading entity.
func (m *FuelUpMutation) ClearOdometerReading() {
	m.clearedodometer_reading = true
}

// OdometerReadingCleared reports if the "odometer_reading" edge to the OdometerReading entity was cleared.
func (m *FuelUpMutation) OdometerReadingCleared() bool {
	return m.clearedodometer_reading
}

// OdometerReadingID returns the "odometer_reading" edge ID in the mutation.
func (m *FuelUpMutation) OdometerReadingID() (id uuid.UUID, exists bool) {
	if m.odometer_reading != nil {
		return *m.odometer_reading, true
	}
	return
}

// OdometerReadingIDs returns the "odometer_reading" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OdometerReadingID instead. It exists only for internal usage by the builders.
func (m *FuelUpMutation) OdometerReadingIDs() (ids []uuid.UUID) {
	if id := m.odometer_reading; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOdometerReading resets all changes to the "odometer_reading" edge.
func (m *FuelUpMutation) ResetOdometerReading() {
	m.odometer_reading = nil
	m.clearedodometer_reading = false
}

// Where appends a list predicates to the FuelUpMutation builder.
func (m *FuelUpMutation) Where(ps ...predicate.FuelUp) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FuelUpMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FuelUpMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FuelUp, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FuelUpMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FuelUpMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FuelUp).
func (m *FuelUpMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FuelUpMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, fuelup.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, fuelup.FieldUpdateTime)
	}
	if m.occurred_at != nil {
		fields = append(fields, fuelup.FieldOccurredAt)
	}
	if m.station != nil {
		fields = append(fields, fuelup.FieldStation)
	}
	if m.amount_liters != nil {
		fields = append(fields, fuelup.FieldAmountLiters)
	}
	if m.cost != nil {
		fields = append(fields, fuelup.FieldCost)
	}
	if m.fuel_category != nil {
		fields = append(fields, fuelup.FieldFuelCategory)
	}
	if m.octane_rating != nil {
		fields = append(fields, fuelup.FieldOctaneRating)
	}
	if m.is_full_tank != nil {
		fields = append(fields, fuelup.FieldIsFullTank)
	}
	if m.notes != nil {
		fields = append(fields, fuelup.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FuelUpMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fuelup.FieldCreateTime:
		return m.CreateTime()
	case fuelup.FieldUpdateTime:
		return m.UpdateTime()
	case fuelup.FieldOccurredAt:
		return m.OccurredAt()
	case fuelup.FieldStation:
		return m.Station()
	case fuelup.FieldAmountLiters:
		return m.AmountLiters()
	case fuelup.FieldCost:
		return m.Cost()
	case fuelup.FieldFuelCategory:
		return m.FuelCategory()
	case fuelup.FieldOctaneRating:
		return m.OctaneRating()
	case fuelup.FieldIsFullTank:
		return m.IsFullTank()
	case fuelup.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FuelUpMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fuelup.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case fuelup.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case fuelup.FieldOccurredAt:
		return m.OldOccurredAt(ctx)
	case fuelup.FieldStation:
		return m.OldStation(ctx)
	case fuelup.FieldAmountLiters:
		return m.OldAmountLiters(ctx)
	case fuelup.FieldCost:
		return m.OldCost(ctx)
	case fuelup.FieldFuelCategory:
		return m.OldFuelCategory(ctx)
	case fuelup.FieldOctaneRating:
		return m.OldOctaneRating(ctx)
	case fuelup.FieldIsFullTank:
		return m.OldIsFullTank(ctx)
	case fuelup.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown FuelUp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FuelUpMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fuelup.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case fuelup.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case fuelup.FieldOccurredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccurredAt(v)
		return nil
	case fuelup.FieldStation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStation(v)
		return nil
	case fuelup.FieldAmountLiters:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountLiters(v)
		return nil
	case fuelup.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	case fuelup.FieldFuelCategory:
		v, ok := value.(fuelup.FuelCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFuelCategory(v)
		return nil
	case fuelup.FieldOctaneRating:
		v, ok := value.(fuelup.OctaneRating)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOctaneRating(v)
		return nil
	case fuelup.FieldIsFullTank:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFullTank(v)
		return nil
	case fuelup.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown FuelUp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FuelUpMutation) AddedFields() []string {
	var fields []string
	if m.addamount_liters != nil {
		fields = append(fields, fuelup.FieldAmountLiters)
	}
	if m.addcost != nil {
		fields = append(fields, fuelup.FieldCost)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FuelUpMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fuelup.FieldAmountLiters:
		return m.AddedAmountLiters()
	case fuelup.FieldCost:
		return m.AddedCost()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FuelUpMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fuelup.FieldAmountLiters:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountLiters(v)
		return nil
	case fuelup.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCost(v)
		return nil
	}
	return fmt.Errorf("unknown FuelUp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FuelUpMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fuelup.FieldOctaneRating) {
		fields = append(fields, fuelup.FieldOctaneRating)
	}
	if m.FieldCleared(fuelup.FieldNotes) {
		fields = append(fields, fuelup.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FuelUpMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FuelUpMutation) ClearField(name string) error {
	switch name {
	case fuelup.FieldOctaneRating:
		m.ClearOctaneRating()
		return nil
	case fuelup.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown FuelUp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FuelUpMutation) ResetField(name string) error {
	switch name {
	case fuelup.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case fuelup.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case fuelup.FieldOccurredAt:
		m.ResetOccurredAt()
		return nil
	case fuelup.FieldStation:
		m.ResetStation()
		return nil
	case fuelup.FieldAmountLiters:
		m.ResetAmountLiters()
		return nil
	case fuelup.FieldCost:
		m.ResetCost()
		return nil
	case fuelup.FieldFuelCategory:
		m.ResetFuelCategory()
		return nil
	case fuelup.FieldOctaneRating:
		m.ResetOctaneRating()
		return nil
	case fuelup.FieldIsFullTank:
		m.ResetIsFullTank()
		return nil
	case fuelup.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown FuelUp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FuelUpMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.car != nil {
		edges = append(edges, fuelup.EdgeCar)
	}
	if m.odometer_reading != nil {
		edges = append(edges, fuelup.EdgeOdometerReading)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FuelUpMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fuelup.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case fuelup.EdgeOdometerReading:
		if id := m.odometer_reading; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FuelUpMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FuelUpMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FuelUpMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcar {
		edges = append(edges, fuelup.EdgeCar)
	}
	if m.clearedodometer_reading {
		edges = append(edges, fuelup.EdgeOdometerReading)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FuelUpMutation) EdgeCleared(name string) bool {
	switch name {
	case fuelup.EdgeCar:
		return m.clearedcar
	case fuelup.EdgeOdometerReading:
		return m.clearedodometer_reading
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FuelUpMutation) ClearEdge(name string) error {
	switch name {
	case fuelup.EdgeCar:
		m.ClearCar()
		return nil
	case fuelup.EdgeOdometerReading:
		m.ClearOdometerReading()
		return nil
	}
	return fmt.Errorf("unknown FuelUp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FuelUpMutation) ResetEdge(name string) error {
	switch name {
	case fuelup.EdgeCar:
		m.ResetCar()
		return nil
	case fuelup.EdgeOdometerReading:
		m.ResetOdometerReading()
		return nil
	}
	return fmt.Errorf("unknown FuelUp edge %s", name)
}

// MediaMutation represents an operation that mutates the Media nodes in the graph.
type MediaMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	clearedFields map[string]struct{}
	car           *uuid.UUID
	clearedcar    bool
	done          bool
	oldValue      func(context.Context) (*Media, error)
	predicates    []predicate.Media
}

var _ ent.Mutation = (*MediaMutation)(nil)

// mediaOption allows management of the mutation configuration using functional options.
type mediaOption func(*MediaMutation)

// newMediaMutation creates new mutation for the Media entity.
func newMediaMutation(c config, op Op, opts ...mediaOption) *MediaMutation {
	m := &MediaMutation{
		config:        c,
		op:            op,
		typ:           TypeMedia,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMediaID sets the ID field of the mutation.
func withMediaID(id uuid.UUID) mediaOption {
	return func(m *MediaMutation) {
		var (
			err   error
			once  sync.Once
			value *Media
		)
		m.oldValue = func(ctx context.Context) (*Media, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Media.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedia sets the old Media of the mutation.
func withMedia(node *Media) mediaOption {
	return func(m *MediaMutation) {
		m.oldValue = func(context.Context) (*Media, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MediaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MediaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Media entities.
func (m *MediaMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MediaMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MediaMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Media.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *MediaMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *MediaMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *MediaMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *MediaMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *MediaMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *MediaMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *MediaMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *MediaMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *MediaMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *MediaMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *MediaMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *MediaMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// Where appends a list predicates to the MediaMutation builder.
func (m *MediaMutation) Where(ps ...predicate.Media) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MediaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MediaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Media, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MediaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MediaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Media).
func (m *MediaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MediaMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.create_time != nil {
		fields = append(fields, media.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, media.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MediaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case media.FieldCreateTime:
		return m.CreateTime()
	case media.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MediaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case media.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case media.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Media field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case media.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case media.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MediaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MediaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Media numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MediaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MediaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MediaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Media nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MediaMutation) ResetField(name string) error {
	switch name {
	case media.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case media.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MediaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.car != nil {
		edges = append(edges, media.EdgeCar)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MediaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case media.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MediaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MediaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MediaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcar {
		edges = append(edges, media.EdgeCar)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MediaMutation) EdgeCleared(name string) bool {
	switch name {
	case media.EdgeCar:
		return m.clearedcar
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MediaMutation) ClearEdge(name string) error {
	switch name {
	case media.EdgeCar:
		m.ClearCar()
		return nil
	}
	return fmt.Errorf("unknown Media unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MediaMutation) ResetEdge(name string) error {
	switch name {
	case media.EdgeCar:
		m.ResetCar()
		return nil
	}
	return fmt.Errorf("unknown Media edge %s", name)
}

// OdometerReadingMutation represents an operation that mutates the OdometerReading nodes in the graph.
type OdometerReadingMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	create_time        *time.Time
	update_time        *time.Time
	reading_km         *float64
	addreading_km      *float64
	notes              *string
	clearedFields      map[string]struct{}
	car                *uuid.UUID
	clearedcar         bool
	fuel_up            *uuid.UUID
	clearedfuel_up     bool
	service_log        *uuid.UUID
	clearedservice_log bool
	done               bool
	oldValue           func(context.Context) (*OdometerReading, error)
	predicates         []predicate.OdometerReading
}

var _ ent.Mutation = (*OdometerReadingMutation)(nil)

// odometerreadingOption allows management of the mutation configuration using functional options.
type odometerreadingOption func(*OdometerReadingMutation)

// newOdometerReadingMutation creates new mutation for the OdometerReading entity.
func newOdometerReadingMutation(c config, op Op, opts ...odometerreadingOption) *OdometerReadingMutation {
	m := &OdometerReadingMutation{
		config:        c,
		op:            op,
		typ:           TypeOdometerReading,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOdometerReadingID sets the ID field of the mutation.
func withOdometerReadingID(id uuid.UUID) odometerreadingOption {
	return func(m *OdometerReadingMutation) {
		var (
			err   error
			once  sync.Once
			value *OdometerReading
		)
		m.oldValue = func(ctx context.Context) (*OdometerReading, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OdometerReading.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOdometerReading sets the old OdometerReading of the mutation.
func withOdometerReading(node *OdometerReading) odometerreadingOption {
	return func(m *OdometerReadingMutation) {
		m.oldValue = func(context.Context) (*OdometerReading, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OdometerReadingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OdometerReadingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OdometerReading entities.
func (m *OdometerReadingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OdometerReadingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OdometerReadingMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OdometerReading.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *OdometerReadingMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OdometerReadingMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OdometerReading entity.
// If the OdometerReading object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OdometerReadingMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OdometerReadingMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OdometerReadingMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OdometerReadingMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OdometerReading entity.
// If the OdometerReading object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OdometerReadingMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OdometerReadingMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetReadingKm sets the "reading_km" field.
func (m *OdometerReadingMutation) SetReadingKm(f float64) {
	m.reading_km = &f
	m.addreading_km = nil
}

// ReadingKm returns the value of the "reading_km" field in the mutation.
func (m *OdometerReadingMutation) ReadingKm() (r float64, exists bool) {
	v := m.reading_km
	if v == nil {
		return
	}
	return *v, true
}

// OldReadingKm returns the old "reading_km" field's value of the OdometerReading entity.
// If the OdometerReading object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OdometerReadingMutation) OldReadingKm(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadingKm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadingKm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadingKm: %w", err)
	}
	return oldValue.ReadingKm, nil
}

// AddReadingKm adds f to the "reading_km" field.
func (m *OdometerReadingMutation) AddReadingKm(f float64) {
	if m.addreading_km != nil {
		*m.addreading_km += f
	} else {
		m.addreading_km = &f
	}
}

// AddedReadingKm returns the value that was added to the "reading_km" field in this mutation.
func (m *OdometerReadingMutation) AddedReadingKm() (r float64, exists bool) {
	v := m.addreading_km
	if v == nil {
		return
	}
	return *v, true
}

// ResetReadingKm resets all changes to the "reading_km" field.
func (m *OdometerReadingMutation) ResetReadingKm() {
	m.reading_km = nil
	m.addreading_km = nil
}

// SetNotes sets the "notes" field.
func (m *OdometerReadingMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *OdometerReadingMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the OdometerReading entity.
// If the OdometerReading object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OdometerReadingMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *OdometerReadingMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[odometerreading.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *OdometerReadingMutation) NotesCleared() bool {
	_, ok := m.clearedFields[odometerreading.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *OdometerReadingMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, odometerreading.FieldNotes)
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *OdometerReadingMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *OdometerReadingMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *OdometerReadingMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *OdometerReadingMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *OdometerReadingMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *OdometerReadingMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// SetFuelUpID sets the "fuel_up" edge to the FuelUp entity by id.
func (m *OdometerReadingMutation) SetFuelUpID(id uuid.UUID) {
	m.fuel_up = &id
}

// ClearFuelUp clears the "fuel_up" edge to the FuelUp entity.
func (m *OdometerReadingMutation) ClearFuelUp() {
	m.clearedfuel_up = true
}

// FuelUpCleared reports if the "fuel_up" edge to the FuelUp entity was cleared.
func (m *OdometerReadingMutation) FuelUpCleared() bool {
	return m.clearedfuel_up
}

// FuelUpID returns the "fuel_up" edge ID in the mutation.
func (m *OdometerReadingMutation) FuelUpID() (id uuid.UUID, exists bool) {
	if m.fuel_up != nil {
		return *m.fuel_up, true
	}
	return
}

// FuelUpIDs returns the "fuel_up" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FuelUpID instead. It exists only for internal usage by the builders.
func (m *OdometerReadingMutation) FuelUpIDs() (ids []uuid.UUID) {
	if id := m.fuel_up; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFuelUp resets all changes to the "fuel_up" edge.
func (m *OdometerReadingMutation) ResetFuelUp() {
	m.fuel_up = nil
	m.clearedfuel_up = false
}

// SetServiceLogID sets the "service_log" edge to the ServiceLog entity by id.
func (m *OdometerReadingMutation) SetServiceLogID(id uuid.UUID) {
	m.service_log = &id
}

// ClearServiceLog clears the "service_log" edge to the ServiceLog entity.
func (m *OdometerReadingMutation) ClearServiceLog() {
	m.clearedservice_log = true
}

// ServiceLogCleared reports if the "service_log" edge to the ServiceLog entity was cleared.
func (m *OdometerReadingMutation) ServiceLogCleared() bool {
	return m.clearedservice_log
}

// ServiceLogID returns the "service_log" edge ID in the mutation.
func (m *OdometerReadingMutation) ServiceLogID() (id uuid.UUID, exists bool) {
	if m.service_log != nil {
		return *m.service_log, true
	}
	return
}

// ServiceLogIDs returns the "service_log" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceLogID instead. It exists only for internal usage by the builders.
func (m *OdometerReadingMutation) ServiceLogIDs() (ids []uuid.UUID) {
	if id := m.service_log; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceLog resets all changes to the "service_log" edge.
func (m *OdometerReadingMutation) ResetServiceLog() {
	m.service_log = nil
	m.clearedservice_log = false
}

// Where appends a list predicates to the OdometerReadingMutation builder.
func (m *OdometerReadingMutation) Where(ps ...predicate.OdometerReading) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OdometerReadingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OdometerReadingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OdometerReading, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OdometerReadingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OdometerReadingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OdometerReading).
func (m *OdometerReadingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OdometerReadingMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, odometerreading.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, odometerreading.FieldUpdateTime)
	}
	if m.reading_km != nil {
		fields = append(fields, odometerreading.FieldReadingKm)
	}
	if m.notes != nil {
		fields = append(fields, odometerreading.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OdometerReadingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case odometerreading.FieldCreateTime:
		return m.CreateTime()
	case odometerreading.FieldUpdateTime:
		return m.UpdateTime()
	case odometerreading.FieldReadingKm:
		return m.ReadingKm()
	case odometerreading.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OdometerReadingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case odometerreading.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case odometerreading.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case odometerreading.FieldReadingKm:
		return m.OldReadingKm(ctx)
	case odometerreading.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown OdometerReading field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OdometerReadingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case odometerreading.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case odometerreading.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case odometerreading.FieldReadingKm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadingKm(v)
		return nil
	case odometerreading.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown OdometerReading field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OdometerReadingMutation) AddedFields() []string {
	var fields []string
	if m.addreading_km != nil {
		fields = append(fields, odometerreading.FieldReadingKm)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OdometerReadingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case odometerreading.FieldReadingKm:
		return m.AddedReadingKm()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OdometerReadingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case odometerreading.FieldReadingKm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReadingKm(v)
		return nil
	}
	return fmt.Errorf("unknown OdometerReading numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OdometerReadingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(odometerreading.FieldNotes) {
		fields = append(fields, odometerreading.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OdometerReadingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OdometerReadingMutation) ClearField(name string) error {
	switch name {
	case odometerreading.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown OdometerReading nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OdometerReadingMutation) ResetField(name string) error {
	switch name {
	case odometerreading.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case odometerreading.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case odometerreading.FieldReadingKm:
		m.ResetReadingKm()
		return nil
	case odometerreading.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown OdometerReading field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OdometerReadingMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.car != nil {
		edges = append(edges, odometerreading.EdgeCar)
	}
	if m.fuel_up != nil {
		edges = append(edges, odometerreading.EdgeFuelUp)
	}
	if m.service_log != nil {
		edges = append(edges, odometerreading.EdgeServiceLog)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OdometerReadingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case odometerreading.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case odometerreading.EdgeFuelUp:
		if id := m.fuel_up; id != nil {
			return []ent.Value{*id}
		}
	case odometerreading.EdgeServiceLog:
		if id := m.service_log; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OdometerReadingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OdometerReadingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OdometerReadingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcar {
		edges = append(edges, odometerreading.EdgeCar)
	}
	if m.clearedfuel_up {
		edges = append(edges, odometerreading.EdgeFuelUp)
	}
	if m.clearedservice_log {
		edges = append(edges, odometerreading.EdgeServiceLog)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OdometerReadingMutation) EdgeCleared(name string) bool {
	switch name {
	case odometerreading.EdgeCar:
		return m.clearedcar
	case odometerreading.EdgeFuelUp:
		return m.clearedfuel_up
	case odometerreading.EdgeServiceLog:
		return m.clearedservice_log
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OdometerReadingMutation) ClearEdge(name string) error {
	switch name {
	case odometerreading.EdgeCar:
		m.ClearCar()
		return nil
	case odometerreading.EdgeFuelUp:
		m.ClearFuelUp()
		return nil
	case odometerreading.EdgeServiceLog:
		m.ClearServiceLog()
		return nil
	}
	return fmt.Errorf("unknown OdometerReading unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OdometerReadingMutation) ResetEdge(name string) error {
	switch name {
	case odometerreading.EdgeCar:
		m.ResetCar()
		return nil
	case odometerreading.EdgeFuelUp:
		m.ResetFuelUp()
		return nil
	case odometerreading.EdgeServiceLog:
		m.ResetServiceLog()
		return nil
	}
	return fmt.Errorf("unknown OdometerReading edge %s", name)
}

// ProfileMutation represents an operation that mutates the Profile nodes in the graph.
type ProfileMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	create_time           *time.Time
	update_time           *time.Time
	username              *string
	first_name            *string
	last_name             *string
	picture               *uuid.UUID
	currency_code         *string
	fuel_volume_unit      *profile.FuelVolumeUnit
	distance_unit         *profile.DistanceUnit
	fuel_consumption_unit *profile.FuelConsumptionUnit
	temperature_unit      *profile.TemperatureUnit
	visibility            *profile.Visibility
	clearedFields         map[string]struct{}
	user                  *uuid.UUID
	cleareduser           bool
	done                  bool
	oldValue              func(context.Context) (*Profile, error)
	predicates            []predicate.Profile
}

var _ ent.Mutation = (*ProfileMutation)(nil)

// profileOption allows management of the mutation configuration using functional options.
type profileOption func(*ProfileMutation)

// newProfileMutation creates new mutation for the Profile entity.
func newProfileMutation(c config, op Op, opts ...profileOption) *ProfileMutation {
	m := &ProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfileID sets the ID field of the mutation.
func withProfileID(id uuid.UUID) profileOption {
	return func(m *ProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *Profile
		)
		m.oldValue = func(ctx context.Context) (*Profile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Profile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfile sets the old Profile of the mutation.
func withProfile(node *Profile) profileOption {
	return func(m *ProfileMutation) {
		m.oldValue = func(context.Context) (*Profile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Profile entities.
func (m *ProfileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Profile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ProfileMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProfileMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProfileMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProfileMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProfileMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProfileMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUsername sets the "username" field.
func (m *ProfileMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *ProfileMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *ProfileMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[profile.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *ProfileMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[profile.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *ProfileMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, profile.FieldUsername)
}

// SetFirstName sets the "first_name" field.
func (m *ProfileMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *ProfileMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldFirstName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *ProfileMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[profile.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *ProfileMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[profile.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *ProfileMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, profile.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *ProfileMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *ProfileMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldLastName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *ProfileMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[profile.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *ProfileMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[profile.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *ProfileMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, profile.FieldLastName)
}

// SetPicture sets the "picture" field.
func (m *ProfileMutation) SetPicture(u uuid.UUID) {
	m.picture = &u
}

// Picture returns the value of the "picture" field in the mutation.
func (m *ProfileMutation) Picture() (r uuid.UUID, exists bool) {
	v := m.picture
	if v == nil {
		return
	}
	return *v, true
}

// OldPicture returns the old "picture" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldPicture(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicture: %w", err)
	}
	return oldValue.Picture, nil
}

// ClearPicture clears the value of the "picture" field.
func (m *ProfileMutation) ClearPicture() {
	m.picture = nil
	m.clearedFields[profile.FieldPicture] = struct{}{}
}

// PictureCleared returns if the "picture" field was cleared in this mutation.
func (m *ProfileMutation) PictureCleared() bool {
	_, ok := m.clearedFields[profile.FieldPicture]
	return ok
}

// ResetPicture resets all changes to the "picture" field.
func (m *ProfileMutation) ResetPicture() {
	m.picture = nil
	delete(m.clearedFields, profile.FieldPicture)
}

// SetCurrencyCode sets the "currency_code" field.
func (m *ProfileMutation) SetCurrencyCode(s string) {
	m.currency_code = &s
}

// CurrencyCode returns the value of the "currency_code" field in the mutation.
func (m *ProfileMutation) CurrencyCode() (r string, exists bool) {
	v := m.currency_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrencyCode returns the old "currency_code" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldCurrencyCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrencyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrencyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrencyCode: %w", err)
	}
	return oldValue.CurrencyCode, nil
}

// ClearCurrencyCode clears the value of the "currency_code" field.
func (m *ProfileMutation) ClearCurrencyCode() {
	m.currency_code = nil
	m.clearedFields[profile.FieldCurrencyCode] = struct{}{}
}

// CurrencyCodeCleared returns if the "currency_code" field was cleared in this mutation.
func (m *ProfileMutation) CurrencyCodeCleared() bool {
	_, ok := m.clearedFields[profile.FieldCurrencyCode]
	return ok
}

// ResetCurrencyCode resets all changes to the "currency_code" field.
func (m *ProfileMutation) ResetCurrencyCode() {
	m.currency_code = nil
	delete(m.clearedFields, profile.FieldCurrencyCode)
}

// SetFuelVolumeUnit sets the "fuel_volume_unit" field.
func (m *ProfileMutation) SetFuelVolumeUnit(pvu profile.FuelVolumeUnit) {
	m.fuel_volume_unit = &pvu
}

// FuelVolumeUnit returns the value of the "fuel_volume_unit" field in the mutation.
func (m *ProfileMutation) FuelVolumeUnit() (r profile.FuelVolumeUnit, exists bool) {
	v := m.fuel_volume_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldFuelVolumeUnit returns the old "fuel_volume_unit" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldFuelVolumeUnit(ctx context.Context) (v *profile.FuelVolumeUnit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFuelVolumeUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFuelVolumeUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFuelVolumeUnit: %w", err)
	}
	return oldValue.FuelVolumeUnit, nil
}

// ClearFuelVolumeUnit clears the value of the "fuel_volume_unit" field.
func (m *ProfileMutation) ClearFuelVolumeUnit() {
	m.fuel_volume_unit = nil
	m.clearedFields[profile.FieldFuelVolumeUnit] = struct{}{}
}

// FuelVolumeUnitCleared returns if the "fuel_volume_unit" field was cleared in this mutation.
func (m *ProfileMutation) FuelVolumeUnitCleared() bool {
	_, ok := m.clearedFields[profile.FieldFuelVolumeUnit]
	return ok
}

// ResetFuelVolumeUnit resets all changes to the "fuel_volume_unit" field.
func (m *ProfileMutation) ResetFuelVolumeUnit() {
	m.fuel_volume_unit = nil
	delete(m.clearedFields, profile.FieldFuelVolumeUnit)
}

// SetDistanceUnit sets the "distance_unit" field.
func (m *ProfileMutation) SetDistanceUnit(pu profile.DistanceUnit) {
	m.distance_unit = &pu
}

// DistanceUnit returns the value of the "distance_unit" field in the mutation.
func (m *ProfileMutation) DistanceUnit() (r profile.DistanceUnit, exists bool) {
	v := m.distance_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldDistanceUnit returns the old "distance_unit" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldDistanceUnit(ctx context.Context) (v *profile.DistanceUnit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistanceUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistanceUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistanceUnit: %w", err)
	}
	return oldValue.DistanceUnit, nil
}

// ClearDistanceUnit clears the value of the "distance_unit" field.
func (m *ProfileMutation) ClearDistanceUnit() {
	m.distance_unit = nil
	m.clearedFields[profile.FieldDistanceUnit] = struct{}{}
}

// DistanceUnitCleared returns if the "distance_unit" field was cleared in this mutation.
func (m *ProfileMutation) DistanceUnitCleared() bool {
	_, ok := m.clearedFields[profile.FieldDistanceUnit]
	return ok
}

// ResetDistanceUnit resets all changes to the "distance_unit" field.
func (m *ProfileMutation) ResetDistanceUnit() {
	m.distance_unit = nil
	delete(m.clearedFields, profile.FieldDistanceUnit)
}

// SetFuelConsumptionUnit sets the "fuel_consumption_unit" field.
func (m *ProfileMutation) SetFuelConsumptionUnit(pcu profile.FuelConsumptionUnit) {
	m.fuel_consumption_unit = &pcu
}

// FuelConsumptionUnit returns the value of the "fuel_consumption_unit" field in the mutation.
func (m *ProfileMutation) FuelConsumptionUnit() (r profile.FuelConsumptionUnit, exists bool) {
	v := m.fuel_consumption_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldFuelConsumptionUnit returns the old "fuel_consumption_unit" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldFuelConsumptionUnit(ctx context.Context) (v *profile.FuelConsumptionUnit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFuelConsumptionUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFuelConsumptionUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFuelConsumptionUnit: %w", err)
	}
	return oldValue.FuelConsumptionUnit, nil
}

// ClearFuelConsumptionUnit clears the value of the "fuel_consumption_unit" field.
func (m *ProfileMutation) ClearFuelConsumptionUnit() {
	m.fuel_consumption_unit = nil
	m.clearedFields[profile.FieldFuelConsumptionUnit] = struct{}{}
}

// FuelConsumptionUnitCleared returns if the "fuel_consumption_unit" field was cleared in this mutation.
func (m *ProfileMutation) FuelConsumptionUnitCleared() bool {
	_, ok := m.clearedFields[profile.FieldFuelConsumptionUnit]
	return ok
}

// ResetFuelConsumptionUnit resets all changes to the "fuel_consumption_unit" field.
func (m *ProfileMutation) ResetFuelConsumptionUnit() {
	m.fuel_consumption_unit = nil
	delete(m.clearedFields, profile.FieldFuelConsumptionUnit)
}

// SetTemperatureUnit sets the "temperature_unit" field.
func (m *ProfileMutation) SetTemperatureUnit(pu profile.TemperatureUnit) {
	m.temperature_unit = &pu
}

// TemperatureUnit returns the value of the "temperature_unit" field in the mutation.
func (m *ProfileMutation) TemperatureUnit() (r profile.TemperatureUnit, exists bool) {
	v := m.temperature_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldTemperatureUnit returns the old "temperature_unit" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldTemperatureUnit(ctx context.Context) (v *profile.TemperatureUnit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemperatureUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemperatureUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemperatureUnit: %w", err)
	}
	return oldValue.TemperatureUnit, nil
}

// ClearTemperatureUnit clears the value of the "temperature_unit" field.
func (m *ProfileMutation) ClearTemperatureUnit() {
	m.temperature_unit = nil
	m.clearedFields[profile.FieldTemperatureUnit] = struct{}{}
}

// TemperatureUnitCleared returns if the "temperature_unit" field was cleared in this mutation.
func (m *ProfileMutation) TemperatureUnitCleared() bool {
	_, ok := m.clearedFields[profile.FieldTemperatureUnit]
	return ok
}

// ResetTemperatureUnit resets all changes to the "temperature_unit" field.
func (m *ProfileMutation) ResetTemperatureUnit() {
	m.temperature_unit = nil
	delete(m.clearedFields, profile.FieldTemperatureUnit)
}

// SetVisibility sets the "visibility" field.
func (m *ProfileMutation) SetVisibility(pr profile.Visibility) {
	m.visibility = &pr
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *ProfileMutation) Visibility() (r profile.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldVisibility(ctx context.Context) (v profile.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *ProfileMutation) ResetVisibility() {
	m.visibility = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ProfileMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProfileMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProfileMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ProfileMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProfileMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProfileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ProfileMutation builder.
func (m *ProfileMutation) Where(ps ...predicate.Profile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Profile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Profile).
func (m *ProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfileMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.create_time != nil {
		fields = append(fields, profile.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, profile.FieldUpdateTime)
	}
	if m.username != nil {
		fields = append(fields, profile.FieldUsername)
	}
	if m.first_name != nil {
		fields = append(fields, profile.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, profile.FieldLastName)
	}
	if m.picture != nil {
		fields = append(fields, profile.FieldPicture)
	}
	if m.currency_code != nil {
		fields = append(fields, profile.FieldCurrencyCode)
	}
	if m.fuel_volume_unit != nil {
		fields = append(fields, profile.FieldFuelVolumeUnit)
	}
	if m.distance_unit != nil {
		fields = append(fields, profile.FieldDistanceUnit)
	}
	if m.fuel_consumption_unit != nil {
		fields = append(fields, profile.FieldFuelConsumptionUnit)
	}
	if m.temperature_unit != nil {
		fields = append(fields, profile.FieldTemperatureUnit)
	}
	if m.visibility != nil {
		fields = append(fields, profile.FieldVisibility)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profile.FieldCreateTime:
		return m.CreateTime()
	case profile.FieldUpdateTime:
		return m.UpdateTime()
	case profile.FieldUsername:
		return m.Username()
	case profile.FieldFirstName:
		return m.FirstName()
	case profile.FieldLastName:
		return m.LastName()
	case profile.FieldPicture:
		return m.Picture()
	case profile.FieldCurrencyCode:
		return m.CurrencyCode()
	case profile.FieldFuelVolumeUnit:
		return m.FuelVolumeUnit()
	case profile.FieldDistanceUnit:
		return m.DistanceUnit()
	case profile.FieldFuelConsumptionUnit:
		return m.FuelConsumptionUnit()
	case profile.FieldTemperatureUnit:
		return m.TemperatureUnit()
	case profile.FieldVisibility:
		return m.Visibility()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profile.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case profile.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case profile.FieldUsername:
		return m.OldUsername(ctx)
	case profile.FieldFirstName:
		return m.OldFirstName(ctx)
	case profile.FieldLastName:
		return m.OldLastName(ctx)
	case profile.FieldPicture:
		return m.OldPicture(ctx)
	case profile.FieldCurrencyCode:
		return m.OldCurrencyCode(ctx)
	case profile.FieldFuelVolumeUnit:
		return m.OldFuelVolumeUnit(ctx)
	case profile.FieldDistanceUnit:
		return m.OldDistanceUnit(ctx)
	case profile.FieldFuelConsumptionUnit:
		return m.OldFuelConsumptionUnit(ctx)
	case profile.FieldTemperatureUnit:
		return m.OldTemperatureUnit(ctx)
	case profile.FieldVisibility:
		return m.OldVisibility(ctx)
	}
	return nil, fmt.Errorf("unknown Profile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profile.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case profile.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case profile.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case profile.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case profile.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case profile.FieldPicture:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicture(v)
		return nil
	case profile.FieldCurrencyCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrencyCode(v)
		return nil
	case profile.FieldFuelVolumeUnit:
		v, ok := value.(profile.FuelVolumeUnit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFuelVolumeUnit(v)
		return nil
	case profile.FieldDistanceUnit:
		v, ok := value.(profile.DistanceUnit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistanceUnit(v)
		return nil
	case profile.FieldFuelConsumptionUnit:
		v, ok := value.(profile.FuelConsumptionUnit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFuelConsumptionUnit(v)
		return nil
	case profile.FieldTemperatureUnit:
		v, ok := value.(profile.TemperatureUnit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemperatureUnit(v)
		return nil
	case profile.FieldVisibility:
		v, ok := value.(profile.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Profile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(profile.FieldUsername) {
		fields = append(fields, profile.FieldUsername)
	}
	if m.FieldCleared(profile.FieldFirstName) {
		fields = append(fields, profile.FieldFirstName)
	}
	if m.FieldCleared(profile.FieldLastName) {
		fields = append(fields, profile.FieldLastName)
	}
	if m.FieldCleared(profile.FieldPicture) {
		fields = append(fields, profile.FieldPicture)
	}
	if m.FieldCleared(profile.FieldCurrencyCode) {
		fields = append(fields, profile.FieldCurrencyCode)
	}
	if m.FieldCleared(profile.FieldFuelVolumeUnit) {
		fields = append(fields, profile.FieldFuelVolumeUnit)
	}
	if m.FieldCleared(profile.FieldDistanceUnit) {
		fields = append(fields, profile.FieldDistanceUnit)
	}
	if m.FieldCleared(profile.FieldFuelConsumptionUnit) {
		fields = append(fields, profile.FieldFuelConsumptionUnit)
	}
	if m.FieldCleared(profile.FieldTemperatureUnit) {
		fields = append(fields, profile.FieldTemperatureUnit)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfileMutation) ClearField(name string) error {
	switch name {
	case profile.FieldUsername:
		m.ClearUsername()
		return nil
	case profile.FieldFirstName:
		m.ClearFirstName()
		return nil
	case profile.FieldLastName:
		m.ClearLastName()
		return nil
	case profile.FieldPicture:
		m.ClearPicture()
		return nil
	case profile.FieldCurrencyCode:
		m.ClearCurrencyCode()
		return nil
	case profile.FieldFuelVolumeUnit:
		m.ClearFuelVolumeUnit()
		return nil
	case profile.FieldDistanceUnit:
		m.ClearDistanceUnit()
		return nil
	case profile.FieldFuelConsumptionUnit:
		m.ClearFuelConsumptionUnit()
		return nil
	case profile.FieldTemperatureUnit:
		m.ClearTemperatureUnit()
		return nil
	}
	return fmt.Errorf("unknown Profile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfileMutation) ResetField(name string) error {
	switch name {
	case profile.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case profile.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case profile.FieldUsername:
		m.ResetUsername()
		return nil
	case profile.FieldFirstName:
		m.ResetFirstName()
		return nil
	case profile.FieldLastName:
		m.ResetLastName()
		return nil
	case profile.FieldPicture:
		m.ResetPicture()
		return nil
	case profile.FieldCurrencyCode:
		m.ResetCurrencyCode()
		return nil
	case profile.FieldFuelVolumeUnit:
		m.ResetFuelVolumeUnit()
		return nil
	case profile.FieldDistanceUnit:
		m.ResetDistanceUnit()
		return nil
	case profile.FieldFuelConsumptionUnit:
		m.ResetFuelConsumptionUnit()
		return nil
	case profile.FieldTemperatureUnit:
		m.ResetTemperatureUnit()
		return nil
	case profile.FieldVisibility:
		m.ResetVisibility()
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, profile.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, profile.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case profile.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfileMutation) ClearEdge(name string) error {
	switch name {
	case profile.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Profile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfileMutation) ResetEdge(name string) error {
	switch name {
	case profile.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Profile edge %s", name)
}

// ServiceItemMutation represents an operation that mutates the ServiceItem nodes in the graph.
type ServiceItemMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	create_time                *time.Time
	update_time                *time.Time
	label                      *string
	estimated_minutes          *int
	addestimated_minutes       *int
	default_interval_km        *float64
	adddefault_interval_km     *float64
	default_interval_months    *int
	adddefault_interval_months *int
	notes                      *string
	tags                       *[]string
	appendtags                 []string
	clearedFields              map[string]struct{}
	car                        *uuid.UUID
	clearedcar                 bool
	schedules                  map[uuid.UUID]struct{}
	removedschedules           map[uuid.UUID]struct{}
	clearedschedules           bool
	logs                       map[uuid.UUID]struct{}
	removedlogs                map[uuid.UUID]struct{}
	clearedlogs                bool
	done                       bool
	oldValue                   func(context.Context) (*ServiceItem, error)
	predicates                 []predicate.ServiceItem
}

var _ ent.Mutation = (*ServiceItemMutation)(nil)

// serviceitemOption allows management of the mutation configuration using functional options.
type serviceitemOption func(*ServiceItemMutation)

// newServiceItemMutation creates new mutation for the ServiceItem entity.
func newServiceItemMutation(c config, op Op, opts ...serviceitemOption) *ServiceItemMutation {
	m := &ServiceItemMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceItemID sets the ID field of the mutation.
func withServiceItemID(id uuid.UUID) serviceitemOption {
	return func(m *ServiceItemMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceItem
		)
		m.oldValue = func(ctx context.Context) (*ServiceItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceItem sets the old ServiceItem of the mutation.
func withServiceItem(node *ServiceItem) serviceitemOption {
	return func(m *ServiceItemMutation) {
		m.oldValue = func(context.Context) (*ServiceItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceItem entities.
func (m *ServiceItemMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceItemMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceItemMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ServiceItemMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ServiceItemMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ServiceItem entity.
// If the ServiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceItemMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ServiceItemMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ServiceItemMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ServiceItemMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ServiceItem entity.
// If the ServiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceItemMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ServiceItemMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetLabel sets the "label" field.
func (m *ServiceItemMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *ServiceItemMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the ServiceItem entity.
// If the ServiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceItemMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *ServiceItemMutation) ResetLabel() {
	m.label = nil
}

// SetEstimatedMinutes sets the "estimated_minutes" field.
func (m *ServiceItemMutation) SetEstimatedMinutes(i int) {
	m.estimated_minutes = &i
	m.addestimated_minutes = nil
}

// EstimatedMinutes returns the value of the "estimated_minutes" field in the mutation.
func (m *ServiceItemMutation) EstimatedMinutes() (r int, exists bool) {
	v := m.estimated_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedMinutes returns the old "estimated_minutes" field's value of the ServiceItem entity.
// If the ServiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceItemMutation) OldEstimatedMinutes(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedMinutes: %w", err)
	}
	return oldValue.EstimatedMinutes, nil
}

// AddEstimatedMinutes adds i to the "estimated_minutes" field.
func (m *ServiceItemMutation) AddEstimatedMinutes(i int) {
	if m.addestimated_minutes != nil {
		*m.addestimated_minutes += i
	} else {
		m.addestimated_minutes = &i
	}
}

// AddedEstimatedMinutes returns the value that was added to the "estimated_minutes" field in this mutation.
func (m *ServiceItemMutation) AddedEstimatedMinutes() (r int, exists bool) {
	v := m.addestimated_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimatedMinutes clears the value of the "estimated_minutes" field.
func (m *ServiceItemMutation) ClearEstimatedMinutes() {
	m.estimated_minutes = nil
	m.addestimated_minutes = nil
	m.clearedFields[serviceitem.FieldEstimatedMinutes] = struct{}{}
}

// EstimatedMinutesCleared returns if the "estimated_minutes" field was cleared in this mutation.
func (m *ServiceItemMutation) EstimatedMinutesCleared() bool {
	_, ok := m.clearedFields[serviceitem.FieldEstimatedMinutes]
	return ok
}

// ResetEstimatedMinutes resets all changes to the "estimated_minutes" field.
func (m *ServiceItemMutation) ResetEstimatedMinutes() {
	m.estimated_minutes = nil
	m.addestimated_minutes = nil
	delete(m.clearedFields, serviceitem.FieldEstimatedMinutes)
}

// SetDefaultIntervalKm sets the "default_interval_km" field.
func (m *ServiceItemMutation) SetDefaultIntervalKm(f float64) {
	m.default_interval_km = &f
	m.adddefault_interval_km = nil
}

// DefaultIntervalKm returns the value of the "default_interval_km" field in the mutation.
func (m *ServiceItemMutation) DefaultIntervalKm() (r float64, exists bool) {
	v := m.default_interval_km
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultIntervalKm returns the old "default_interval_km" field's value of the ServiceItem entity.
// If the ServiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceItemMutation) OldDefaultIntervalKm(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultIntervalKm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultIntervalKm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultIntervalKm: %w", err)
	}
	return oldValue.DefaultIntervalKm, nil
}

// AddDefaultIntervalKm adds f to the "default_interval_km" field.
func (m *ServiceItemMutation) AddDefaultIntervalKm(f float64) {
	if m.adddefault_interval_km != nil {
		*m.adddefault_interval_km += f
	} else {
		m.adddefault_interval_km = &f
	}
}

// AddedDefaultIntervalKm returns the value that was added to the "default_interval_km" field in this mutation.
func (m *ServiceItemMutation) AddedDefaultIntervalKm() (r float64, exists bool) {
	v := m.adddefault_interval_km
	if v == nil {
		return
	}
	return *v, true
}

// ClearDefaultIntervalKm clears the value of the "default_interval_km" field.
func (m *ServiceItemMutation) ClearDefaultIntervalKm() {
	m.default_interval_km = nil
	m.adddefault_interval_km = nil
	m.clearedFields[serviceitem.FieldDefaultIntervalKm] = struct{}{}
}

// DefaultIntervalKmCleared returns if the "default_interval_km" field was cleared in this mutation.
func (m *ServiceItemMutation) DefaultIntervalKmCleared() bool {
	_, ok := m.clearedFields[serviceitem.FieldDefaultIntervalKm]
	return ok
}

// ResetDefaultIntervalKm resets all changes to the "default_interval_km" field.
func (m *ServiceItemMutation) ResetDefaultIntervalKm() {
	m.default_interval_km = nil
	m.adddefault_interval_km = nil
	delete(m.clearedFields, serviceitem.FieldDefaultIntervalKm)
}

// SetDefaultIntervalMonths sets the "default_interval_months" field.
func (m *ServiceItemMutation) SetDefaultIntervalMonths(i int) {
	m.default_interval_months = &i
	m.adddefault_interval_months = nil
}

// DefaultIntervalMonths returns the value of the "default_interval_months" field in the mutation.
func (m *ServiceItemMutation) DefaultIntervalMonths() (r int, exists bool) {
	v := m.default_interval_months
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultIntervalMonths returns the old "default_interval_months" field's value of the ServiceItem entity.
// If the ServiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceItemMutation) OldDefaultIntervalMonths(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultIntervalMonths is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultIntervalMonths requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultIntervalMonths: %w", err)
	}
	return oldValue.DefaultIntervalMonths, nil
}

// AddDefaultIntervalMonths adds i to the "default_interval_months" field.
func (m *ServiceItemMutation) AddDefaultIntervalMonths(i int) {
	if m.adddefault_interval_months != nil {
		*m.adddefault_interval_months += i
	} else {
		m.adddefault_interval_months = &i
	}
}

// AddedDefaultIntervalMonths returns the value that was added to the "default_interval_months" field in this mutation.
func (m *ServiceItemMutation) AddedDefaultIntervalMonths() (r int, exists bool) {
	v := m.adddefault_interval_months
	if v == nil {
		return
	}
	return *v, true
}

// ClearDefaultIntervalMonths clears the value of the "default_interval_months" field.
func (m *ServiceItemMutation) ClearDefaultIntervalMonths() {
	m.default_interval_months = nil
	m.adddefault_interval_months = nil
	m.clearedFields[serviceitem.FieldDefaultIntervalMonths] = struct{}{}
}

// DefaultIntervalMonthsCleared returns if the "default_interval_months" field was cleared in this mutation.
func (m *ServiceItemMutation) DefaultIntervalMonthsCleared() bool {
	_, ok := m.clearedFields[serviceitem.FieldDefaultIntervalMonths]
	return ok
}

// ResetDefaultIntervalMonths resets all changes to the "default_interval_months" field.
func (m *ServiceItemMutation) ResetDefaultIntervalMonths() {
	m.default_interval_months = nil
	m.adddefault_interval_months = nil
	delete(m.clearedFields, serviceitem.FieldDefaultIntervalMonths)
}

// SetNotes sets the "notes" field.
func (m *ServiceItemMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *ServiceItemMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the ServiceItem entity.
// If the ServiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceItemMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *ServiceItemMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[serviceitem.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *ServiceItemMutation) NotesCleared() bool {
	_, ok := m.clearedFields[serviceitem.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *ServiceItemMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, serviceitem.FieldNotes)
}

// SetTags sets the "tags" field.
func (m *ServiceItemMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ServiceItemMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the ServiceItem entity.
// If the ServiceItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceItemMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ServiceItemMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ServiceItemMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *ServiceItemMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *ServiceItemMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *ServiceItemMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *ServiceItemMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *ServiceItemMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *ServiceItemMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *ServiceItemMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// AddScheduleIDs adds the "schedules" edge to the ServiceSchedule entity by ids.
func (m *ServiceItemMutation) AddScheduleIDs(ids ...uuid.UUID) {
	if m.schedules == nil {
		m.schedules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.schedules[ids[i]] = struct{}{}
	}
}

// ClearSchedules clears the "schedules" edge to the ServiceSchedule entity.
func (m *ServiceItemMutation) ClearSchedules() {
	m.clearedschedules = true
}

// SchedulesCleared reports if the "schedules" edge to the ServiceSchedule entity was cleared.
func (m *ServiceItemMutation) SchedulesCleared() bool {
	return m.clearedschedules
}

// RemoveScheduleIDs removes the "schedules" edge to the ServiceSchedule entity by IDs.
func (m *ServiceItemMutation) RemoveScheduleIDs(ids ...uuid.UUID) {
	if m.removedschedules == nil {
		m.removedschedules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.schedules, ids[i])
		m.removedschedules[ids[i]] = struct{}{}
	}
}

// RemovedSchedules returns the removed IDs of the "schedules" edge to the ServiceSchedule entity.
func (m *ServiceItemMutation) RemovedSchedulesIDs() (ids []uuid.UUID) {
	for id := range m.removedschedules {
		ids = append(ids, id)
	}
	return
}

// SchedulesIDs returns the "schedules" edge IDs in the mutation.
func (m *ServiceItemMutation) SchedulesIDs() (ids []uuid.UUID) {
	for id := range m.schedules {
		ids = append(ids, id)
	}
	return
}

// ResetSchedules resets all changes to the "schedules" edge.
func (m *ServiceItemMutation) ResetSchedules() {
	m.schedules = nil
	m.clearedschedules = false
	m.removedschedules = nil
}

// AddLogIDs adds the "logs" edge to the ServiceLog entity by ids.
func (m *ServiceItemMutation) AddLogIDs(ids ...uuid.UUID) {
	if m.logs == nil {
		m.logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the ServiceLog entity.
func (m *ServiceItemMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the ServiceLog entity was cleared.
func (m *ServiceItemMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the ServiceLog entity by IDs.
func (m *ServiceItemMutation) RemoveLogIDs(ids ...uuid.UUID) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the ServiceLog entity.
func (m *ServiceItemMutation) RemovedLogsIDs() (ids []uuid.UUID) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *ServiceItemMutation) LogsIDs() (ids []uuid.UUID) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *ServiceItemMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// Where appends a list predicates to the ServiceItemMutation builder.
func (m *ServiceItemMutation) Where(ps ...predicate.ServiceItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceItem).
func (m *ServiceItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceItemMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, serviceitem.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, serviceitem.FieldUpdateTime)
	}
	if m.label != nil {
		fields = append(fields, serviceitem.FieldLabel)
	}
	if m.estimated_minutes != nil {
		fields = append(fields, serviceitem.FieldEstimatedMinutes)
	}
	if m.default_interval_km != nil {
		fields = append(fields, serviceitem.FieldDefaultIntervalKm)
	}
	if m.default_interval_months != nil {
		fields = append(fields, serviceitem.FieldDefaultIntervalMonths)
	}
	if m.notes != nil {
		fields = append(fields, serviceitem.FieldNotes)
	}
	if m.tags != nil {
		fields = append(fields, serviceitem.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serviceitem.FieldCreateTime:
		return m.CreateTime()
	case serviceitem.FieldUpdateTime:
		return m.UpdateTime()
	case serviceitem.FieldLabel:
		return m.Label()
	case serviceitem.FieldEstimatedMinutes:
		return m.EstimatedMinutes()
	case serviceitem.FieldDefaultIntervalKm:
		return m.DefaultIntervalKm()
	case serviceitem.FieldDefaultIntervalMonths:
		return m.DefaultIntervalMonths()
	case serviceitem.FieldNotes:
		return m.Notes()
	case serviceitem.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serviceitem.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case serviceitem.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case serviceitem.FieldLabel:
		return m.OldLabel(ctx)
	case serviceitem.FieldEstimatedMinutes:
		return m.OldEstimatedMinutes(ctx)
	case serviceitem.FieldDefaultIntervalKm:
		return m.OldDefaultIntervalKm(ctx)
	case serviceitem.FieldDefaultIntervalMonths:
		return m.OldDefaultIntervalMonths(ctx)
	case serviceitem.FieldNotes:
		return m.OldNotes(ctx)
	case serviceitem.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serviceitem.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case serviceitem.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case serviceitem.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case serviceitem.FieldEstimatedMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedMinutes(v)
		return nil
	case serviceitem.FieldDefaultIntervalKm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultIntervalKm(v)
		return nil
	case serviceitem.FieldDefaultIntervalMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultIntervalMonths(v)
		return nil
	case serviceitem.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case serviceitem.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceItemMutation) AddedFields() []string {
	var fields []string
	if m.addestimated_minutes != nil {
		fields = append(fields, serviceitem.FieldEstimatedMinutes)
	}
	if m.adddefault_interval_km != nil {
		fields = append(fields, serviceitem.FieldDefaultIntervalKm)
	}
	if m.adddefault_interval_months != nil {
		fields = append(fields, serviceitem.FieldDefaultIntervalMonths)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case serviceitem.FieldEstimatedMinutes:
		return m.AddedEstimatedMinutes()
	case serviceitem.FieldDefaultIntervalKm:
		return m.AddedDefaultIntervalKm()
	case serviceitem.FieldDefaultIntervalMonths:
		return m.AddedDefaultIntervalMonths()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case serviceitem.FieldEstimatedMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedMinutes(v)
		return nil
	case serviceitem.FieldDefaultIntervalKm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultIntervalKm(v)
		return nil
	case serviceitem.FieldDefaultIntervalMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultIntervalMonths(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(serviceitem.FieldEstimatedMinutes) {
		fields = append(fields, serviceitem.FieldEstimatedMinutes)
	}
	if m.FieldCleared(serviceitem.FieldDefaultIntervalKm) {
		fields = append(fields, serviceitem.FieldDefaultIntervalKm)
	}
	if m.FieldCleared(serviceitem.FieldDefaultIntervalMonths) {
		fields = append(fields, serviceitem.FieldDefaultIntervalMonths)
	}
	if m.FieldCleared(serviceitem.FieldNotes) {
		fields = append(fields, serviceitem.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceItemMutation) ClearField(name string) error {
	switch name {
	case serviceitem.FieldEstimatedMinutes:
		m.ClearEstimatedMinutes()
		return nil
	case serviceitem.FieldDefaultIntervalKm:
		m.ClearDefaultIntervalKm()
		return nil
	case serviceitem.FieldDefaultIntervalMonths:
		m.ClearDefaultIntervalMonths()
		return nil
	case serviceitem.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown ServiceItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceItemMutation) ResetField(name string) error {
	switch name {
	case serviceitem.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case serviceitem.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case serviceitem.FieldLabel:
		m.ResetLabel()
		return nil
	case serviceitem.FieldEstimatedMinutes:
		m.ResetEstimatedMinutes()
		return nil
	case serviceitem.FieldDefaultIntervalKm:
		m.ResetDefaultIntervalKm()
		return nil
	case serviceitem.FieldDefaultIntervalMonths:
		m.ResetDefaultIntervalMonths()
		return nil
	case serviceitem.FieldNotes:
		m.ResetNotes()
		return nil
	case serviceitem.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown ServiceItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.car != nil {
		edges = append(edges, serviceitem.EdgeCar)
	}
	if m.schedules != nil {
		edges = append(edges, serviceitem.EdgeSchedules)
	}
	if m.logs != nil {
		edges = append(edges, serviceitem.EdgeLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serviceitem.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case serviceitem.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.schedules))
		for id := range m.schedules {
			ids = append(ids, id)
		}
		return ids
	case serviceitem.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedschedules != nil {
		edges = append(edges, serviceitem.EdgeSchedules)
	}
	if m.removedlogs != nil {
		edges = append(edges, serviceitem.EdgeLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case serviceitem.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.removedschedules))
		for id := range m.removedschedules {
			ids = append(ids, id)
		}
		return ids
	case serviceitem.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcar {
		edges = append(edges, serviceitem.EdgeCar)
	}
	if m.clearedschedules {
		edges = append(edges, serviceitem.EdgeSchedules)
	}
	if m.clearedlogs {
		edges = append(edges, serviceitem.EdgeLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceItemMutation) EdgeCleared(name string) bool {
	switch name {
	case serviceitem.EdgeCar:
		return m.clearedcar
	case serviceitem.EdgeSchedules:
		return m.clearedschedules
	case serviceitem.EdgeLogs:
		return m.clearedlogs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceItemMutation) ClearEdge(name string) error {
	switch name {
	case serviceitem.EdgeCar:
		m.ClearCar()
		return nil
	}
	return fmt.Errorf("unknown ServiceItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceItemMutation) ResetEdge(name string) error {
	switch name {
	case serviceitem.EdgeCar:
		m.ResetCar()
		return nil
	case serviceitem.EdgeSchedules:
		m.ResetSchedules()
		return nil
	case serviceitem.EdgeLogs:
		m.ResetLogs()
		return nil
	}
	return fmt.Errorf("unknown ServiceItem edge %s", name)
}

// ServiceLogMutation represents an operation that mutates the ServiceLog nodes in the graph.
type ServiceLogMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	create_time             *time.Time
	update_time             *time.Time
	date_performed          *time.Time
	performed_by            *string
	notes                   *string
	clearedFields           map[string]struct{}
	car                     *uuid.UUID
	clearedcar              bool
	items                   map[uuid.UUID]struct{}
	removeditems            map[uuid.UUID]struct{}
	cleareditems            bool
	schedule                *uuid.UUID
	clearedschedule         bool
	odometer_reading        *uuid.UUID
	clearedodometer_reading bool
	done                    bool
	oldValue                func(context.Context) (*ServiceLog, error)
	predicates              []predicate.ServiceLog
}

var _ ent.Mutation = (*ServiceLogMutation)(nil)

// servicelogOption allows management of the mutation configuration using functional options.
type servicelogOption func(*ServiceLogMutation)

// newServiceLogMutation creates new mutation for the ServiceLog entity.
func newServiceLogMutation(c config, op Op, opts ...servicelogOption) *ServiceLogMutation {
	m := &ServiceLogMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceLogID sets the ID field of the mutation.
func withServiceLogID(id uuid.UUID) servicelogOption {
	return func(m *ServiceLogMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceLog
		)
		m.oldValue = func(ctx context.Context) (*ServiceLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceLog sets the old ServiceLog of the mutation.
func withServiceLog(node *ServiceLog) servicelogOption {
	return func(m *ServiceLogMutation) {
		m.oldValue = func(context.Context) (*ServiceLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceLog entities.
func (m *ServiceLogMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceLogMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceLogMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ServiceLogMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ServiceLogMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ServiceLog entity.
// If the ServiceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceLogMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ServiceLogMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ServiceLogMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ServiceLogMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ServiceLog entity.
// If the ServiceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceLogMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ServiceLogMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDatePerformed sets the "date_performed" field.
func (m *ServiceLogMutation) SetDatePerformed(t time.Time) {
	m.date_performed = &t
}

// DatePerformed returns the value of the "date_performed" field in the mutation.
func (m *ServiceLogMutation) DatePerformed() (r time.Time, exists bool) {
	v := m.date_performed
	if v == nil {
		return
	}
	return *v, true
}

// OldDatePerformed returns the old "date_performed" field's value of the ServiceLog entity.
// If the ServiceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceLogMutation) OldDatePerformed(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatePerformed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatePerformed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatePerformed: %w", err)
	}
	return oldValue.DatePerformed, nil
}

// ResetDatePerformed resets all changes to the "date_performed" field.
func (m *ServiceLogMutation) ResetDatePerformed() {
	m.date_performed = nil
}

// SetPerformedBy sets the "performed_by" field.
func (m *ServiceLogMutation) SetPerformedBy(s string) {
	m.performed_by = &s
}

// PerformedBy returns the value of the "performed_by" field in the mutation.
func (m *ServiceLogMutation) PerformedBy() (r string, exists bool) {
	v := m.performed_by
	if v == nil {
		return
	}
	return *v, true
}

// OldPerformedBy returns the old "performed_by" field's value of the ServiceLog entity.
// If the ServiceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceLogMutation) OldPerformedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerformedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerformedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerformedBy: %w", err)
	}
	return oldValue.PerformedBy, nil
}

// ClearPerformedBy clears the value of the "performed_by" field.
func (m *ServiceLogMutation) ClearPerformedBy() {
	m.performed_by = nil
	m.clearedFields[servicelog.FieldPerformedBy] = struct{}{}
}

// PerformedByCleared returns if the "performed_by" field was cleared in this mutation.
func (m *ServiceLogMutation) PerformedByCleared() bool {
	_, ok := m.clearedFields[servicelog.FieldPerformedBy]
	return ok
}

// ResetPerformedBy resets all changes to the "performed_by" field.
func (m *ServiceLogMutation) ResetPerformedBy() {
	m.performed_by = nil
	delete(m.clearedFields, servicelog.FieldPerformedBy)
}

// SetNotes sets the "notes" field.
func (m *ServiceLogMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *ServiceLogMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the ServiceLog entity.
// If the ServiceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceLogMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *ServiceLogMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[servicelog.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *ServiceLogMutation) NotesCleared() bool {
	_, ok := m.clearedFields[servicelog.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *ServiceLogMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, servicelog.FieldNotes)
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *ServiceLogMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *ServiceLogMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *ServiceLogMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *ServiceLogMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *ServiceLogMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *ServiceLogMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// AddItemIDs adds the "items" edge to the ServiceItem entity by ids.
func (m *ServiceLogMutation) AddItemIDs(ids ...uuid.UUID) {
	if m.items == nil {
		m.items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the ServiceItem entity.
func (m *ServiceLogMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the ServiceItem entity was cleared.
func (m *ServiceLogMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the ServiceItem entity by IDs.
func (m *ServiceLogMutation) RemoveItemIDs(ids ...uuid.UUID) {
	if m.removeditems == nil {
		m.removeditems = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the ServiceItem entity.
func (m *ServiceLogMutation) RemovedItemsIDs() (ids []uuid.UUID) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *ServiceLogMutation) ItemsIDs() (ids []uuid.UUID) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *ServiceLogMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// SetScheduleID sets the "schedule" edge to the ServiceSchedule entity by id.
func (m *ServiceLogMutation) SetScheduleID(id uuid.UUID) {
	m.schedule = &id
}

// ClearSchedule clears the "schedule" edge to the ServiceSchedule entity.
func (m *ServiceLogMutation) ClearSchedule() {
	m.clearedschedule = true
}

// ScheduleCleared reports if the "schedule" edge to the ServiceSchedule entity was cleared.
func (m *ServiceLogMutation) ScheduleCleared() bool {
	return m.clearedschedule
}

// ScheduleID returns the "schedule" edge ID in the mutation.
func (m *ServiceLogMutation) ScheduleID() (id uuid.UUID, exists bool) {
	if m.schedule != nil {
		return *m.schedule, true
	}
	return
}

// ScheduleIDs returns the "schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheduleID instead. It exists only for internal usage by the builders.
func (m *ServiceLogMutation) ScheduleIDs() (ids []uuid.UUID) {
	if id := m.schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchedule resets all changes to the "schedule" edge.
func (m *ServiceLogMutation) ResetSchedule() {
	m.schedule = nil
	m.clearedschedule = false
}

// SetOdometerReadingID sets the "odometer_reading" edge to the OdometerReading entity by id.
func (m *ServiceLogMutation) SetOdometerReadingID(id uuid.UUID) {
	m.odometer_reading = &id
}

// ClearOdometerReading clears the "odometer_reading" edge to the OdometerReading entity.
func (m *ServiceLogMutation) ClearOdometerReading() {
	m.clearedodometer_reading = true
}

// OdometerReadingCleared reports if the "odometer_reading" edge to the OdometerReading entity was cleared.
func (m *ServiceLogMutation) OdometerReadingCleared() bool {
	return m.clearedodometer_reading
}

// OdometerReadingID returns the "odometer_reading" edge ID in the mutation.
func (m *ServiceLogMutation) OdometerReadingID() (id uuid.UUID, exists bool) {
	if m.odometer_reading != nil {
		return *m.odometer_reading, true
	}
	return
}

// OdometerReadingIDs returns the "odometer_reading" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OdometerReadingID instead. It exists only for internal usage by the builders.
func (m *ServiceLogMutation) OdometerReadingIDs() (ids []uuid.UUID) {
	if id := m.odometer_reading; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOdometerReading resets all changes to the "odometer_reading" edge.
func (m *ServiceLogMutation) ResetOdometerReading() {
	m.odometer_reading = nil
	m.clearedodometer_reading = false
}

// Where appends a list predicates to the ServiceLogMutation builder.
func (m *ServiceLogMutation) Where(ps ...predicate.ServiceLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceLog).
func (m *ServiceLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceLogMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, servicelog.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, servicelog.FieldUpdateTime)
	}
	if m.date_performed != nil {
		fields = append(fields, servicelog.FieldDatePerformed)
	}
	if m.performed_by != nil {
		fields = append(fields, servicelog.FieldPerformedBy)
	}
	if m.notes != nil {
		fields = append(fields, servicelog.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicelog.FieldCreateTime:
		return m.CreateTime()
	case servicelog.FieldUpdateTime:
		return m.UpdateTime()
	case servicelog.FieldDatePerformed:
		return m.DatePerformed()
	case servicelog.FieldPerformedBy:
		return m.PerformedBy()
	case servicelog.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicelog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case servicelog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case servicelog.FieldDatePerformed:
		return m.OldDatePerformed(ctx)
	case servicelog.FieldPerformedBy:
		return m.OldPerformedBy(ctx)
	case servicelog.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicelog.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case servicelog.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case servicelog.FieldDatePerformed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatePerformed(v)
		return nil
	case servicelog.FieldPerformedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerformedBy(v)
		return nil
	case servicelog.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servicelog.FieldPerformedBy) {
		fields = append(fields, servicelog.FieldPerformedBy)
	}
	if m.FieldCleared(servicelog.FieldNotes) {
		fields = append(fields, servicelog.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceLogMutation) ClearField(name string) error {
	switch name {
	case servicelog.FieldPerformedBy:
		m.ClearPerformedBy()
		return nil
	case servicelog.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown ServiceLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceLogMutation) ResetField(name string) error {
	switch name {
	case servicelog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case servicelog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case servicelog.FieldDatePerformed:
		m.ResetDatePerformed()
		return nil
	case servicelog.FieldPerformedBy:
		m.ResetPerformedBy()
		return nil
	case servicelog.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown ServiceLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.car != nil {
		edges = append(edges, servicelog.EdgeCar)
	}
	if m.items != nil {
		edges = append(edges, servicelog.EdgeItems)
	}
	if m.schedule != nil {
		edges = append(edges, servicelog.EdgeSchedule)
	}
	if m.odometer_reading != nil {
		edges = append(edges, servicelog.EdgeOdometerReading)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servicelog.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case servicelog.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case servicelog.EdgeSchedule:
		if id := m.schedule; id != nil {
			return []ent.Value{*id}
		}
	case servicelog.EdgeOdometerReading:
		if id := m.odometer_reading; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeditems != nil {
		edges = append(edges, servicelog.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceLogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case servicelog.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcar {
		edges = append(edges, servicelog.EdgeCar)
	}
	if m.cleareditems {
		edges = append(edges, servicelog.EdgeItems)
	}
	if m.clearedschedule {
		edges = append(edges, servicelog.EdgeSchedule)
	}
	if m.clearedodometer_reading {
		edges = append(edges, servicelog.EdgeOdometerReading)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceLogMutation) EdgeCleared(name string) bool {
	switch name {
	case servicelog.EdgeCar:
		return m.clearedcar
	case servicelog.EdgeItems:
		return m.cleareditems
	case servicelog.EdgeSchedule:
		return m.clearedschedule
	case servicelog.EdgeOdometerReading:
		return m.clearedodometer_reading
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceLogMutation) ClearEdge(name string) error {
	switch name {
	case servicelog.EdgeCar:
		m.ClearCar()
		return nil
	case servicelog.EdgeSchedule:
		m.ClearSchedule()
		return nil
	case servicelog.EdgeOdometerReading:
		m.ClearOdometerReading()
		return nil
	}
	return fmt.Errorf("unknown ServiceLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceLogMutation) ResetEdge(name string) error {
	switch name {
	case servicelog.EdgeCar:
		m.ResetCar()
		return nil
	case servicelog.EdgeItems:
		m.ResetItems()
		return nil
	case servicelog.EdgeSchedule:
		m.ResetSchedule()
		return nil
	case servicelog.EdgeOdometerReading:
		m.ResetOdometerReading()
		return nil
	}
	return fmt.Errorf("unknown ServiceLog edge %s", name)
}

// ServiceScheduleMutation represents an operation that mutates the ServiceSchedule nodes in the graph.
type ServiceScheduleMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	create_time            *time.Time
	update_time            *time.Time
	title                  *string
	repeat_every_km        *float64
	addrepeat_every_km     *float64
	starts_at_km           *float64
	addstarts_at_km        *float64
	repeat_every_months    *int
	addrepeat_every_months *int
	starts_at_months       *int
	addstarts_at_months    *int
	notes                  *string
	archived               *bool
	clearedFields          map[string]struct{}
	car                    *uuid.UUID
	clearedcar             bool
	items                  map[uuid.UUID]struct{}
	removeditems           map[uuid.UUID]struct{}
	cleareditems           bool
	logs                   map[uuid.UUID]struct{}
	removedlogs            map[uuid.UUID]struct{}
	clearedlogs            bool
	done                   bool
	oldValue               func(context.Context) (*ServiceSchedule, error)
	predicates             []predicate.ServiceSchedule
}

var _ ent.Mutation = (*ServiceScheduleMutation)(nil)

// servicescheduleOption allows management of the mutation configuration using functional options.
type servicescheduleOption func(*ServiceScheduleMutation)

// newServiceScheduleMutation creates new mutation for the ServiceSchedule entity.
func newServiceScheduleMutation(c config, op Op, opts ...servicescheduleOption) *ServiceScheduleMutation {
	m := &ServiceScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceScheduleID sets the ID field of the mutation.
func withServiceScheduleID(id uuid.UUID) servicescheduleOption {
	return func(m *ServiceScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceSchedule
		)
		m.oldValue = func(ctx context.Context) (*ServiceSchedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceSchedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceSchedule sets the old ServiceSchedule of the mutation.
func withServiceSchedule(node *ServiceSchedule) servicescheduleOption {
	return func(m *ServiceScheduleMutation) {
		m.oldValue = func(context.Context) (*ServiceSchedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceSchedule entities.
func (m *ServiceScheduleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceScheduleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceScheduleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceSchedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ServiceScheduleMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ServiceScheduleMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ServiceSchedule entity.
// If the ServiceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceScheduleMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ServiceScheduleMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ServiceScheduleMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ServiceScheduleMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ServiceSchedule entity.
// If the ServiceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceScheduleMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ServiceScheduleMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTitle sets the "title" field.
func (m *ServiceScheduleMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ServiceScheduleMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ServiceSchedule entity.
// If the ServiceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceScheduleMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ServiceScheduleMutation) ResetTitle() {
	m.title = nil
}

// SetRepeatEveryKm sets the "repeat_every_km" field.
func (m *ServiceScheduleMutation) SetRepeatEveryKm(f float64) {
	m.repeat_every_km = &f
	m.addrepeat_every_km = nil
}

// RepeatEveryKm returns the value of the "repeat_every_km" field in the mutation.
func (m *ServiceScheduleMutation) RepeatEveryKm() (r float64, exists bool) {
	v := m.repeat_every_km
	if v == nil {
		return
	}
	return *v, true
}

// OldRepeatEveryKm returns the old "repeat_every_km" field's value of the ServiceSchedule entity.
// If the ServiceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceScheduleMutation) OldRepeatEveryKm(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepeatEveryKm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepeatEveryKm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepeatEveryKm: %w", err)
	}
	return oldValue.RepeatEveryKm, nil
}

// AddRepeatEveryKm adds f to the "repeat_every_km" field.
func (m *ServiceScheduleMutation) AddRepeatEveryKm(f float64) {
	if m.addrepeat_every_km != nil {
		*m.addrepeat_every_km += f
	} else {
		m.addrepeat_every_km = &f
	}
}

// AddedRepeatEveryKm returns the value that was added to the "repeat_every_km" field in this mutation.
func (m *ServiceScheduleMutation) AddedRepeatEveryKm() (r float64, exists bool) {
	v := m.addrepeat_every_km
	if v == nil {
		return
	}
	return *v, true
}

// ClearRepeatEveryKm clears the value of the "repeat_every_km" field.
func (m *ServiceScheduleMutation) ClearRepeatEveryKm() {
	m.repeat_every_km = nil
	m.addrepeat_every_km = nil
	m.clearedFields[serviceschedule.FieldRepeatEveryKm] = struct{}{}
}

// RepeatEveryKmCleared returns if the "repeat_every_km" field was cleared in this mutation.
func (m *ServiceScheduleMutation) RepeatEveryKmCleared() bool {
	_, ok := m.clearedFields[serviceschedule.FieldRepeatEveryKm]
	return ok
}

// ResetRepeatEveryKm resets all changes to the "repeat_every_km" field.
func (m *ServiceScheduleMutation) ResetRepeatEveryKm() {
	m.repeat_every_km = nil
	m.addrepeat_every_km = nil
	delete(m.clearedFields, serviceschedule.FieldRepeatEveryKm)
}

// SetStartsAtKm sets the "starts_at_km" field.
func (m *ServiceScheduleMutation) SetStartsAtKm(f float64) {
	m.starts_at_km = &f
	m.addstarts_at_km = nil
}

// StartsAtKm returns the value of the "starts_at_km" field in the mutation.
func (m *ServiceScheduleMutation) StartsAtKm() (r float64, exists bool) {
	v := m.starts_at_km
	if v == nil {
		return
	}
	return *v, true
}

// OldStartsAtKm returns the old "starts_at_km" field's value of the ServiceSchedule entity.
// If the ServiceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceScheduleMutation) OldStartsAtKm(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartsAtKm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartsAtKm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartsAtKm: %w", err)
	}
	return oldValue.StartsAtKm, nil
}

// AddStartsAtKm adds f to the "starts_at_km" field.
func (m *ServiceScheduleMutation) AddStartsAtKm(f float64) {
	if m.addstarts_at_km != nil {
		*m.addstarts_at_km += f
	} else {
		m.addstarts_at_km = &f
	}
}

// AddedStartsAtKm returns the value that was added to the "starts_at_km" field in this mutation.
func (m *ServiceScheduleMutation) AddedStartsAtKm() (r float64, exists bool) {
	v := m.addstarts_at_km
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartsAtKm clears the value of the "starts_at_km" field.
func (m *ServiceScheduleMutation) ClearStartsAtKm() {
	m.starts_at_km = nil
	m.addstarts_at_km = nil
	m.clearedFields[serviceschedule.FieldStartsAtKm] = struct{}{}
}

// StartsAtKmCleared returns if the "starts_at_km" field was cleared in this mutation.
func (m *ServiceScheduleMutation) StartsAtKmCleared() bool {
	_, ok := m.clearedFields[serviceschedule.FieldStartsAtKm]
	return ok
}

// ResetStartsAtKm resets all changes to the "starts_at_km" field.
func (m *ServiceScheduleMutation) ResetStartsAtKm() {
	m.starts_at_km = nil
	m.addstarts_at_km = nil
	delete(m.clearedFields, serviceschedule.FieldStartsAtKm)
}

// SetRepeatEveryMonths sets the "repeat_every_months" field.
func (m *ServiceScheduleMutation) SetRepeatEveryMonths(i int) {
	m.repeat_every_months = &i
	m.addrepeat_every_months = nil
}

// RepeatEveryMonths returns the value of the "repeat_every_months" field in the mutation.
func (m *ServiceScheduleMutation) RepeatEveryMonths() (r int, exists bool) {
	v := m.repeat_every_months
	if v == nil {
		return
	}
	return *v, true
}

// OldRepeatEveryMonths returns the old "repeat_every_months" field's value of the ServiceSchedule entity.
// If the ServiceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceScheduleMutation) OldRepeatEveryMonths(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepeatEveryMonths is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepeatEveryMonths requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepeatEveryMonths: %w", err)
	}
	return oldValue.RepeatEveryMonths, nil
}

// AddRepeatEveryMonths adds i to the "repeat_every_months" field.
func (m *ServiceScheduleMutation) AddRepeatEveryMonths(i int) {
	if m.addrepeat_every_months != nil {
		*m.addrepeat_every_months += i
	} else {
		m.addrepeat_every_months = &i
	}
}

// AddedRepeatEveryMonths returns the value that was added to the "repeat_every_months" field in this mutation.
func (m *ServiceScheduleMutation) AddedRepeatEveryMonths() (r int, exists bool) {
	v := m.addrepeat_every_months
	if v == nil {
		return
	}
	return *v, true
}

// ClearRepeatEveryMonths clears the value of the "repeat_every_months" field.
func (m *ServiceScheduleMutation) ClearRepeatEveryMonths() {
	m.repeat_every_months = nil
	m.addrepeat_every_months = nil
	m.clearedFields[serviceschedule.FieldRepeatEveryMonths] = struct{}{}
}

// RepeatEveryMonthsCleared returns if the "repeat_every_months" field was cleared in this mutation.
func (m *ServiceScheduleMutation) RepeatEveryMonthsCleared() bool {
	_, ok := m.clearedFields[serviceschedule.FieldRepeatEveryMonths]
	return ok
}

// ResetRepeatEveryMonths resets all changes to the "repeat_every_months" field.
func (m *ServiceScheduleMutation) ResetRepeatEveryMonths() {
	m.repeat_every_months = nil
	m.addrepeat_every_months = nil
	delete(m.clearedFields, serviceschedule.FieldRepeatEveryMonths)
}

// SetStartsAtMonths sets the "starts_at_months" field.
func (m *ServiceScheduleMutation) SetStartsAtMonths(i int) {
	m.starts_at_months = &i
	m.addstarts_at_months = nil
}

// StartsAtMonths returns the value of the "starts_at_months" field in the mutation.
func (m *ServiceScheduleMutation) StartsAtMonths() (r int, exists bool) {
	v := m.starts_at_months
	if v == nil {
		return
	}
	return *v, true
}

// OldStartsAtMonths returns the old "starts_at_months" field's value of the ServiceSchedule entity.
// If the ServiceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceScheduleMutation) OldStartsAtMonths(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartsAtMonths is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartsAtMonths requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartsAtMonths: %w", err)
	}
	return oldValue.StartsAtMonths, nil
}

// AddStartsAtMonths adds i to the "starts_at_months" field.
func (m *ServiceScheduleMutation) AddStartsAtMonths(i int) {
	if m.addstarts_at_months != nil {
		*m.addstarts_at_months += i
	} else {
		m.addstarts_at_months = &i
	}
}

// AddedStartsAtMonths returns the value that was added to the "starts_at_months" field in this mutation.
func (m *ServiceScheduleMutation) AddedStartsAtMonths() (r int, exists bool) {
	v := m.addstarts_at_months
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartsAtMonths clears the value of the "starts_at_months" field.
func (m *ServiceScheduleMutation) ClearStartsAtMonths() {
	m.starts_at_months = nil
	m.addstarts_at_months = nil
	m.clearedFields[serviceschedule.FieldStartsAtMonths] = struct{}{}
}

// StartsAtMonthsCleared returns if the "starts_at_months" field was cleared in this mutation.
func (m *ServiceScheduleMutation) StartsAtMonthsCleared() bool {
	_, ok := m.clearedFields[serviceschedule.FieldStartsAtMonths]
	return ok
}

// ResetStartsAtMonths resets all changes to the "starts_at_months" field.
func (m *ServiceScheduleMutation) ResetStartsAtMonths() {
	m.starts_at_months = nil
	m.addstarts_at_months = nil
	delete(m.clearedFields, serviceschedule.FieldStartsAtMonths)
}

// SetNotes sets the "notes" field.
func (m *ServiceScheduleMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *ServiceScheduleMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the ServiceSchedule entity.
// If the ServiceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceScheduleMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *ServiceScheduleMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[serviceschedule.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *ServiceScheduleMutation) NotesCleared() bool {
	_, ok := m.clearedFields[serviceschedule.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *ServiceScheduleMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, serviceschedule.FieldNotes)
}

// SetArchived sets the "archived" field.
func (m *ServiceScheduleMutation) SetArchived(b bool) {
	m.archived = &b
}

// Archived returns the value of the "archived" field in the mutation.
func (m *ServiceScheduleMutation) Archived() (r bool, exists bool) {
	v := m.archived
	if v == nil {
		return
	}
	return *v, true
}

// OldArchived returns the old "archived" field's value of the ServiceSchedule entity.
// If the ServiceSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceScheduleMutation) OldArchived(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchived is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchived requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchived: %w", err)
	}
	return oldValue.Archived, nil
}

// ResetArchived resets all changes to the "archived" field.
func (m *ServiceScheduleMutation) ResetArchived() {
	m.archived = nil
}

// SetCarID sets the "car" edge to the Car entity by id.
func (m *ServiceScheduleMutation) SetCarID(id uuid.UUID) {
	m.car = &id
}

// ClearCar clears the "car" edge to the Car entity.
func (m *ServiceScheduleMutation) ClearCar() {
	m.clearedcar = true
}

// CarCleared reports if the "car" edge to the Car entity was cleared.
func (m *ServiceScheduleMutation) CarCleared() bool {
	return m.clearedcar
}

// CarID returns the "car" edge ID in the mutation.
func (m *ServiceScheduleMutation) CarID() (id uuid.UUID, exists bool) {
	if m.car != nil {
		return *m.car, true
	}
	return
}

// CarIDs returns the "car" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *ServiceScheduleMutation) CarIDs() (ids []uuid.UUID) {
	if id := m.car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar resets all changes to the "car" edge.
func (m *ServiceScheduleMutation) ResetCar() {
	m.car = nil
	m.clearedcar = false
}

// AddItemIDs adds the "items" edge to the ServiceItem entity by ids.
func (m *ServiceScheduleMutation) AddItemIDs(ids ...uuid.UUID) {
	if m.items == nil {
		m.items = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the ServiceItem entity.
func (m *ServiceScheduleMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the ServiceItem entity was cleared.
func (m *ServiceScheduleMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the ServiceItem entity by IDs.
func (m *ServiceScheduleMutation) RemoveItemIDs(ids ...uuid.UUID) {
	if m.removeditems == nil {
		m.removeditems = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the ServiceItem entity.
func (m *ServiceScheduleMutation) RemovedItemsIDs() (ids []uuid.UUID) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *ServiceScheduleMutation) ItemsIDs() (ids []uuid.UUID) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *ServiceScheduleMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// AddLogIDs adds the "logs" edge to the ServiceLog entity by ids.
func (m *ServiceScheduleMutation) AddLogIDs(ids ...uuid.UUID) {
	if m.logs == nil {
		m.logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the ServiceLog entity.
func (m *ServiceScheduleMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the ServiceLog entity was cleared.
func (m *ServiceScheduleMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the ServiceLog entity by IDs.
func (m *ServiceScheduleMutation) RemoveLogIDs(ids ...uuid.UUID) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the ServiceLog entity.
func (m *ServiceScheduleMutation) RemovedLogsIDs() (ids []uuid.UUID) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *ServiceScheduleMutation) LogsIDs() (ids []uuid.UUID) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *ServiceScheduleMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// Where appends a list predicates to the ServiceScheduleMutation builder.
func (m *ServiceScheduleMutation) Where(ps ...predicate.ServiceSchedule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceScheduleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceScheduleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceSchedule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceScheduleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceScheduleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceSchedule).
func (m *ServiceScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceScheduleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, serviceschedule.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, serviceschedule.FieldUpdateTime)
	}
	if m.title != nil {
		fields = append(fields, serviceschedule.FieldTitle)
	}
	if m.repeat_every_km != nil {
		fields = append(fields, serviceschedule.FieldRepeatEveryKm)
	}
	if m.starts_at_km != nil {
		fields = append(fields, serviceschedule.FieldStartsAtKm)
	}
	if m.repeat_every_months != nil {
		fields = append(fields, serviceschedule.FieldRepeatEveryMonths)
	}
	if m.starts_at_months != nil {
		fields = append(fields, serviceschedule.FieldStartsAtMonths)
	}
	if m.notes != nil {
		fields = append(fields, serviceschedule.FieldNotes)
	}
	if m.archived != nil {
		fields = append(fields, serviceschedule.FieldArchived)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case serviceschedule.FieldCreateTime:
		return m.CreateTime()
	case serviceschedule.FieldUpdateTime:
		return m.UpdateTime()
	case serviceschedule.FieldTitle:
		return m.Title()
	case serviceschedule.FieldRepeatEveryKm:
		return m.RepeatEveryKm()
	case serviceschedule.FieldStartsAtKm:
		return m.StartsAtKm()
	case serviceschedule.FieldRepeatEveryMonths:
		return m.RepeatEveryMonths()
	case serviceschedule.FieldStartsAtMonths:
		return m.StartsAtMonths()
	case serviceschedule.FieldNotes:
		return m.Notes()
	case serviceschedule.FieldArchived:
		return m.Archived()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case serviceschedule.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case serviceschedule.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case serviceschedule.FieldTitle:
		return m.OldTitle(ctx)
	case serviceschedule.FieldRepeatEveryKm:
		return m.OldRepeatEveryKm(ctx)
	case serviceschedule.FieldStartsAtKm:
		return m.OldStartsAtKm(ctx)
	case serviceschedule.FieldRepeatEveryMonths:
		return m.OldRepeatEveryMonths(ctx)
	case serviceschedule.FieldStartsAtMonths:
		return m.OldStartsAtMonths(ctx)
	case serviceschedule.FieldNotes:
		return m.OldNotes(ctx)
	case serviceschedule.FieldArchived:
		return m.OldArchived(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceSchedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case serviceschedule.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case serviceschedule.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case serviceschedule.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case serviceschedule.FieldRepeatEveryKm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepeatEveryKm(v)
		return nil
	case serviceschedule.FieldStartsAtKm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartsAtKm(v)
		return nil
	case serviceschedule.FieldRepeatEveryMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepeatEveryMonths(v)
		return nil
	case serviceschedule.FieldStartsAtMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartsAtMonths(v)
		return nil
	case serviceschedule.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case serviceschedule.FieldArchived:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchived(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceSchedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceScheduleMutation) AddedFields() []string {
	var fields []string
	if m.addrepeat_every_km != nil {
		fields = append(fields, serviceschedule.FieldRepeatEveryKm)
	}
	if m.addstarts_at_km != nil {
		fields = append(fields, serviceschedule.FieldStartsAtKm)
	}
	if m.addrepeat_every_months != nil {
		fields = append(fields, serviceschedule.FieldRepeatEveryMonths)
	}
	if m.addstarts_at_months != nil {
		fields = append(fields, serviceschedule.FieldStartsAtMonths)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceScheduleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case serviceschedule.FieldRepeatEveryKm:
		return m.AddedRepeatEveryKm()
	case serviceschedule.FieldStartsAtKm:
		return m.AddedStartsAtKm()
	case serviceschedule.FieldRepeatEveryMonths:
		return m.AddedRepeatEveryMonths()
	case serviceschedule.FieldStartsAtMonths:
		return m.AddedStartsAtMonths()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case serviceschedule.FieldRepeatEveryKm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRepeatEveryKm(v)
		return nil
	case serviceschedule.FieldStartsAtKm:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartsAtKm(v)
		return nil
	case serviceschedule.FieldRepeatEveryMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRepeatEveryMonths(v)
		return nil
	case serviceschedule.FieldStartsAtMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartsAtMonths(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceSchedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceScheduleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(serviceschedule.FieldRepeatEveryKm) {
		fields = append(fields, serviceschedule.FieldRepeatEveryKm)
	}
	if m.FieldCleared(serviceschedule.FieldStartsAtKm) {
		fields = append(fields, serviceschedule.FieldStartsAtKm)
	}
	if m.FieldCleared(serviceschedule.FieldRepeatEveryMonths) {
		fields = append(fields, serviceschedule.FieldRepeatEveryMonths)
	}
	if m.FieldCleared(serviceschedule.FieldStartsAtMonths) {
		fields = append(fields, serviceschedule.FieldStartsAtMonths)
	}
	if m.FieldCleared(serviceschedule.FieldNotes) {
		fields = append(fields, serviceschedule.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceScheduleMutation) ClearField(name string) error {
	switch name {
	case serviceschedule.FieldRepeatEveryKm:
		m.ClearRepeatEveryKm()
		return nil
	case serviceschedule.FieldStartsAtKm:
		m.ClearStartsAtKm()
		return nil
	case serviceschedule.FieldRepeatEveryMonths:
		m.ClearRepeatEveryMonths()
		return nil
	case serviceschedule.FieldStartsAtMonths:
		m.ClearStartsAtMonths()
		return nil
	case serviceschedule.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown ServiceSchedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceScheduleMutation) ResetField(name string) error {
	switch name {
	case serviceschedule.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case serviceschedule.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case serviceschedule.FieldTitle:
		m.ResetTitle()
		return nil
	case serviceschedule.FieldRepeatEveryKm:
		m.ResetRepeatEveryKm()
		return nil
	case serviceschedule.FieldStartsAtKm:
		m.ResetStartsAtKm()
		return nil
	case serviceschedule.FieldRepeatEveryMonths:
		m.ResetRepeatEveryMonths()
		return nil
	case serviceschedule.FieldStartsAtMonths:
		m.ResetStartsAtMonths()
		return nil
	case serviceschedule.FieldNotes:
		m.ResetNotes()
		return nil
	case serviceschedule.FieldArchived:
		m.ResetArchived()
		return nil
	}
	return fmt.Errorf("unknown ServiceSchedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.car != nil {
		edges = append(edges, serviceschedule.EdgeCar)
	}
	if m.items != nil {
		edges = append(edges, serviceschedule.EdgeItems)
	}
	if m.logs != nil {
		edges = append(edges, serviceschedule.EdgeLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case serviceschedule.EdgeCar:
		if id := m.car; id != nil {
			return []ent.Value{*id}
		}
	case serviceschedule.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case serviceschedule.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeditems != nil {
		edges = append(edges, serviceschedule.EdgeItems)
	}
	if m.removedlogs != nil {
		edges = append(edges, serviceschedule.EdgeLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceScheduleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case serviceschedule.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	case serviceschedule.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcar {
		edges = append(edges, serviceschedule.EdgeCar)
	}
	if m.cleareditems {
		edges = append(edges, serviceschedule.EdgeItems)
	}
	if m.clearedlogs {
		edges = append(edges, serviceschedule.EdgeLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case serviceschedule.EdgeCar:
		return m.clearedcar
	case serviceschedule.EdgeItems:
		return m.cleareditems
	case serviceschedule.EdgeLogs:
		return m.clearedlogs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceScheduleMutation) ClearEdge(name string) error {
	switch name {
	case serviceschedule.EdgeCar:
		m.ClearCar()
		return nil
	}
	return fmt.Errorf("unknown ServiceSchedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceScheduleMutation) ResetEdge(name string) error {
	switch name {
	case serviceschedule.EdgeCar:
		m.ResetCar()
		return nil
	case serviceschedule.EdgeItems:
		m.ResetItems()
		return nil
	case serviceschedule.EdgeLogs:
		m.ResetLogs()
		return nil
	}
	return fmt.Errorf("unknown ServiceSchedule edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	create_time    *time.Time
	update_time    *time.Time
	email          *string
	clearedFields  map[string]struct{}
	cars           map[uuid.UUID]struct{}
	removedcars    map[uuid.UUID]struct{}
	clearedcars    bool
	profile        *uuid.UUID
	clearedprofile bool
	done           bool
	oldValue       func(context.Context) (*User, error)
	predicates     []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// AddCarIDs adds the "cars" edge to the Car entity by ids.
func (m *UserMutation) AddCarIDs(ids ...uuid.UUID) {
	if m.cars == nil {
		m.cars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.cars[ids[i]] = struct{}{}
	}
}

// ClearCars clears the "cars" edge to the Car entity.
func (m *UserMutation) ClearCars() {
	m.clearedcars = true
}

// CarsCleared reports if the "cars" edge to the Car entity was cleared.
func (m *UserMutation) CarsCleared() bool {
	return m.clearedcars
}

// RemoveCarIDs removes the "cars" edge to the Car entity by IDs.
func (m *UserMutation) RemoveCarIDs(ids ...uuid.UUID) {
	if m.removedcars == nil {
		m.removedcars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.cars, ids[i])
		m.removedcars[ids[i]] = struct{}{}
	}
}

// RemovedCars returns the removed IDs of the "cars" edge to the Car entity.
func (m *UserMutation) RemovedCarsIDs() (ids []uuid.UUID) {
	for id := range m.removedcars {
		ids = append(ids, id)
	}
	return
}

// CarsIDs returns the "cars" edge IDs in the mutation.
func (m *UserMutation) CarsIDs() (ids []uuid.UUID) {
	for id := range m.cars {
		ids = append(ids, id)
	}
	return
}

// ResetCars resets all changes to the "cars" edge.
func (m *UserMutation) ResetCars() {
	m.cars = nil
	m.clearedcars = false
	m.removedcars = nil
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *UserMutation) SetProfileID(id uuid.UUID) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *UserMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *UserMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *UserMutation) ProfileID() (id uuid.UUID, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ProfileIDs() (ids []uuid.UUID) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *UserMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cars != nil {
		edges = append(edges, user.EdgeCars)
	}
	if m.profile != nil {
		edges = append(edges, user.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCars:
		ids := make([]ent.Value, 0, len(m.cars))
		for id := range m.cars {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcars != nil {
		edges = append(edges, user.EdgeCars)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCars:
		ids := make([]ent.Value, 0, len(m.removedcars))
		for id := range m.removedcars {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcars {
		edges = append(edges, user.EdgeCars)
	}
	if m.clearedprofile {
		edges = append(edges, user.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeCars:
		return m.clearedcars
	case user.EdgeProfile:
		return m.clearedprofile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeCars:
		m.ResetCars()
		return nil
	case user.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

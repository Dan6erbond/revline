// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/Dan6erbond/revline/ent/album"
	"github.com/Dan6erbond/revline/ent/car"
	"github.com/Dan6erbond/revline/ent/checkoutsession"
	"github.com/Dan6erbond/revline/ent/document"
	"github.com/Dan6erbond/revline/ent/dragresult"
	"github.com/Dan6erbond/revline/ent/dragsession"
	"github.com/Dan6erbond/revline/ent/dynoresult"
	"github.com/Dan6erbond/revline/ent/dynosession"
	"github.com/Dan6erbond/revline/ent/expense"
	"github.com/Dan6erbond/revline/ent/fuelup"
	"github.com/Dan6erbond/revline/ent/media"
	"github.com/Dan6erbond/revline/ent/mod"
	"github.com/Dan6erbond/revline/ent/modproductoption"
	"github.com/Dan6erbond/revline/ent/modproductoptionpreview"
	"github.com/Dan6erbond/revline/ent/odometerreading"
	"github.com/Dan6erbond/revline/ent/profile"
	"github.com/Dan6erbond/revline/ent/serviceitem"
	"github.com/Dan6erbond/revline/ent/servicelog"
	"github.com/Dan6erbond/revline/ent/serviceschedule"
	"github.com/Dan6erbond/revline/ent/subscription"
	"github.com/Dan6erbond/revline/ent/task"
	"github.com/Dan6erbond/revline/ent/user"
	"github.com/Dan6erbond/revline/ent/usersettings"
	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[uuid.UUID]
	PageInfo       = entgql.PageInfo[uuid.UUID]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// AlbumEdge is the edge representation of Album.
type AlbumEdge struct {
	Node   *Album `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// AlbumConnection is the connection containing edges to Album.
type AlbumConnection struct {
	Edges      []*AlbumEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *AlbumConnection) build(nodes []*Album, pager *albumPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Album
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Album {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Album {
			return nodes[i]
		}
	}
	c.Edges = make([]*AlbumEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AlbumEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AlbumPaginateOption enables pagination customization.
type AlbumPaginateOption func(*albumPager) error

// WithAlbumOrder configures pagination ordering.
func WithAlbumOrder(order *AlbumOrder) AlbumPaginateOption {
	if order == nil {
		order = DefaultAlbumOrder
	}
	o := *order
	return func(pager *albumPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAlbumOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAlbumFilter configures pagination filter.
func WithAlbumFilter(filter func(*AlbumQuery) (*AlbumQuery, error)) AlbumPaginateOption {
	return func(pager *albumPager) error {
		if filter == nil {
			return errors.New("AlbumQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type albumPager struct {
	reverse bool
	order   *AlbumOrder
	filter  func(*AlbumQuery) (*AlbumQuery, error)
}

func newAlbumPager(opts []AlbumPaginateOption, reverse bool) (*albumPager, error) {
	pager := &albumPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAlbumOrder
	}
	return pager, nil
}

func (p *albumPager) applyFilter(query *AlbumQuery) (*AlbumQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *albumPager) toCursor(a *Album) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *albumPager) applyCursors(query *AlbumQuery, after, before *Cursor) (*AlbumQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAlbumOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *albumPager) applyOrder(query *AlbumQuery) *AlbumQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAlbumOrder.Field {
		query = query.Order(DefaultAlbumOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *albumPager) orderExpr(query *AlbumQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAlbumOrder.Field {
			b.Comma().Ident(DefaultAlbumOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Album.
func (a *AlbumQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AlbumPaginateOption,
) (*AlbumConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAlbumPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AlbumConnection{Edges: []*AlbumEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := a.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if a, err = pager.applyCursors(a, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	a = pager.applyOrder(a)
	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// AlbumOrderField defines the ordering field of Album.
type AlbumOrderField struct {
	// Value extracts the ordering value from the given Album.
	Value    func(*Album) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) album.OrderOption
	toCursor func(*Album) Cursor
}

// AlbumOrder defines the ordering of Album.
type AlbumOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *AlbumOrderField `json:"field"`
}

// DefaultAlbumOrder is the default ordering of Album.
var DefaultAlbumOrder = &AlbumOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AlbumOrderField{
		Value: func(a *Album) (ent.Value, error) {
			return a.ID, nil
		},
		column: album.FieldID,
		toTerm: album.ByID,
		toCursor: func(a *Album) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Album into AlbumEdge.
func (a *Album) ToEdge(order *AlbumOrder) *AlbumEdge {
	if order == nil {
		order = DefaultAlbumOrder
	}
	return &AlbumEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// CarEdge is the edge representation of Car.
type CarEdge struct {
	Node   *Car   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// CarConnection is the connection containing edges to Car.
type CarConnection struct {
	Edges      []*CarEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

func (c *CarConnection) build(nodes []*Car, pager *carPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Car
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Car {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Car {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarPaginateOption enables pagination customization.
type CarPaginateOption func(*carPager) error

// WithCarOrder configures pagination ordering.
func WithCarOrder(order *CarOrder) CarPaginateOption {
	if order == nil {
		order = DefaultCarOrder
	}
	o := *order
	return func(pager *carPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarFilter configures pagination filter.
func WithCarFilter(filter func(*CarQuery) (*CarQuery, error)) CarPaginateOption {
	return func(pager *carPager) error {
		if filter == nil {
			return errors.New("CarQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carPager struct {
	reverse bool
	order   *CarOrder
	filter  func(*CarQuery) (*CarQuery, error)
}

func newCarPager(opts []CarPaginateOption, reverse bool) (*carPager, error) {
	pager := &carPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarOrder
	}
	return pager, nil
}

func (p *carPager) applyFilter(query *CarQuery) (*CarQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carPager) toCursor(c *Car) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *carPager) applyCursors(query *CarQuery, after, before *Cursor) (*CarQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carPager) applyOrder(query *CarQuery) *CarQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarOrder.Field {
		query = query.Order(DefaultCarOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carPager) orderExpr(query *CarQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarOrder.Field {
			b.Comma().Ident(DefaultCarOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Car.
func (c *CarQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarPaginateOption,
) (*CarConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CarConnection{Edges: []*CarEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarOrderField defines the ordering field of Car.
type CarOrderField struct {
	// Value extracts the ordering value from the given Car.
	Value    func(*Car) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) car.OrderOption
	toCursor func(*Car) Cursor
}

// CarOrder defines the ordering of Car.
type CarOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *CarOrderField `json:"field"`
}

// DefaultCarOrder is the default ordering of Car.
var DefaultCarOrder = &CarOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarOrderField{
		Value: func(c *Car) (ent.Value, error) {
			return c.ID, nil
		},
		column: car.FieldID,
		toTerm: car.ByID,
		toCursor: func(c *Car) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Car into CarEdge.
func (c *Car) ToEdge(order *CarOrder) *CarEdge {
	if order == nil {
		order = DefaultCarOrder
	}
	return &CarEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CheckoutSessionEdge is the edge representation of CheckoutSession.
type CheckoutSessionEdge struct {
	Node   *CheckoutSession `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// CheckoutSessionConnection is the connection containing edges to CheckoutSession.
type CheckoutSessionConnection struct {
	Edges      []*CheckoutSessionEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *CheckoutSessionConnection) build(nodes []*CheckoutSession, pager *checkoutsessionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CheckoutSession
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CheckoutSession {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CheckoutSession {
			return nodes[i]
		}
	}
	c.Edges = make([]*CheckoutSessionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CheckoutSessionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CheckoutSessionPaginateOption enables pagination customization.
type CheckoutSessionPaginateOption func(*checkoutsessionPager) error

// WithCheckoutSessionOrder configures pagination ordering.
func WithCheckoutSessionOrder(order *CheckoutSessionOrder) CheckoutSessionPaginateOption {
	if order == nil {
		order = DefaultCheckoutSessionOrder
	}
	o := *order
	return func(pager *checkoutsessionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCheckoutSessionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCheckoutSessionFilter configures pagination filter.
func WithCheckoutSessionFilter(filter func(*CheckoutSessionQuery) (*CheckoutSessionQuery, error)) CheckoutSessionPaginateOption {
	return func(pager *checkoutsessionPager) error {
		if filter == nil {
			return errors.New("CheckoutSessionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type checkoutsessionPager struct {
	reverse bool
	order   *CheckoutSessionOrder
	filter  func(*CheckoutSessionQuery) (*CheckoutSessionQuery, error)
}

func newCheckoutSessionPager(opts []CheckoutSessionPaginateOption, reverse bool) (*checkoutsessionPager, error) {
	pager := &checkoutsessionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCheckoutSessionOrder
	}
	return pager, nil
}

func (p *checkoutsessionPager) applyFilter(query *CheckoutSessionQuery) (*CheckoutSessionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *checkoutsessionPager) toCursor(cs *CheckoutSession) Cursor {
	return p.order.Field.toCursor(cs)
}

func (p *checkoutsessionPager) applyCursors(query *CheckoutSessionQuery, after, before *Cursor) (*CheckoutSessionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCheckoutSessionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *checkoutsessionPager) applyOrder(query *CheckoutSessionQuery) *CheckoutSessionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCheckoutSessionOrder.Field {
		query = query.Order(DefaultCheckoutSessionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *checkoutsessionPager) orderExpr(query *CheckoutSessionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCheckoutSessionOrder.Field {
			b.Comma().Ident(DefaultCheckoutSessionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CheckoutSession.
func (cs *CheckoutSessionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CheckoutSessionPaginateOption,
) (*CheckoutSessionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCheckoutSessionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cs, err = pager.applyFilter(cs); err != nil {
		return nil, err
	}
	conn := &CheckoutSessionConnection{Edges: []*CheckoutSessionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cs.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cs, err = pager.applyCursors(cs, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cs.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cs.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cs = pager.applyOrder(cs)
	nodes, err := cs.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CheckoutSessionOrderField defines the ordering field of CheckoutSession.
type CheckoutSessionOrderField struct {
	// Value extracts the ordering value from the given CheckoutSession.
	Value    func(*CheckoutSession) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) checkoutsession.OrderOption
	toCursor func(*CheckoutSession) Cursor
}

// CheckoutSessionOrder defines the ordering of CheckoutSession.
type CheckoutSessionOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *CheckoutSessionOrderField `json:"field"`
}

// DefaultCheckoutSessionOrder is the default ordering of CheckoutSession.
var DefaultCheckoutSessionOrder = &CheckoutSessionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CheckoutSessionOrderField{
		Value: func(cs *CheckoutSession) (ent.Value, error) {
			return cs.ID, nil
		},
		column: checkoutsession.FieldID,
		toTerm: checkoutsession.ByID,
		toCursor: func(cs *CheckoutSession) Cursor {
			return Cursor{ID: cs.ID}
		},
	},
}

// ToEdge converts CheckoutSession into CheckoutSessionEdge.
func (cs *CheckoutSession) ToEdge(order *CheckoutSessionOrder) *CheckoutSessionEdge {
	if order == nil {
		order = DefaultCheckoutSessionOrder
	}
	return &CheckoutSessionEdge{
		Node:   cs,
		Cursor: order.Field.toCursor(cs),
	}
}

// DocumentEdge is the edge representation of Document.
type DocumentEdge struct {
	Node   *Document `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// DocumentConnection is the connection containing edges to Document.
type DocumentConnection struct {
	Edges      []*DocumentEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *DocumentConnection) build(nodes []*Document, pager *documentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Document
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Document {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Document {
			return nodes[i]
		}
	}
	c.Edges = make([]*DocumentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DocumentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DocumentPaginateOption enables pagination customization.
type DocumentPaginateOption func(*documentPager) error

// WithDocumentOrder configures pagination ordering.
func WithDocumentOrder(order *DocumentOrder) DocumentPaginateOption {
	if order == nil {
		order = DefaultDocumentOrder
	}
	o := *order
	return func(pager *documentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDocumentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDocumentFilter configures pagination filter.
func WithDocumentFilter(filter func(*DocumentQuery) (*DocumentQuery, error)) DocumentPaginateOption {
	return func(pager *documentPager) error {
		if filter == nil {
			return errors.New("DocumentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type documentPager struct {
	reverse bool
	order   *DocumentOrder
	filter  func(*DocumentQuery) (*DocumentQuery, error)
}

func newDocumentPager(opts []DocumentPaginateOption, reverse bool) (*documentPager, error) {
	pager := &documentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDocumentOrder
	}
	return pager, nil
}

func (p *documentPager) applyFilter(query *DocumentQuery) (*DocumentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *documentPager) toCursor(d *Document) Cursor {
	return p.order.Field.toCursor(d)
}

func (p *documentPager) applyCursors(query *DocumentQuery, after, before *Cursor) (*DocumentQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDocumentOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *documentPager) applyOrder(query *DocumentQuery) *DocumentQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDocumentOrder.Field {
		query = query.Order(DefaultDocumentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *documentPager) orderExpr(query *DocumentQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDocumentOrder.Field {
			b.Comma().Ident(DefaultDocumentOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Document.
func (d *DocumentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DocumentPaginateOption,
) (*DocumentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDocumentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if d, err = pager.applyFilter(d); err != nil {
		return nil, err
	}
	conn := &DocumentConnection{Edges: []*DocumentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := d.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if d, err = pager.applyCursors(d, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		d.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := d.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	d = pager.applyOrder(d)
	nodes, err := d.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DocumentOrderField defines the ordering field of Document.
type DocumentOrderField struct {
	// Value extracts the ordering value from the given Document.
	Value    func(*Document) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) document.OrderOption
	toCursor func(*Document) Cursor
}

// DocumentOrder defines the ordering of Document.
type DocumentOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *DocumentOrderField `json:"field"`
}

// DefaultDocumentOrder is the default ordering of Document.
var DefaultDocumentOrder = &DocumentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DocumentOrderField{
		Value: func(d *Document) (ent.Value, error) {
			return d.ID, nil
		},
		column: document.FieldID,
		toTerm: document.ByID,
		toCursor: func(d *Document) Cursor {
			return Cursor{ID: d.ID}
		},
	},
}

// ToEdge converts Document into DocumentEdge.
func (d *Document) ToEdge(order *DocumentOrder) *DocumentEdge {
	if order == nil {
		order = DefaultDocumentOrder
	}
	return &DocumentEdge{
		Node:   d,
		Cursor: order.Field.toCursor(d),
	}
}

// DragResultEdge is the edge representation of DragResult.
type DragResultEdge struct {
	Node   *DragResult `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// DragResultConnection is the connection containing edges to DragResult.
type DragResultConnection struct {
	Edges      []*DragResultEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *DragResultConnection) build(nodes []*DragResult, pager *dragresultPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DragResult
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DragResult {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DragResult {
			return nodes[i]
		}
	}
	c.Edges = make([]*DragResultEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DragResultEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DragResultPaginateOption enables pagination customization.
type DragResultPaginateOption func(*dragresultPager) error

// WithDragResultOrder configures pagination ordering.
func WithDragResultOrder(order *DragResultOrder) DragResultPaginateOption {
	if order == nil {
		order = DefaultDragResultOrder
	}
	o := *order
	return func(pager *dragresultPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDragResultOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDragResultFilter configures pagination filter.
func WithDragResultFilter(filter func(*DragResultQuery) (*DragResultQuery, error)) DragResultPaginateOption {
	return func(pager *dragresultPager) error {
		if filter == nil {
			return errors.New("DragResultQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dragresultPager struct {
	reverse bool
	order   *DragResultOrder
	filter  func(*DragResultQuery) (*DragResultQuery, error)
}

func newDragResultPager(opts []DragResultPaginateOption, reverse bool) (*dragresultPager, error) {
	pager := &dragresultPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDragResultOrder
	}
	return pager, nil
}

func (p *dragresultPager) applyFilter(query *DragResultQuery) (*DragResultQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dragresultPager) toCursor(dr *DragResult) Cursor {
	return p.order.Field.toCursor(dr)
}

func (p *dragresultPager) applyCursors(query *DragResultQuery, after, before *Cursor) (*DragResultQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDragResultOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *dragresultPager) applyOrder(query *DragResultQuery) *DragResultQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDragResultOrder.Field {
		query = query.Order(DefaultDragResultOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *dragresultPager) orderExpr(query *DragResultQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDragResultOrder.Field {
			b.Comma().Ident(DefaultDragResultOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DragResult.
func (dr *DragResultQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DragResultPaginateOption,
) (*DragResultConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDragResultPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if dr, err = pager.applyFilter(dr); err != nil {
		return nil, err
	}
	conn := &DragResultConnection{Edges: []*DragResultEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := dr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if dr, err = pager.applyCursors(dr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		dr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	dr = pager.applyOrder(dr)
	nodes, err := dr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DragResultOrderField defines the ordering field of DragResult.
type DragResultOrderField struct {
	// Value extracts the ordering value from the given DragResult.
	Value    func(*DragResult) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) dragresult.OrderOption
	toCursor func(*DragResult) Cursor
}

// DragResultOrder defines the ordering of DragResult.
type DragResultOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *DragResultOrderField `json:"field"`
}

// DefaultDragResultOrder is the default ordering of DragResult.
var DefaultDragResultOrder = &DragResultOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DragResultOrderField{
		Value: func(dr *DragResult) (ent.Value, error) {
			return dr.ID, nil
		},
		column: dragresult.FieldID,
		toTerm: dragresult.ByID,
		toCursor: func(dr *DragResult) Cursor {
			return Cursor{ID: dr.ID}
		},
	},
}

// ToEdge converts DragResult into DragResultEdge.
func (dr *DragResult) ToEdge(order *DragResultOrder) *DragResultEdge {
	if order == nil {
		order = DefaultDragResultOrder
	}
	return &DragResultEdge{
		Node:   dr,
		Cursor: order.Field.toCursor(dr),
	}
}

// DragSessionEdge is the edge representation of DragSession.
type DragSessionEdge struct {
	Node   *DragSession `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// DragSessionConnection is the connection containing edges to DragSession.
type DragSessionConnection struct {
	Edges      []*DragSessionEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *DragSessionConnection) build(nodes []*DragSession, pager *dragsessionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DragSession
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DragSession {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DragSession {
			return nodes[i]
		}
	}
	c.Edges = make([]*DragSessionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DragSessionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DragSessionPaginateOption enables pagination customization.
type DragSessionPaginateOption func(*dragsessionPager) error

// WithDragSessionOrder configures pagination ordering.
func WithDragSessionOrder(order *DragSessionOrder) DragSessionPaginateOption {
	if order == nil {
		order = DefaultDragSessionOrder
	}
	o := *order
	return func(pager *dragsessionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDragSessionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDragSessionFilter configures pagination filter.
func WithDragSessionFilter(filter func(*DragSessionQuery) (*DragSessionQuery, error)) DragSessionPaginateOption {
	return func(pager *dragsessionPager) error {
		if filter == nil {
			return errors.New("DragSessionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dragsessionPager struct {
	reverse bool
	order   *DragSessionOrder
	filter  func(*DragSessionQuery) (*DragSessionQuery, error)
}

func newDragSessionPager(opts []DragSessionPaginateOption, reverse bool) (*dragsessionPager, error) {
	pager := &dragsessionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDragSessionOrder
	}
	return pager, nil
}

func (p *dragsessionPager) applyFilter(query *DragSessionQuery) (*DragSessionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dragsessionPager) toCursor(ds *DragSession) Cursor {
	return p.order.Field.toCursor(ds)
}

func (p *dragsessionPager) applyCursors(query *DragSessionQuery, after, before *Cursor) (*DragSessionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDragSessionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *dragsessionPager) applyOrder(query *DragSessionQuery) *DragSessionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDragSessionOrder.Field {
		query = query.Order(DefaultDragSessionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *dragsessionPager) orderExpr(query *DragSessionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDragSessionOrder.Field {
			b.Comma().Ident(DefaultDragSessionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DragSession.
func (ds *DragSessionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DragSessionPaginateOption,
) (*DragSessionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDragSessionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ds, err = pager.applyFilter(ds); err != nil {
		return nil, err
	}
	conn := &DragSessionConnection{Edges: []*DragSessionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ds.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ds, err = pager.applyCursors(ds, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ds.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ds.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ds = pager.applyOrder(ds)
	nodes, err := ds.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DragSessionOrderField defines the ordering field of DragSession.
type DragSessionOrderField struct {
	// Value extracts the ordering value from the given DragSession.
	Value    func(*DragSession) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) dragsession.OrderOption
	toCursor func(*DragSession) Cursor
}

// DragSessionOrder defines the ordering of DragSession.
type DragSessionOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *DragSessionOrderField `json:"field"`
}

// DefaultDragSessionOrder is the default ordering of DragSession.
var DefaultDragSessionOrder = &DragSessionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DragSessionOrderField{
		Value: func(ds *DragSession) (ent.Value, error) {
			return ds.ID, nil
		},
		column: dragsession.FieldID,
		toTerm: dragsession.ByID,
		toCursor: func(ds *DragSession) Cursor {
			return Cursor{ID: ds.ID}
		},
	},
}

// ToEdge converts DragSession into DragSessionEdge.
func (ds *DragSession) ToEdge(order *DragSessionOrder) *DragSessionEdge {
	if order == nil {
		order = DefaultDragSessionOrder
	}
	return &DragSessionEdge{
		Node:   ds,
		Cursor: order.Field.toCursor(ds),
	}
}

// DynoResultEdge is the edge representation of DynoResult.
type DynoResultEdge struct {
	Node   *DynoResult `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// DynoResultConnection is the connection containing edges to DynoResult.
type DynoResultConnection struct {
	Edges      []*DynoResultEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *DynoResultConnection) build(nodes []*DynoResult, pager *dynoresultPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DynoResult
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DynoResult {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DynoResult {
			return nodes[i]
		}
	}
	c.Edges = make([]*DynoResultEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DynoResultEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DynoResultPaginateOption enables pagination customization.
type DynoResultPaginateOption func(*dynoresultPager) error

// WithDynoResultOrder configures pagination ordering.
func WithDynoResultOrder(order *DynoResultOrder) DynoResultPaginateOption {
	if order == nil {
		order = DefaultDynoResultOrder
	}
	o := *order
	return func(pager *dynoresultPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDynoResultOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDynoResultFilter configures pagination filter.
func WithDynoResultFilter(filter func(*DynoResultQuery) (*DynoResultQuery, error)) DynoResultPaginateOption {
	return func(pager *dynoresultPager) error {
		if filter == nil {
			return errors.New("DynoResultQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dynoresultPager struct {
	reverse bool
	order   *DynoResultOrder
	filter  func(*DynoResultQuery) (*DynoResultQuery, error)
}

func newDynoResultPager(opts []DynoResultPaginateOption, reverse bool) (*dynoresultPager, error) {
	pager := &dynoresultPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDynoResultOrder
	}
	return pager, nil
}

func (p *dynoresultPager) applyFilter(query *DynoResultQuery) (*DynoResultQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dynoresultPager) toCursor(dr *DynoResult) Cursor {
	return p.order.Field.toCursor(dr)
}

func (p *dynoresultPager) applyCursors(query *DynoResultQuery, after, before *Cursor) (*DynoResultQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDynoResultOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *dynoresultPager) applyOrder(query *DynoResultQuery) *DynoResultQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDynoResultOrder.Field {
		query = query.Order(DefaultDynoResultOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *dynoresultPager) orderExpr(query *DynoResultQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDynoResultOrder.Field {
			b.Comma().Ident(DefaultDynoResultOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DynoResult.
func (dr *DynoResultQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DynoResultPaginateOption,
) (*DynoResultConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDynoResultPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if dr, err = pager.applyFilter(dr); err != nil {
		return nil, err
	}
	conn := &DynoResultConnection{Edges: []*DynoResultEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := dr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if dr, err = pager.applyCursors(dr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		dr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	dr = pager.applyOrder(dr)
	nodes, err := dr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DynoResultOrderField defines the ordering field of DynoResult.
type DynoResultOrderField struct {
	// Value extracts the ordering value from the given DynoResult.
	Value    func(*DynoResult) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) dynoresult.OrderOption
	toCursor func(*DynoResult) Cursor
}

// DynoResultOrder defines the ordering of DynoResult.
type DynoResultOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *DynoResultOrderField `json:"field"`
}

// DefaultDynoResultOrder is the default ordering of DynoResult.
var DefaultDynoResultOrder = &DynoResultOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DynoResultOrderField{
		Value: func(dr *DynoResult) (ent.Value, error) {
			return dr.ID, nil
		},
		column: dynoresult.FieldID,
		toTerm: dynoresult.ByID,
		toCursor: func(dr *DynoResult) Cursor {
			return Cursor{ID: dr.ID}
		},
	},
}

// ToEdge converts DynoResult into DynoResultEdge.
func (dr *DynoResult) ToEdge(order *DynoResultOrder) *DynoResultEdge {
	if order == nil {
		order = DefaultDynoResultOrder
	}
	return &DynoResultEdge{
		Node:   dr,
		Cursor: order.Field.toCursor(dr),
	}
}

// DynoSessionEdge is the edge representation of DynoSession.
type DynoSessionEdge struct {
	Node   *DynoSession `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// DynoSessionConnection is the connection containing edges to DynoSession.
type DynoSessionConnection struct {
	Edges      []*DynoSessionEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *DynoSessionConnection) build(nodes []*DynoSession, pager *dynosessionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DynoSession
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DynoSession {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DynoSession {
			return nodes[i]
		}
	}
	c.Edges = make([]*DynoSessionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DynoSessionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DynoSessionPaginateOption enables pagination customization.
type DynoSessionPaginateOption func(*dynosessionPager) error

// WithDynoSessionOrder configures pagination ordering.
func WithDynoSessionOrder(order *DynoSessionOrder) DynoSessionPaginateOption {
	if order == nil {
		order = DefaultDynoSessionOrder
	}
	o := *order
	return func(pager *dynosessionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDynoSessionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDynoSessionFilter configures pagination filter.
func WithDynoSessionFilter(filter func(*DynoSessionQuery) (*DynoSessionQuery, error)) DynoSessionPaginateOption {
	return func(pager *dynosessionPager) error {
		if filter == nil {
			return errors.New("DynoSessionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dynosessionPager struct {
	reverse bool
	order   *DynoSessionOrder
	filter  func(*DynoSessionQuery) (*DynoSessionQuery, error)
}

func newDynoSessionPager(opts []DynoSessionPaginateOption, reverse bool) (*dynosessionPager, error) {
	pager := &dynosessionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDynoSessionOrder
	}
	return pager, nil
}

func (p *dynosessionPager) applyFilter(query *DynoSessionQuery) (*DynoSessionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dynosessionPager) toCursor(ds *DynoSession) Cursor {
	return p.order.Field.toCursor(ds)
}

func (p *dynosessionPager) applyCursors(query *DynoSessionQuery, after, before *Cursor) (*DynoSessionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDynoSessionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *dynosessionPager) applyOrder(query *DynoSessionQuery) *DynoSessionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDynoSessionOrder.Field {
		query = query.Order(DefaultDynoSessionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *dynosessionPager) orderExpr(query *DynoSessionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDynoSessionOrder.Field {
			b.Comma().Ident(DefaultDynoSessionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DynoSession.
func (ds *DynoSessionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DynoSessionPaginateOption,
) (*DynoSessionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDynoSessionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ds, err = pager.applyFilter(ds); err != nil {
		return nil, err
	}
	conn := &DynoSessionConnection{Edges: []*DynoSessionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ds.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ds, err = pager.applyCursors(ds, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ds.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ds.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ds = pager.applyOrder(ds)
	nodes, err := ds.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DynoSessionOrderField defines the ordering field of DynoSession.
type DynoSessionOrderField struct {
	// Value extracts the ordering value from the given DynoSession.
	Value    func(*DynoSession) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) dynosession.OrderOption
	toCursor func(*DynoSession) Cursor
}

// DynoSessionOrder defines the ordering of DynoSession.
type DynoSessionOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *DynoSessionOrderField `json:"field"`
}

// DefaultDynoSessionOrder is the default ordering of DynoSession.
var DefaultDynoSessionOrder = &DynoSessionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DynoSessionOrderField{
		Value: func(ds *DynoSession) (ent.Value, error) {
			return ds.ID, nil
		},
		column: dynosession.FieldID,
		toTerm: dynosession.ByID,
		toCursor: func(ds *DynoSession) Cursor {
			return Cursor{ID: ds.ID}
		},
	},
}

// ToEdge converts DynoSession into DynoSessionEdge.
func (ds *DynoSession) ToEdge(order *DynoSessionOrder) *DynoSessionEdge {
	if order == nil {
		order = DefaultDynoSessionOrder
	}
	return &DynoSessionEdge{
		Node:   ds,
		Cursor: order.Field.toCursor(ds),
	}
}

// ExpenseEdge is the edge representation of Expense.
type ExpenseEdge struct {
	Node   *Expense `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ExpenseConnection is the connection containing edges to Expense.
type ExpenseConnection struct {
	Edges      []*ExpenseEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ExpenseConnection) build(nodes []*Expense, pager *expensePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Expense
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Expense {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Expense {
			return nodes[i]
		}
	}
	c.Edges = make([]*ExpenseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ExpenseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ExpensePaginateOption enables pagination customization.
type ExpensePaginateOption func(*expensePager) error

// WithExpenseOrder configures pagination ordering.
func WithExpenseOrder(order *ExpenseOrder) ExpensePaginateOption {
	if order == nil {
		order = DefaultExpenseOrder
	}
	o := *order
	return func(pager *expensePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultExpenseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithExpenseFilter configures pagination filter.
func WithExpenseFilter(filter func(*ExpenseQuery) (*ExpenseQuery, error)) ExpensePaginateOption {
	return func(pager *expensePager) error {
		if filter == nil {
			return errors.New("ExpenseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type expensePager struct {
	reverse bool
	order   *ExpenseOrder
	filter  func(*ExpenseQuery) (*ExpenseQuery, error)
}

func newExpensePager(opts []ExpensePaginateOption, reverse bool) (*expensePager, error) {
	pager := &expensePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultExpenseOrder
	}
	return pager, nil
}

func (p *expensePager) applyFilter(query *ExpenseQuery) (*ExpenseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *expensePager) toCursor(e *Expense) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *expensePager) applyCursors(query *ExpenseQuery, after, before *Cursor) (*ExpenseQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultExpenseOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *expensePager) applyOrder(query *ExpenseQuery) *ExpenseQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultExpenseOrder.Field {
		query = query.Order(DefaultExpenseOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *expensePager) orderExpr(query *ExpenseQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultExpenseOrder.Field {
			b.Comma().Ident(DefaultExpenseOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Expense.
func (e *ExpenseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ExpensePaginateOption,
) (*ExpenseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newExpensePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &ExpenseConnection{Edges: []*ExpenseEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := e.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if e, err = pager.applyCursors(e, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	e = pager.applyOrder(e)
	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ExpenseOrderField defines the ordering field of Expense.
type ExpenseOrderField struct {
	// Value extracts the ordering value from the given Expense.
	Value    func(*Expense) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) expense.OrderOption
	toCursor func(*Expense) Cursor
}

// ExpenseOrder defines the ordering of Expense.
type ExpenseOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ExpenseOrderField `json:"field"`
}

// DefaultExpenseOrder is the default ordering of Expense.
var DefaultExpenseOrder = &ExpenseOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ExpenseOrderField{
		Value: func(e *Expense) (ent.Value, error) {
			return e.ID, nil
		},
		column: expense.FieldID,
		toTerm: expense.ByID,
		toCursor: func(e *Expense) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Expense into ExpenseEdge.
func (e *Expense) ToEdge(order *ExpenseOrder) *ExpenseEdge {
	if order == nil {
		order = DefaultExpenseOrder
	}
	return &ExpenseEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// FuelUpEdge is the edge representation of FuelUp.
type FuelUpEdge struct {
	Node   *FuelUp `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// FuelUpConnection is the connection containing edges to FuelUp.
type FuelUpConnection struct {
	Edges      []*FuelUpEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *FuelUpConnection) build(nodes []*FuelUp, pager *fuelupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *FuelUp
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FuelUp {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FuelUp {
			return nodes[i]
		}
	}
	c.Edges = make([]*FuelUpEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FuelUpEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FuelUpPaginateOption enables pagination customization.
type FuelUpPaginateOption func(*fuelupPager) error

// WithFuelUpOrder configures pagination ordering.
func WithFuelUpOrder(order *FuelUpOrder) FuelUpPaginateOption {
	if order == nil {
		order = DefaultFuelUpOrder
	}
	o := *order
	return func(pager *fuelupPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFuelUpOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFuelUpFilter configures pagination filter.
func WithFuelUpFilter(filter func(*FuelUpQuery) (*FuelUpQuery, error)) FuelUpPaginateOption {
	return func(pager *fuelupPager) error {
		if filter == nil {
			return errors.New("FuelUpQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type fuelupPager struct {
	reverse bool
	order   *FuelUpOrder
	filter  func(*FuelUpQuery) (*FuelUpQuery, error)
}

func newFuelUpPager(opts []FuelUpPaginateOption, reverse bool) (*fuelupPager, error) {
	pager := &fuelupPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFuelUpOrder
	}
	return pager, nil
}

func (p *fuelupPager) applyFilter(query *FuelUpQuery) (*FuelUpQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *fuelupPager) toCursor(fu *FuelUp) Cursor {
	return p.order.Field.toCursor(fu)
}

func (p *fuelupPager) applyCursors(query *FuelUpQuery, after, before *Cursor) (*FuelUpQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFuelUpOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *fuelupPager) applyOrder(query *FuelUpQuery) *FuelUpQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFuelUpOrder.Field {
		query = query.Order(DefaultFuelUpOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *fuelupPager) orderExpr(query *FuelUpQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFuelUpOrder.Field {
			b.Comma().Ident(DefaultFuelUpOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FuelUp.
func (fu *FuelUpQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FuelUpPaginateOption,
) (*FuelUpConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFuelUpPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if fu, err = pager.applyFilter(fu); err != nil {
		return nil, err
	}
	conn := &FuelUpConnection{Edges: []*FuelUpEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := fu.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if fu, err = pager.applyCursors(fu, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		fu.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := fu.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	fu = pager.applyOrder(fu)
	nodes, err := fu.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FuelUpOrderField defines the ordering field of FuelUp.
type FuelUpOrderField struct {
	// Value extracts the ordering value from the given FuelUp.
	Value    func(*FuelUp) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) fuelup.OrderOption
	toCursor func(*FuelUp) Cursor
}

// FuelUpOrder defines the ordering of FuelUp.
type FuelUpOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *FuelUpOrderField `json:"field"`
}

// DefaultFuelUpOrder is the default ordering of FuelUp.
var DefaultFuelUpOrder = &FuelUpOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FuelUpOrderField{
		Value: func(fu *FuelUp) (ent.Value, error) {
			return fu.ID, nil
		},
		column: fuelup.FieldID,
		toTerm: fuelup.ByID,
		toCursor: func(fu *FuelUp) Cursor {
			return Cursor{ID: fu.ID}
		},
	},
}

// ToEdge converts FuelUp into FuelUpEdge.
func (fu *FuelUp) ToEdge(order *FuelUpOrder) *FuelUpEdge {
	if order == nil {
		order = DefaultFuelUpOrder
	}
	return &FuelUpEdge{
		Node:   fu,
		Cursor: order.Field.toCursor(fu),
	}
}

// MediaEdge is the edge representation of Media.
type MediaEdge struct {
	Node   *Media `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// MediaConnection is the connection containing edges to Media.
type MediaConnection struct {
	Edges      []*MediaEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *MediaConnection) build(nodes []*Media, pager *mediaPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Media
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Media {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Media {
			return nodes[i]
		}
	}
	c.Edges = make([]*MediaEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MediaEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MediaPaginateOption enables pagination customization.
type MediaPaginateOption func(*mediaPager) error

// WithMediaOrder configures pagination ordering.
func WithMediaOrder(order *MediaOrder) MediaPaginateOption {
	if order == nil {
		order = DefaultMediaOrder
	}
	o := *order
	return func(pager *mediaPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMediaOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMediaFilter configures pagination filter.
func WithMediaFilter(filter func(*MediaQuery) (*MediaQuery, error)) MediaPaginateOption {
	return func(pager *mediaPager) error {
		if filter == nil {
			return errors.New("MediaQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mediaPager struct {
	reverse bool
	order   *MediaOrder
	filter  func(*MediaQuery) (*MediaQuery, error)
}

func newMediaPager(opts []MediaPaginateOption, reverse bool) (*mediaPager, error) {
	pager := &mediaPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMediaOrder
	}
	return pager, nil
}

func (p *mediaPager) applyFilter(query *MediaQuery) (*MediaQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mediaPager) toCursor(m *Media) Cursor {
	return p.order.Field.toCursor(m)
}

func (p *mediaPager) applyCursors(query *MediaQuery, after, before *Cursor) (*MediaQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultMediaOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *mediaPager) applyOrder(query *MediaQuery) *MediaQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultMediaOrder.Field {
		query = query.Order(DefaultMediaOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *mediaPager) orderExpr(query *MediaQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMediaOrder.Field {
			b.Comma().Ident(DefaultMediaOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Media.
func (m *MediaQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MediaPaginateOption,
) (*MediaConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMediaPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if m, err = pager.applyFilter(m); err != nil {
		return nil, err
	}
	conn := &MediaConnection{Edges: []*MediaEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if m, err = pager.applyCursors(m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	m = pager.applyOrder(m)
	nodes, err := m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// MediaOrderField defines the ordering field of Media.
type MediaOrderField struct {
	// Value extracts the ordering value from the given Media.
	Value    func(*Media) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) media.OrderOption
	toCursor func(*Media) Cursor
}

// MediaOrder defines the ordering of Media.
type MediaOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *MediaOrderField `json:"field"`
}

// DefaultMediaOrder is the default ordering of Media.
var DefaultMediaOrder = &MediaOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MediaOrderField{
		Value: func(m *Media) (ent.Value, error) {
			return m.ID, nil
		},
		column: media.FieldID,
		toTerm: media.ByID,
		toCursor: func(m *Media) Cursor {
			return Cursor{ID: m.ID}
		},
	},
}

// ToEdge converts Media into MediaEdge.
func (m *Media) ToEdge(order *MediaOrder) *MediaEdge {
	if order == nil {
		order = DefaultMediaOrder
	}
	return &MediaEdge{
		Node:   m,
		Cursor: order.Field.toCursor(m),
	}
}

// ModEdge is the edge representation of Mod.
type ModEdge struct {
	Node   *Mod   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ModConnection is the connection containing edges to Mod.
type ModConnection struct {
	Edges      []*ModEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

func (c *ModConnection) build(nodes []*Mod, pager *modPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Mod
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Mod {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Mod {
			return nodes[i]
		}
	}
	c.Edges = make([]*ModEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ModEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ModPaginateOption enables pagination customization.
type ModPaginateOption func(*modPager) error

// WithModOrder configures pagination ordering.
func WithModOrder(order *ModOrder) ModPaginateOption {
	if order == nil {
		order = DefaultModOrder
	}
	o := *order
	return func(pager *modPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultModOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithModFilter configures pagination filter.
func WithModFilter(filter func(*ModQuery) (*ModQuery, error)) ModPaginateOption {
	return func(pager *modPager) error {
		if filter == nil {
			return errors.New("ModQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type modPager struct {
	reverse bool
	order   *ModOrder
	filter  func(*ModQuery) (*ModQuery, error)
}

func newModPager(opts []ModPaginateOption, reverse bool) (*modPager, error) {
	pager := &modPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultModOrder
	}
	return pager, nil
}

func (p *modPager) applyFilter(query *ModQuery) (*ModQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *modPager) toCursor(m *Mod) Cursor {
	return p.order.Field.toCursor(m)
}

func (p *modPager) applyCursors(query *ModQuery, after, before *Cursor) (*ModQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultModOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *modPager) applyOrder(query *ModQuery) *ModQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultModOrder.Field {
		query = query.Order(DefaultModOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *modPager) orderExpr(query *ModQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultModOrder.Field {
			b.Comma().Ident(DefaultModOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Mod.
func (m *ModQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ModPaginateOption,
) (*ModConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newModPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if m, err = pager.applyFilter(m); err != nil {
		return nil, err
	}
	conn := &ModConnection{Edges: []*ModEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if m, err = pager.applyCursors(m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	m = pager.applyOrder(m)
	nodes, err := m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ModOrderField defines the ordering field of Mod.
type ModOrderField struct {
	// Value extracts the ordering value from the given Mod.
	Value    func(*Mod) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) mod.OrderOption
	toCursor func(*Mod) Cursor
}

// ModOrder defines the ordering of Mod.
type ModOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *ModOrderField `json:"field"`
}

// DefaultModOrder is the default ordering of Mod.
var DefaultModOrder = &ModOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ModOrderField{
		Value: func(m *Mod) (ent.Value, error) {
			return m.ID, nil
		},
		column: mod.FieldID,
		toTerm: mod.ByID,
		toCursor: func(m *Mod) Cursor {
			return Cursor{ID: m.ID}
		},
	},
}

// ToEdge converts Mod into ModEdge.
func (m *Mod) ToEdge(order *ModOrder) *ModEdge {
	if order == nil {
		order = DefaultModOrder
	}
	return &ModEdge{
		Node:   m,
		Cursor: order.Field.toCursor(m),
	}
}

// ModProductOptionEdge is the edge representation of ModProductOption.
type ModProductOptionEdge struct {
	Node   *ModProductOption `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ModProductOptionConnection is the connection containing edges to ModProductOption.
type ModProductOptionConnection struct {
	Edges      []*ModProductOptionEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *ModProductOptionConnection) build(nodes []*ModProductOption, pager *modproductoptionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ModProductOption
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ModProductOption {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ModProductOption {
			return nodes[i]
		}
	}
	c.Edges = make([]*ModProductOptionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ModProductOptionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ModProductOptionPaginateOption enables pagination customization.
type ModProductOptionPaginateOption func(*modproductoptionPager) error

// WithModProductOptionOrder configures pagination ordering.
func WithModProductOptionOrder(order *ModProductOptionOrder) ModProductOptionPaginateOption {
	if order == nil {
		order = DefaultModProductOptionOrder
	}
	o := *order
	return func(pager *modproductoptionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultModProductOptionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithModProductOptionFilter configures pagination filter.
func WithModProductOptionFilter(filter func(*ModProductOptionQuery) (*ModProductOptionQuery, error)) ModProductOptionPaginateOption {
	return func(pager *modproductoptionPager) error {
		if filter == nil {
			return errors.New("ModProductOptionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type modproductoptionPager struct {
	reverse bool
	order   *ModProductOptionOrder
	filter  func(*ModProductOptionQuery) (*ModProductOptionQuery, error)
}

func newModProductOptionPager(opts []ModProductOptionPaginateOption, reverse bool) (*modproductoptionPager, error) {
	pager := &modproductoptionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultModProductOptionOrder
	}
	return pager, nil
}

func (p *modproductoptionPager) applyFilter(query *ModProductOptionQuery) (*ModProductOptionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *modproductoptionPager) toCursor(mpo *ModProductOption) Cursor {
	return p.order.Field.toCursor(mpo)
}

func (p *modproductoptionPager) applyCursors(query *ModProductOptionQuery, after, before *Cursor) (*ModProductOptionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultModProductOptionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *modproductoptionPager) applyOrder(query *ModProductOptionQuery) *ModProductOptionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultModProductOptionOrder.Field {
		query = query.Order(DefaultModProductOptionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *modproductoptionPager) orderExpr(query *ModProductOptionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultModProductOptionOrder.Field {
			b.Comma().Ident(DefaultModProductOptionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ModProductOption.
func (mpo *ModProductOptionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ModProductOptionPaginateOption,
) (*ModProductOptionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newModProductOptionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if mpo, err = pager.applyFilter(mpo); err != nil {
		return nil, err
	}
	conn := &ModProductOptionConnection{Edges: []*ModProductOptionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := mpo.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if mpo, err = pager.applyCursors(mpo, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		mpo.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := mpo.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	mpo = pager.applyOrder(mpo)
	nodes, err := mpo.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ModProductOptionOrderField defines the ordering field of ModProductOption.
type ModProductOptionOrderField struct {
	// Value extracts the ordering value from the given ModProductOption.
	Value    func(*ModProductOption) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) modproductoption.OrderOption
	toCursor func(*ModProductOption) Cursor
}

// ModProductOptionOrder defines the ordering of ModProductOption.
type ModProductOptionOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ModProductOptionOrderField `json:"field"`
}

// DefaultModProductOptionOrder is the default ordering of ModProductOption.
var DefaultModProductOptionOrder = &ModProductOptionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ModProductOptionOrderField{
		Value: func(mpo *ModProductOption) (ent.Value, error) {
			return mpo.ID, nil
		},
		column: modproductoption.FieldID,
		toTerm: modproductoption.ByID,
		toCursor: func(mpo *ModProductOption) Cursor {
			return Cursor{ID: mpo.ID}
		},
	},
}

// ToEdge converts ModProductOption into ModProductOptionEdge.
func (mpo *ModProductOption) ToEdge(order *ModProductOptionOrder) *ModProductOptionEdge {
	if order == nil {
		order = DefaultModProductOptionOrder
	}
	return &ModProductOptionEdge{
		Node:   mpo,
		Cursor: order.Field.toCursor(mpo),
	}
}

// ModProductOptionPreviewEdge is the edge representation of ModProductOptionPreview.
type ModProductOptionPreviewEdge struct {
	Node   *ModProductOptionPreview `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// ModProductOptionPreviewConnection is the connection containing edges to ModProductOptionPreview.
type ModProductOptionPreviewConnection struct {
	Edges      []*ModProductOptionPreviewEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

func (c *ModProductOptionPreviewConnection) build(nodes []*ModProductOptionPreview, pager *modproductoptionpreviewPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ModProductOptionPreview
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ModProductOptionPreview {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ModProductOptionPreview {
			return nodes[i]
		}
	}
	c.Edges = make([]*ModProductOptionPreviewEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ModProductOptionPreviewEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ModProductOptionPreviewPaginateOption enables pagination customization.
type ModProductOptionPreviewPaginateOption func(*modproductoptionpreviewPager) error

// WithModProductOptionPreviewOrder configures pagination ordering.
func WithModProductOptionPreviewOrder(order *ModProductOptionPreviewOrder) ModProductOptionPreviewPaginateOption {
	if order == nil {
		order = DefaultModProductOptionPreviewOrder
	}
	o := *order
	return func(pager *modproductoptionpreviewPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultModProductOptionPreviewOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithModProductOptionPreviewFilter configures pagination filter.
func WithModProductOptionPreviewFilter(filter func(*ModProductOptionPreviewQuery) (*ModProductOptionPreviewQuery, error)) ModProductOptionPreviewPaginateOption {
	return func(pager *modproductoptionpreviewPager) error {
		if filter == nil {
			return errors.New("ModProductOptionPreviewQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type modproductoptionpreviewPager struct {
	reverse bool
	order   *ModProductOptionPreviewOrder
	filter  func(*ModProductOptionPreviewQuery) (*ModProductOptionPreviewQuery, error)
}

func newModProductOptionPreviewPager(opts []ModProductOptionPreviewPaginateOption, reverse bool) (*modproductoptionpreviewPager, error) {
	pager := &modproductoptionpreviewPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultModProductOptionPreviewOrder
	}
	return pager, nil
}

func (p *modproductoptionpreviewPager) applyFilter(query *ModProductOptionPreviewQuery) (*ModProductOptionPreviewQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *modproductoptionpreviewPager) toCursor(mpop *ModProductOptionPreview) Cursor {
	return p.order.Field.toCursor(mpop)
}

func (p *modproductoptionpreviewPager) applyCursors(query *ModProductOptionPreviewQuery, after, before *Cursor) (*ModProductOptionPreviewQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultModProductOptionPreviewOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *modproductoptionpreviewPager) applyOrder(query *ModProductOptionPreviewQuery) *ModProductOptionPreviewQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultModProductOptionPreviewOrder.Field {
		query = query.Order(DefaultModProductOptionPreviewOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *modproductoptionpreviewPager) orderExpr(query *ModProductOptionPreviewQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultModProductOptionPreviewOrder.Field {
			b.Comma().Ident(DefaultModProductOptionPreviewOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ModProductOptionPreview.
func (mpop *ModProductOptionPreviewQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ModProductOptionPreviewPaginateOption,
) (*ModProductOptionPreviewConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newModProductOptionPreviewPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if mpop, err = pager.applyFilter(mpop); err != nil {
		return nil, err
	}
	conn := &ModProductOptionPreviewConnection{Edges: []*ModProductOptionPreviewEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := mpop.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if mpop, err = pager.applyCursors(mpop, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		mpop.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := mpop.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	mpop = pager.applyOrder(mpop)
	nodes, err := mpop.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ModProductOptionPreviewOrderField defines the ordering field of ModProductOptionPreview.
type ModProductOptionPreviewOrderField struct {
	// Value extracts the ordering value from the given ModProductOptionPreview.
	Value    func(*ModProductOptionPreview) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) modproductoptionpreview.OrderOption
	toCursor func(*ModProductOptionPreview) Cursor
}

// ModProductOptionPreviewOrder defines the ordering of ModProductOptionPreview.
type ModProductOptionPreviewOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *ModProductOptionPreviewOrderField `json:"field"`
}

// DefaultModProductOptionPreviewOrder is the default ordering of ModProductOptionPreview.
var DefaultModProductOptionPreviewOrder = &ModProductOptionPreviewOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ModProductOptionPreviewOrderField{
		Value: func(mpop *ModProductOptionPreview) (ent.Value, error) {
			return mpop.ID, nil
		},
		column: modproductoptionpreview.FieldID,
		toTerm: modproductoptionpreview.ByID,
		toCursor: func(mpop *ModProductOptionPreview) Cursor {
			return Cursor{ID: mpop.ID}
		},
	},
}

// ToEdge converts ModProductOptionPreview into ModProductOptionPreviewEdge.
func (mpop *ModProductOptionPreview) ToEdge(order *ModProductOptionPreviewOrder) *ModProductOptionPreviewEdge {
	if order == nil {
		order = DefaultModProductOptionPreviewOrder
	}
	return &ModProductOptionPreviewEdge{
		Node:   mpop,
		Cursor: order.Field.toCursor(mpop),
	}
}

// OdometerReadingEdge is the edge representation of OdometerReading.
type OdometerReadingEdge struct {
	Node   *OdometerReading `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// OdometerReadingConnection is the connection containing edges to OdometerReading.
type OdometerReadingConnection struct {
	Edges      []*OdometerReadingEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *OdometerReadingConnection) build(nodes []*OdometerReading, pager *odometerreadingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OdometerReading
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OdometerReading {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OdometerReading {
			return nodes[i]
		}
	}
	c.Edges = make([]*OdometerReadingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OdometerReadingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OdometerReadingPaginateOption enables pagination customization.
type OdometerReadingPaginateOption func(*odometerreadingPager) error

// WithOdometerReadingOrder configures pagination ordering.
func WithOdometerReadingOrder(order *OdometerReadingOrder) OdometerReadingPaginateOption {
	if order == nil {
		order = DefaultOdometerReadingOrder
	}
	o := *order
	return func(pager *odometerreadingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOdometerReadingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOdometerReadingFilter configures pagination filter.
func WithOdometerReadingFilter(filter func(*OdometerReadingQuery) (*OdometerReadingQuery, error)) OdometerReadingPaginateOption {
	return func(pager *odometerreadingPager) error {
		if filter == nil {
			return errors.New("OdometerReadingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type odometerreadingPager struct {
	reverse bool
	order   *OdometerReadingOrder
	filter  func(*OdometerReadingQuery) (*OdometerReadingQuery, error)
}

func newOdometerReadingPager(opts []OdometerReadingPaginateOption, reverse bool) (*odometerreadingPager, error) {
	pager := &odometerreadingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOdometerReadingOrder
	}
	return pager, nil
}

func (p *odometerreadingPager) applyFilter(query *OdometerReadingQuery) (*OdometerReadingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *odometerreadingPager) toCursor(or *OdometerReading) Cursor {
	return p.order.Field.toCursor(or)
}

func (p *odometerreadingPager) applyCursors(query *OdometerReadingQuery, after, before *Cursor) (*OdometerReadingQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOdometerReadingOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *odometerreadingPager) applyOrder(query *OdometerReadingQuery) *OdometerReadingQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOdometerReadingOrder.Field {
		query = query.Order(DefaultOdometerReadingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *odometerreadingPager) orderExpr(query *OdometerReadingQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOdometerReadingOrder.Field {
			b.Comma().Ident(DefaultOdometerReadingOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OdometerReading.
func (or *OdometerReadingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OdometerReadingPaginateOption,
) (*OdometerReadingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOdometerReadingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if or, err = pager.applyFilter(or); err != nil {
		return nil, err
	}
	conn := &OdometerReadingConnection{Edges: []*OdometerReadingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := or.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if or, err = pager.applyCursors(or, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		or.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := or.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	or = pager.applyOrder(or)
	nodes, err := or.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OdometerReadingOrderField defines the ordering field of OdometerReading.
type OdometerReadingOrderField struct {
	// Value extracts the ordering value from the given OdometerReading.
	Value    func(*OdometerReading) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) odometerreading.OrderOption
	toCursor func(*OdometerReading) Cursor
}

// OdometerReadingOrder defines the ordering of OdometerReading.
type OdometerReadingOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *OdometerReadingOrderField `json:"field"`
}

// DefaultOdometerReadingOrder is the default ordering of OdometerReading.
var DefaultOdometerReadingOrder = &OdometerReadingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OdometerReadingOrderField{
		Value: func(or *OdometerReading) (ent.Value, error) {
			return or.ID, nil
		},
		column: odometerreading.FieldID,
		toTerm: odometerreading.ByID,
		toCursor: func(or *OdometerReading) Cursor {
			return Cursor{ID: or.ID}
		},
	},
}

// ToEdge converts OdometerReading into OdometerReadingEdge.
func (or *OdometerReading) ToEdge(order *OdometerReadingOrder) *OdometerReadingEdge {
	if order == nil {
		order = DefaultOdometerReadingOrder
	}
	return &OdometerReadingEdge{
		Node:   or,
		Cursor: order.Field.toCursor(or),
	}
}

// ProfileEdge is the edge representation of Profile.
type ProfileEdge struct {
	Node   *Profile `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProfileConnection is the connection containing edges to Profile.
type ProfileConnection struct {
	Edges      []*ProfileEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProfileConnection) build(nodes []*Profile, pager *profilePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Profile
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Profile {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Profile {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProfileEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProfileEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProfilePaginateOption enables pagination customization.
type ProfilePaginateOption func(*profilePager) error

// WithProfileOrder configures pagination ordering.
func WithProfileOrder(order *ProfileOrder) ProfilePaginateOption {
	if order == nil {
		order = DefaultProfileOrder
	}
	o := *order
	return func(pager *profilePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProfileOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProfileFilter configures pagination filter.
func WithProfileFilter(filter func(*ProfileQuery) (*ProfileQuery, error)) ProfilePaginateOption {
	return func(pager *profilePager) error {
		if filter == nil {
			return errors.New("ProfileQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type profilePager struct {
	reverse bool
	order   *ProfileOrder
	filter  func(*ProfileQuery) (*ProfileQuery, error)
}

func newProfilePager(opts []ProfilePaginateOption, reverse bool) (*profilePager, error) {
	pager := &profilePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProfileOrder
	}
	return pager, nil
}

func (p *profilePager) applyFilter(query *ProfileQuery) (*ProfileQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *profilePager) toCursor(pr *Profile) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *profilePager) applyCursors(query *ProfileQuery, after, before *Cursor) (*ProfileQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProfileOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *profilePager) applyOrder(query *ProfileQuery) *ProfileQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProfileOrder.Field {
		query = query.Order(DefaultProfileOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *profilePager) orderExpr(query *ProfileQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProfileOrder.Field {
			b.Comma().Ident(DefaultProfileOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Profile.
func (pr *ProfileQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProfilePaginateOption,
) (*ProfileConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProfilePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProfileConnection{Edges: []*ProfileEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProfileOrderField defines the ordering field of Profile.
type ProfileOrderField struct {
	// Value extracts the ordering value from the given Profile.
	Value    func(*Profile) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) profile.OrderOption
	toCursor func(*Profile) Cursor
}

// ProfileOrder defines the ordering of Profile.
type ProfileOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProfileOrderField `json:"field"`
}

// DefaultProfileOrder is the default ordering of Profile.
var DefaultProfileOrder = &ProfileOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProfileOrderField{
		Value: func(pr *Profile) (ent.Value, error) {
			return pr.ID, nil
		},
		column: profile.FieldID,
		toTerm: profile.ByID,
		toCursor: func(pr *Profile) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Profile into ProfileEdge.
func (pr *Profile) ToEdge(order *ProfileOrder) *ProfileEdge {
	if order == nil {
		order = DefaultProfileOrder
	}
	return &ProfileEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ServiceItemEdge is the edge representation of ServiceItem.
type ServiceItemEdge struct {
	Node   *ServiceItem `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// ServiceItemConnection is the connection containing edges to ServiceItem.
type ServiceItemConnection struct {
	Edges      []*ServiceItemEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *ServiceItemConnection) build(nodes []*ServiceItem, pager *serviceitemPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ServiceItem
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ServiceItem {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ServiceItem {
			return nodes[i]
		}
	}
	c.Edges = make([]*ServiceItemEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ServiceItemEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ServiceItemPaginateOption enables pagination customization.
type ServiceItemPaginateOption func(*serviceitemPager) error

// WithServiceItemOrder configures pagination ordering.
func WithServiceItemOrder(order *ServiceItemOrder) ServiceItemPaginateOption {
	if order == nil {
		order = DefaultServiceItemOrder
	}
	o := *order
	return func(pager *serviceitemPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultServiceItemOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithServiceItemFilter configures pagination filter.
func WithServiceItemFilter(filter func(*ServiceItemQuery) (*ServiceItemQuery, error)) ServiceItemPaginateOption {
	return func(pager *serviceitemPager) error {
		if filter == nil {
			return errors.New("ServiceItemQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type serviceitemPager struct {
	reverse bool
	order   *ServiceItemOrder
	filter  func(*ServiceItemQuery) (*ServiceItemQuery, error)
}

func newServiceItemPager(opts []ServiceItemPaginateOption, reverse bool) (*serviceitemPager, error) {
	pager := &serviceitemPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultServiceItemOrder
	}
	return pager, nil
}

func (p *serviceitemPager) applyFilter(query *ServiceItemQuery) (*ServiceItemQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *serviceitemPager) toCursor(si *ServiceItem) Cursor {
	return p.order.Field.toCursor(si)
}

func (p *serviceitemPager) applyCursors(query *ServiceItemQuery, after, before *Cursor) (*ServiceItemQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultServiceItemOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *serviceitemPager) applyOrder(query *ServiceItemQuery) *ServiceItemQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultServiceItemOrder.Field {
		query = query.Order(DefaultServiceItemOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *serviceitemPager) orderExpr(query *ServiceItemQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultServiceItemOrder.Field {
			b.Comma().Ident(DefaultServiceItemOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ServiceItem.
func (si *ServiceItemQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ServiceItemPaginateOption,
) (*ServiceItemConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newServiceItemPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if si, err = pager.applyFilter(si); err != nil {
		return nil, err
	}
	conn := &ServiceItemConnection{Edges: []*ServiceItemEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := si.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if si, err = pager.applyCursors(si, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		si.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := si.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	si = pager.applyOrder(si)
	nodes, err := si.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ServiceItemOrderField defines the ordering field of ServiceItem.
type ServiceItemOrderField struct {
	// Value extracts the ordering value from the given ServiceItem.
	Value    func(*ServiceItem) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) serviceitem.OrderOption
	toCursor func(*ServiceItem) Cursor
}

// ServiceItemOrder defines the ordering of ServiceItem.
type ServiceItemOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *ServiceItemOrderField `json:"field"`
}

// DefaultServiceItemOrder is the default ordering of ServiceItem.
var DefaultServiceItemOrder = &ServiceItemOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ServiceItemOrderField{
		Value: func(si *ServiceItem) (ent.Value, error) {
			return si.ID, nil
		},
		column: serviceitem.FieldID,
		toTerm: serviceitem.ByID,
		toCursor: func(si *ServiceItem) Cursor {
			return Cursor{ID: si.ID}
		},
	},
}

// ToEdge converts ServiceItem into ServiceItemEdge.
func (si *ServiceItem) ToEdge(order *ServiceItemOrder) *ServiceItemEdge {
	if order == nil {
		order = DefaultServiceItemOrder
	}
	return &ServiceItemEdge{
		Node:   si,
		Cursor: order.Field.toCursor(si),
	}
}

// ServiceLogEdge is the edge representation of ServiceLog.
type ServiceLogEdge struct {
	Node   *ServiceLog `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ServiceLogConnection is the connection containing edges to ServiceLog.
type ServiceLogConnection struct {
	Edges      []*ServiceLogEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *ServiceLogConnection) build(nodes []*ServiceLog, pager *servicelogPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ServiceLog
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ServiceLog {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ServiceLog {
			return nodes[i]
		}
	}
	c.Edges = make([]*ServiceLogEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ServiceLogEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ServiceLogPaginateOption enables pagination customization.
type ServiceLogPaginateOption func(*servicelogPager) error

// WithServiceLogOrder configures pagination ordering.
func WithServiceLogOrder(order *ServiceLogOrder) ServiceLogPaginateOption {
	if order == nil {
		order = DefaultServiceLogOrder
	}
	o := *order
	return func(pager *servicelogPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultServiceLogOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithServiceLogFilter configures pagination filter.
func WithServiceLogFilter(filter func(*ServiceLogQuery) (*ServiceLogQuery, error)) ServiceLogPaginateOption {
	return func(pager *servicelogPager) error {
		if filter == nil {
			return errors.New("ServiceLogQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type servicelogPager struct {
	reverse bool
	order   *ServiceLogOrder
	filter  func(*ServiceLogQuery) (*ServiceLogQuery, error)
}

func newServiceLogPager(opts []ServiceLogPaginateOption, reverse bool) (*servicelogPager, error) {
	pager := &servicelogPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultServiceLogOrder
	}
	return pager, nil
}

func (p *servicelogPager) applyFilter(query *ServiceLogQuery) (*ServiceLogQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *servicelogPager) toCursor(sl *ServiceLog) Cursor {
	return p.order.Field.toCursor(sl)
}

func (p *servicelogPager) applyCursors(query *ServiceLogQuery, after, before *Cursor) (*ServiceLogQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultServiceLogOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *servicelogPager) applyOrder(query *ServiceLogQuery) *ServiceLogQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultServiceLogOrder.Field {
		query = query.Order(DefaultServiceLogOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *servicelogPager) orderExpr(query *ServiceLogQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultServiceLogOrder.Field {
			b.Comma().Ident(DefaultServiceLogOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ServiceLog.
func (sl *ServiceLogQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ServiceLogPaginateOption,
) (*ServiceLogConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newServiceLogPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sl, err = pager.applyFilter(sl); err != nil {
		return nil, err
	}
	conn := &ServiceLogConnection{Edges: []*ServiceLogEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sl.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sl, err = pager.applyCursors(sl, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sl.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sl.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sl = pager.applyOrder(sl)
	nodes, err := sl.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ServiceLogOrderField defines the ordering field of ServiceLog.
type ServiceLogOrderField struct {
	// Value extracts the ordering value from the given ServiceLog.
	Value    func(*ServiceLog) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) servicelog.OrderOption
	toCursor func(*ServiceLog) Cursor
}

// ServiceLogOrder defines the ordering of ServiceLog.
type ServiceLogOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ServiceLogOrderField `json:"field"`
}

// DefaultServiceLogOrder is the default ordering of ServiceLog.
var DefaultServiceLogOrder = &ServiceLogOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ServiceLogOrderField{
		Value: func(sl *ServiceLog) (ent.Value, error) {
			return sl.ID, nil
		},
		column: servicelog.FieldID,
		toTerm: servicelog.ByID,
		toCursor: func(sl *ServiceLog) Cursor {
			return Cursor{ID: sl.ID}
		},
	},
}

// ToEdge converts ServiceLog into ServiceLogEdge.
func (sl *ServiceLog) ToEdge(order *ServiceLogOrder) *ServiceLogEdge {
	if order == nil {
		order = DefaultServiceLogOrder
	}
	return &ServiceLogEdge{
		Node:   sl,
		Cursor: order.Field.toCursor(sl),
	}
}

// ServiceScheduleEdge is the edge representation of ServiceSchedule.
type ServiceScheduleEdge struct {
	Node   *ServiceSchedule `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// ServiceScheduleConnection is the connection containing edges to ServiceSchedule.
type ServiceScheduleConnection struct {
	Edges      []*ServiceScheduleEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *ServiceScheduleConnection) build(nodes []*ServiceSchedule, pager *serviceschedulePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ServiceSchedule
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ServiceSchedule {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ServiceSchedule {
			return nodes[i]
		}
	}
	c.Edges = make([]*ServiceScheduleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ServiceScheduleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ServiceSchedulePaginateOption enables pagination customization.
type ServiceSchedulePaginateOption func(*serviceschedulePager) error

// WithServiceScheduleOrder configures pagination ordering.
func WithServiceScheduleOrder(order *ServiceScheduleOrder) ServiceSchedulePaginateOption {
	if order == nil {
		order = DefaultServiceScheduleOrder
	}
	o := *order
	return func(pager *serviceschedulePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultServiceScheduleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithServiceScheduleFilter configures pagination filter.
func WithServiceScheduleFilter(filter func(*ServiceScheduleQuery) (*ServiceScheduleQuery, error)) ServiceSchedulePaginateOption {
	return func(pager *serviceschedulePager) error {
		if filter == nil {
			return errors.New("ServiceScheduleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type serviceschedulePager struct {
	reverse bool
	order   *ServiceScheduleOrder
	filter  func(*ServiceScheduleQuery) (*ServiceScheduleQuery, error)
}

func newServiceSchedulePager(opts []ServiceSchedulePaginateOption, reverse bool) (*serviceschedulePager, error) {
	pager := &serviceschedulePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultServiceScheduleOrder
	}
	return pager, nil
}

func (p *serviceschedulePager) applyFilter(query *ServiceScheduleQuery) (*ServiceScheduleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *serviceschedulePager) toCursor(ss *ServiceSchedule) Cursor {
	return p.order.Field.toCursor(ss)
}

func (p *serviceschedulePager) applyCursors(query *ServiceScheduleQuery, after, before *Cursor) (*ServiceScheduleQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultServiceScheduleOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *serviceschedulePager) applyOrder(query *ServiceScheduleQuery) *ServiceScheduleQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultServiceScheduleOrder.Field {
		query = query.Order(DefaultServiceScheduleOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *serviceschedulePager) orderExpr(query *ServiceScheduleQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultServiceScheduleOrder.Field {
			b.Comma().Ident(DefaultServiceScheduleOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ServiceSchedule.
func (ss *ServiceScheduleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ServiceSchedulePaginateOption,
) (*ServiceScheduleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newServiceSchedulePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ss, err = pager.applyFilter(ss); err != nil {
		return nil, err
	}
	conn := &ServiceScheduleConnection{Edges: []*ServiceScheduleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ss.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ss, err = pager.applyCursors(ss, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ss.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ss.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ss = pager.applyOrder(ss)
	nodes, err := ss.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ServiceScheduleOrderField defines the ordering field of ServiceSchedule.
type ServiceScheduleOrderField struct {
	// Value extracts the ordering value from the given ServiceSchedule.
	Value    func(*ServiceSchedule) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) serviceschedule.OrderOption
	toCursor func(*ServiceSchedule) Cursor
}

// ServiceScheduleOrder defines the ordering of ServiceSchedule.
type ServiceScheduleOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *ServiceScheduleOrderField `json:"field"`
}

// DefaultServiceScheduleOrder is the default ordering of ServiceSchedule.
var DefaultServiceScheduleOrder = &ServiceScheduleOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ServiceScheduleOrderField{
		Value: func(ss *ServiceSchedule) (ent.Value, error) {
			return ss.ID, nil
		},
		column: serviceschedule.FieldID,
		toTerm: serviceschedule.ByID,
		toCursor: func(ss *ServiceSchedule) Cursor {
			return Cursor{ID: ss.ID}
		},
	},
}

// ToEdge converts ServiceSchedule into ServiceScheduleEdge.
func (ss *ServiceSchedule) ToEdge(order *ServiceScheduleOrder) *ServiceScheduleEdge {
	if order == nil {
		order = DefaultServiceScheduleOrder
	}
	return &ServiceScheduleEdge{
		Node:   ss,
		Cursor: order.Field.toCursor(ss),
	}
}

// SubscriptionPlan is the type alias for Subscription.
type SubscriptionPlan = Subscription

// SubscriptionPlanEdge is the edge representation of SubscriptionPlan.
type SubscriptionPlanEdge struct {
	Node   *SubscriptionPlan `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// SubscriptionPlanConnection is the connection containing edges to SubscriptionPlan.
type SubscriptionPlanConnection struct {
	Edges      []*SubscriptionPlanEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *SubscriptionPlanConnection) build(nodes []*SubscriptionPlan, pager *subscriptionplanPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *SubscriptionPlan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SubscriptionPlan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SubscriptionPlan {
			return nodes[i]
		}
	}
	c.Edges = make([]*SubscriptionPlanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SubscriptionPlanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SubscriptionPlanPaginateOption enables pagination customization.
type SubscriptionPlanPaginateOption func(*subscriptionplanPager) error

// WithSubscriptionPlanOrder configures pagination ordering.
func WithSubscriptionPlanOrder(order *SubscriptionPlanOrder) SubscriptionPlanPaginateOption {
	if order == nil {
		order = DefaultSubscriptionPlanOrder
	}
	o := *order
	return func(pager *subscriptionplanPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSubscriptionPlanOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSubscriptionPlanFilter configures pagination filter.
func WithSubscriptionPlanFilter(filter func(*SubscriptionQuery) (*SubscriptionQuery, error)) SubscriptionPlanPaginateOption {
	return func(pager *subscriptionplanPager) error {
		if filter == nil {
			return errors.New("SubscriptionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type subscriptionplanPager struct {
	reverse bool
	order   *SubscriptionPlanOrder
	filter  func(*SubscriptionQuery) (*SubscriptionQuery, error)
}

func newSubscriptionPlanPager(opts []SubscriptionPlanPaginateOption, reverse bool) (*subscriptionplanPager, error) {
	pager := &subscriptionplanPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSubscriptionPlanOrder
	}
	return pager, nil
}

func (p *subscriptionplanPager) applyFilter(query *SubscriptionQuery) (*SubscriptionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *subscriptionplanPager) toCursor(s *SubscriptionPlan) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *subscriptionplanPager) applyCursors(query *SubscriptionQuery, after, before *Cursor) (*SubscriptionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSubscriptionPlanOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *subscriptionplanPager) applyOrder(query *SubscriptionQuery) *SubscriptionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSubscriptionPlanOrder.Field {
		query = query.Order(DefaultSubscriptionPlanOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *subscriptionplanPager) orderExpr(query *SubscriptionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSubscriptionPlanOrder.Field {
			b.Comma().Ident(DefaultSubscriptionPlanOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SubscriptionPlan.
func (s *SubscriptionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SubscriptionPlanPaginateOption,
) (*SubscriptionPlanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSubscriptionPlanPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SubscriptionPlanConnection{Edges: []*SubscriptionPlanEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := s.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// SubscriptionPlanOrderField defines the ordering field of Subscription.
type SubscriptionPlanOrderField struct {
	// Value extracts the ordering value from the given Subscription.
	Value    func(*SubscriptionPlan) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) subscription.OrderOption
	toCursor func(*SubscriptionPlan) Cursor
}

// SubscriptionPlanOrder defines the ordering of Subscription.
type SubscriptionPlanOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *SubscriptionPlanOrderField `json:"field"`
}

// DefaultSubscriptionPlanOrder is the default ordering of Subscription.
var DefaultSubscriptionPlanOrder = &SubscriptionPlanOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SubscriptionPlanOrderField{
		Value: func(s *SubscriptionPlan) (ent.Value, error) {
			return s.ID, nil
		},
		column: subscription.FieldID,
		toTerm: subscription.ByID,
		toCursor: func(s *SubscriptionPlan) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts SubscriptionPlan into SubscriptionPlanEdge.
func (s *SubscriptionPlan) ToEdge(order *SubscriptionPlanOrder) *SubscriptionPlanEdge {
	if order == nil {
		order = DefaultSubscriptionPlanOrder
	}
	return &SubscriptionPlanEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// TaskEdge is the edge representation of Task.
type TaskEdge struct {
	Node   *Task  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TaskConnection is the connection containing edges to Task.
type TaskConnection struct {
	Edges      []*TaskEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *TaskConnection) build(nodes []*Task, pager *taskPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Task
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Task {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Task {
			return nodes[i]
		}
	}
	c.Edges = make([]*TaskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TaskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TaskPaginateOption enables pagination customization.
type TaskPaginateOption func(*taskPager) error

// WithTaskOrder configures pagination ordering.
func WithTaskOrder(order []*TaskOrder) TaskPaginateOption {
	return func(pager *taskPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTaskFilter configures pagination filter.
func WithTaskFilter(filter func(*TaskQuery) (*TaskQuery, error)) TaskPaginateOption {
	return func(pager *taskPager) error {
		if filter == nil {
			return errors.New("TaskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type taskPager struct {
	reverse bool
	order   []*TaskOrder
	filter  func(*TaskQuery) (*TaskQuery, error)
}

func newTaskPager(opts []TaskPaginateOption, reverse bool) (*taskPager, error) {
	pager := &taskPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *taskPager) applyFilter(query *TaskQuery) (*TaskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *taskPager) toCursor(t *Task) Cursor {
	cs_ := make([]any, 0, len(p.order))
	for _, o_ := range p.order {
		cs_ = append(cs_, o_.Field.toCursor(t).Value)
	}
	return Cursor{ID: t.ID, Value: cs_}
}

func (p *taskPager) applyCursors(query *TaskQuery, after, before *Cursor) (*TaskQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTaskOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *taskPager) applyOrder(query *TaskQuery) *TaskQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTaskOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTaskOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *taskPager) orderExpr(query *TaskQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTaskOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Task.
func (t *TaskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TaskPaginateOption,
) (*TaskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTaskPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TaskConnection{Edges: []*TaskEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := t.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TaskOrderFieldID orders Task by id.
	TaskOrderFieldID = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.ID, nil
		},
		column: task.FieldID,
		toTerm: task.ByID,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.ID,
			}
		},
	}
	// TaskOrderFieldStatus orders Task by status.
	TaskOrderFieldStatus = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.Status, nil
		},
		column: task.FieldStatus,
		toTerm: task.ByStatus,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Status,
			}
		},
	}
	// TaskOrderFieldTitle orders Task by title.
	TaskOrderFieldTitle = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.Title, nil
		},
		column: task.FieldTitle,
		toTerm: task.ByTitle,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Title,
			}
		},
	}
	// TaskOrderFieldDescription orders Task by description.
	TaskOrderFieldDescription = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.Description, nil
		},
		column: task.FieldDescription,
		toTerm: task.ByDescription,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Description,
			}
		},
	}
	// TaskOrderFieldRank orders Task by rank.
	TaskOrderFieldRank = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.Rank, nil
		},
		column: task.FieldRank,
		toTerm: task.ByRank,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Rank,
			}
		},
	}
	// TaskOrderFieldEstimate orders Task by estimate.
	TaskOrderFieldEstimate = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.Estimate, nil
		},
		column: task.FieldEstimate,
		toTerm: task.ByEstimate,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Estimate,
			}
		},
	}
	// TaskOrderFieldPriority orders Task by priority.
	TaskOrderFieldPriority = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.Priority, nil
		},
		column: task.FieldPriority,
		toTerm: task.ByPriority,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Priority,
			}
		},
	}
	// TaskOrderFieldEffort orders Task by effort.
	TaskOrderFieldEffort = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.Effort, nil
		},
		column: task.FieldEffort,
		toTerm: task.ByEffort,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Effort,
			}
		},
	}
	// TaskOrderFieldDifficulty orders Task by difficulty.
	TaskOrderFieldDifficulty = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.Difficulty, nil
		},
		column: task.FieldDifficulty,
		toTerm: task.ByDifficulty,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Difficulty,
			}
		},
	}
	// TaskOrderFieldCategory orders Task by category.
	TaskOrderFieldCategory = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.Category, nil
		},
		column: task.FieldCategory,
		toTerm: task.ByCategory,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Category,
			}
		},
	}
	// TaskOrderFieldBudget orders Task by budget.
	TaskOrderFieldBudget = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.Budget, nil
		},
		column: task.FieldBudget,
		toTerm: task.ByBudget,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Budget,
			}
		},
	}
	// TaskOrderFieldPartsNeeded orders Task by parts_needed.
	TaskOrderFieldPartsNeeded = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.PartsNeeded, nil
		},
		column: task.FieldPartsNeeded,
		toTerm: task.ByPartsNeeded,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.PartsNeeded,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TaskOrderField) String() string {
	var str string
	switch f.column {
	case TaskOrderFieldID.column:
		str = "ID"
	case TaskOrderFieldStatus.column:
		str = "STATUS"
	case TaskOrderFieldTitle.column:
		str = "TITLE"
	case TaskOrderFieldDescription.column:
		str = "DESCRIPTION"
	case TaskOrderFieldRank.column:
		str = "RANK"
	case TaskOrderFieldEstimate.column:
		str = "ESTIMATE"
	case TaskOrderFieldPriority.column:
		str = "PRIORITY"
	case TaskOrderFieldEffort.column:
		str = "EFFORT"
	case TaskOrderFieldDifficulty.column:
		str = "DIFFICULTY"
	case TaskOrderFieldCategory.column:
		str = "CATEGORY"
	case TaskOrderFieldBudget.column:
		str = "BUDGET"
	case TaskOrderFieldPartsNeeded.column:
		str = "PARTS_NEEDED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TaskOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TaskOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TaskOrderField %T must be a string", v)
	}
	switch str {
	case "ID":
		*f = *TaskOrderFieldID
	case "STATUS":
		*f = *TaskOrderFieldStatus
	case "TITLE":
		*f = *TaskOrderFieldTitle
	case "DESCRIPTION":
		*f = *TaskOrderFieldDescription
	case "RANK":
		*f = *TaskOrderFieldRank
	case "ESTIMATE":
		*f = *TaskOrderFieldEstimate
	case "PRIORITY":
		*f = *TaskOrderFieldPriority
	case "EFFORT":
		*f = *TaskOrderFieldEffort
	case "DIFFICULTY":
		*f = *TaskOrderFieldDifficulty
	case "CATEGORY":
		*f = *TaskOrderFieldCategory
	case "BUDGET":
		*f = *TaskOrderFieldBudget
	case "PARTS_NEEDED":
		*f = *TaskOrderFieldPartsNeeded
	default:
		return fmt.Errorf("%s is not a valid TaskOrderField", str)
	}
	return nil
}

// TaskOrderField defines the ordering field of Task.
type TaskOrderField struct {
	// Value extracts the ordering value from the given Task.
	Value    func(*Task) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) task.OrderOption
	toCursor func(*Task) Cursor
}

// TaskOrder defines the ordering of Task.
type TaskOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *TaskOrderField `json:"field"`
}

// DefaultTaskOrder is the default ordering of Task.
var DefaultTaskOrder = &TaskOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.ID, nil
		},
		column: task.FieldID,
		toTerm: task.ByID,
		toCursor: func(t *Task) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Task into TaskEdge.
func (t *Task) ToEdge(order *TaskOrder) *TaskEdge {
	if order == nil {
		order = DefaultTaskOrder
	}
	return &TaskEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := u.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}

// UserSettingsEdge is the edge representation of UserSettings.
type UserSettingsEdge struct {
	Node   *UserSettings `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// UserSettingsConnection is the connection containing edges to UserSettings.
type UserSettingsConnection struct {
	Edges      []*UserSettingsEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *UserSettingsConnection) build(nodes []*UserSettings, pager *usersettingsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserSettings
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserSettings {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserSettings {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserSettingsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserSettingsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserSettingsPaginateOption enables pagination customization.
type UserSettingsPaginateOption func(*usersettingsPager) error

// WithUserSettingsOrder configures pagination ordering.
func WithUserSettingsOrder(order *UserSettingsOrder) UserSettingsPaginateOption {
	if order == nil {
		order = DefaultUserSettingsOrder
	}
	o := *order
	return func(pager *usersettingsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserSettingsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserSettingsFilter configures pagination filter.
func WithUserSettingsFilter(filter func(*UserSettingsQuery) (*UserSettingsQuery, error)) UserSettingsPaginateOption {
	return func(pager *usersettingsPager) error {
		if filter == nil {
			return errors.New("UserSettingsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usersettingsPager struct {
	reverse bool
	order   *UserSettingsOrder
	filter  func(*UserSettingsQuery) (*UserSettingsQuery, error)
}

func newUserSettingsPager(opts []UserSettingsPaginateOption, reverse bool) (*usersettingsPager, error) {
	pager := &usersettingsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserSettingsOrder
	}
	return pager, nil
}

func (p *usersettingsPager) applyFilter(query *UserSettingsQuery) (*UserSettingsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usersettingsPager) toCursor(us *UserSettings) Cursor {
	return p.order.Field.toCursor(us)
}

func (p *usersettingsPager) applyCursors(query *UserSettingsQuery, after, before *Cursor) (*UserSettingsQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserSettingsOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *usersettingsPager) applyOrder(query *UserSettingsQuery) *UserSettingsQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserSettingsOrder.Field {
		query = query.Order(DefaultUserSettingsOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *usersettingsPager) orderExpr(query *UserSettingsQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserSettingsOrder.Field {
			b.Comma().Ident(DefaultUserSettingsOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserSettings.
func (us *UserSettingsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserSettingsPaginateOption,
) (*UserSettingsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserSettingsPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if us, err = pager.applyFilter(us); err != nil {
		return nil, err
	}
	conn := &UserSettingsConnection{Edges: []*UserSettingsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := us.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if us, err = pager.applyCursors(us, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		us.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := us.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	us = pager.applyOrder(us)
	nodes, err := us.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserSettingsOrderField defines the ordering field of UserSettings.
type UserSettingsOrderField struct {
	// Value extracts the ordering value from the given UserSettings.
	Value    func(*UserSettings) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) usersettings.OrderOption
	toCursor func(*UserSettings) Cursor
}

// UserSettingsOrder defines the ordering of UserSettings.
type UserSettingsOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *UserSettingsOrderField `json:"field"`
}

// DefaultUserSettingsOrder is the default ordering of UserSettings.
var DefaultUserSettingsOrder = &UserSettingsOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserSettingsOrderField{
		Value: func(us *UserSettings) (ent.Value, error) {
			return us.ID, nil
		},
		column: usersettings.FieldID,
		toTerm: usersettings.ByID,
		toCursor: func(us *UserSettings) Cursor {
			return Cursor{ID: us.ID}
		},
	},
}

// ToEdge converts UserSettings into UserSettingsEdge.
func (us *UserSettings) ToEdge(order *UserSettingsOrder) *UserSettingsEdge {
	if order == nil {
		order = DefaultUserSettingsOrder
	}
	return &UserSettingsEdge{
		Node:   us,
		Cursor: order.Field.toCursor(us),
	}
}

// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/Dan6erbond/revline/ent/car"
	"github.com/Dan6erbond/revline/ent/dragresult"
	"github.com/Dan6erbond/revline/ent/dragsession"
	"github.com/Dan6erbond/revline/ent/fuelup"
	"github.com/Dan6erbond/revline/ent/media"
	"github.com/Dan6erbond/revline/ent/odometerreading"
	"github.com/Dan6erbond/revline/ent/profile"
	"github.com/Dan6erbond/revline/ent/serviceitem"
	"github.com/Dan6erbond/revline/ent/servicelog"
	"github.com/Dan6erbond/revline/ent/serviceschedule"
	"github.com/Dan6erbond/revline/ent/user"
	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[uuid.UUID]
	PageInfo       = entgql.PageInfo[uuid.UUID]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// CarEdge is the edge representation of Car.
type CarEdge struct {
	Node   *Car   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// CarConnection is the connection containing edges to Car.
type CarConnection struct {
	Edges      []*CarEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

func (c *CarConnection) build(nodes []*Car, pager *carPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Car
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Car {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Car {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarPaginateOption enables pagination customization.
type CarPaginateOption func(*carPager) error

// WithCarOrder configures pagination ordering.
func WithCarOrder(order *CarOrder) CarPaginateOption {
	if order == nil {
		order = DefaultCarOrder
	}
	o := *order
	return func(pager *carPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarFilter configures pagination filter.
func WithCarFilter(filter func(*CarQuery) (*CarQuery, error)) CarPaginateOption {
	return func(pager *carPager) error {
		if filter == nil {
			return errors.New("CarQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carPager struct {
	reverse bool
	order   *CarOrder
	filter  func(*CarQuery) (*CarQuery, error)
}

func newCarPager(opts []CarPaginateOption, reverse bool) (*carPager, error) {
	pager := &carPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarOrder
	}
	return pager, nil
}

func (p *carPager) applyFilter(query *CarQuery) (*CarQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carPager) toCursor(c *Car) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *carPager) applyCursors(query *CarQuery, after, before *Cursor) (*CarQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carPager) applyOrder(query *CarQuery) *CarQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarOrder.Field {
		query = query.Order(DefaultCarOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carPager) orderExpr(query *CarQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarOrder.Field {
			b.Comma().Ident(DefaultCarOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Car.
func (c *CarQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarPaginateOption,
) (*CarConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CarConnection{Edges: []*CarEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarOrderField defines the ordering field of Car.
type CarOrderField struct {
	// Value extracts the ordering value from the given Car.
	Value    func(*Car) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) car.OrderOption
	toCursor func(*Car) Cursor
}

// CarOrder defines the ordering of Car.
type CarOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *CarOrderField `json:"field"`
}

// DefaultCarOrder is the default ordering of Car.
var DefaultCarOrder = &CarOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarOrderField{
		Value: func(c *Car) (ent.Value, error) {
			return c.ID, nil
		},
		column: car.FieldID,
		toTerm: car.ByID,
		toCursor: func(c *Car) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Car into CarEdge.
func (c *Car) ToEdge(order *CarOrder) *CarEdge {
	if order == nil {
		order = DefaultCarOrder
	}
	return &CarEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// DragResultEdge is the edge representation of DragResult.
type DragResultEdge struct {
	Node   *DragResult `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// DragResultConnection is the connection containing edges to DragResult.
type DragResultConnection struct {
	Edges      []*DragResultEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *DragResultConnection) build(nodes []*DragResult, pager *dragresultPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DragResult
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DragResult {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DragResult {
			return nodes[i]
		}
	}
	c.Edges = make([]*DragResultEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DragResultEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DragResultPaginateOption enables pagination customization.
type DragResultPaginateOption func(*dragresultPager) error

// WithDragResultOrder configures pagination ordering.
func WithDragResultOrder(order *DragResultOrder) DragResultPaginateOption {
	if order == nil {
		order = DefaultDragResultOrder
	}
	o := *order
	return func(pager *dragresultPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDragResultOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDragResultFilter configures pagination filter.
func WithDragResultFilter(filter func(*DragResultQuery) (*DragResultQuery, error)) DragResultPaginateOption {
	return func(pager *dragresultPager) error {
		if filter == nil {
			return errors.New("DragResultQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dragresultPager struct {
	reverse bool
	order   *DragResultOrder
	filter  func(*DragResultQuery) (*DragResultQuery, error)
}

func newDragResultPager(opts []DragResultPaginateOption, reverse bool) (*dragresultPager, error) {
	pager := &dragresultPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDragResultOrder
	}
	return pager, nil
}

func (p *dragresultPager) applyFilter(query *DragResultQuery) (*DragResultQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dragresultPager) toCursor(dr *DragResult) Cursor {
	return p.order.Field.toCursor(dr)
}

func (p *dragresultPager) applyCursors(query *DragResultQuery, after, before *Cursor) (*DragResultQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDragResultOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *dragresultPager) applyOrder(query *DragResultQuery) *DragResultQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDragResultOrder.Field {
		query = query.Order(DefaultDragResultOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *dragresultPager) orderExpr(query *DragResultQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDragResultOrder.Field {
			b.Comma().Ident(DefaultDragResultOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DragResult.
func (dr *DragResultQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DragResultPaginateOption,
) (*DragResultConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDragResultPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if dr, err = pager.applyFilter(dr); err != nil {
		return nil, err
	}
	conn := &DragResultConnection{Edges: []*DragResultEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := dr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if dr, err = pager.applyCursors(dr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		dr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	dr = pager.applyOrder(dr)
	nodes, err := dr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DragResultOrderField defines the ordering field of DragResult.
type DragResultOrderField struct {
	// Value extracts the ordering value from the given DragResult.
	Value    func(*DragResult) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) dragresult.OrderOption
	toCursor func(*DragResult) Cursor
}

// DragResultOrder defines the ordering of DragResult.
type DragResultOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *DragResultOrderField `json:"field"`
}

// DefaultDragResultOrder is the default ordering of DragResult.
var DefaultDragResultOrder = &DragResultOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DragResultOrderField{
		Value: func(dr *DragResult) (ent.Value, error) {
			return dr.ID, nil
		},
		column: dragresult.FieldID,
		toTerm: dragresult.ByID,
		toCursor: func(dr *DragResult) Cursor {
			return Cursor{ID: dr.ID}
		},
	},
}

// ToEdge converts DragResult into DragResultEdge.
func (dr *DragResult) ToEdge(order *DragResultOrder) *DragResultEdge {
	if order == nil {
		order = DefaultDragResultOrder
	}
	return &DragResultEdge{
		Node:   dr,
		Cursor: order.Field.toCursor(dr),
	}
}

// DragSessionEdge is the edge representation of DragSession.
type DragSessionEdge struct {
	Node   *DragSession `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// DragSessionConnection is the connection containing edges to DragSession.
type DragSessionConnection struct {
	Edges      []*DragSessionEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *DragSessionConnection) build(nodes []*DragSession, pager *dragsessionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DragSession
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DragSession {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DragSession {
			return nodes[i]
		}
	}
	c.Edges = make([]*DragSessionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DragSessionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DragSessionPaginateOption enables pagination customization.
type DragSessionPaginateOption func(*dragsessionPager) error

// WithDragSessionOrder configures pagination ordering.
func WithDragSessionOrder(order *DragSessionOrder) DragSessionPaginateOption {
	if order == nil {
		order = DefaultDragSessionOrder
	}
	o := *order
	return func(pager *dragsessionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDragSessionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDragSessionFilter configures pagination filter.
func WithDragSessionFilter(filter func(*DragSessionQuery) (*DragSessionQuery, error)) DragSessionPaginateOption {
	return func(pager *dragsessionPager) error {
		if filter == nil {
			return errors.New("DragSessionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dragsessionPager struct {
	reverse bool
	order   *DragSessionOrder
	filter  func(*DragSessionQuery) (*DragSessionQuery, error)
}

func newDragSessionPager(opts []DragSessionPaginateOption, reverse bool) (*dragsessionPager, error) {
	pager := &dragsessionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDragSessionOrder
	}
	return pager, nil
}

func (p *dragsessionPager) applyFilter(query *DragSessionQuery) (*DragSessionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dragsessionPager) toCursor(ds *DragSession) Cursor {
	return p.order.Field.toCursor(ds)
}

func (p *dragsessionPager) applyCursors(query *DragSessionQuery, after, before *Cursor) (*DragSessionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDragSessionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *dragsessionPager) applyOrder(query *DragSessionQuery) *DragSessionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDragSessionOrder.Field {
		query = query.Order(DefaultDragSessionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *dragsessionPager) orderExpr(query *DragSessionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDragSessionOrder.Field {
			b.Comma().Ident(DefaultDragSessionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DragSession.
func (ds *DragSessionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DragSessionPaginateOption,
) (*DragSessionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDragSessionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ds, err = pager.applyFilter(ds); err != nil {
		return nil, err
	}
	conn := &DragSessionConnection{Edges: []*DragSessionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ds.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ds, err = pager.applyCursors(ds, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ds.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ds.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ds = pager.applyOrder(ds)
	nodes, err := ds.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DragSessionOrderField defines the ordering field of DragSession.
type DragSessionOrderField struct {
	// Value extracts the ordering value from the given DragSession.
	Value    func(*DragSession) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) dragsession.OrderOption
	toCursor func(*DragSession) Cursor
}

// DragSessionOrder defines the ordering of DragSession.
type DragSessionOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *DragSessionOrderField `json:"field"`
}

// DefaultDragSessionOrder is the default ordering of DragSession.
var DefaultDragSessionOrder = &DragSessionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DragSessionOrderField{
		Value: func(ds *DragSession) (ent.Value, error) {
			return ds.ID, nil
		},
		column: dragsession.FieldID,
		toTerm: dragsession.ByID,
		toCursor: func(ds *DragSession) Cursor {
			return Cursor{ID: ds.ID}
		},
	},
}

// ToEdge converts DragSession into DragSessionEdge.
func (ds *DragSession) ToEdge(order *DragSessionOrder) *DragSessionEdge {
	if order == nil {
		order = DefaultDragSessionOrder
	}
	return &DragSessionEdge{
		Node:   ds,
		Cursor: order.Field.toCursor(ds),
	}
}

// FuelUpEdge is the edge representation of FuelUp.
type FuelUpEdge struct {
	Node   *FuelUp `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// FuelUpConnection is the connection containing edges to FuelUp.
type FuelUpConnection struct {
	Edges      []*FuelUpEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *FuelUpConnection) build(nodes []*FuelUp, pager *fuelupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *FuelUp
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FuelUp {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FuelUp {
			return nodes[i]
		}
	}
	c.Edges = make([]*FuelUpEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FuelUpEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FuelUpPaginateOption enables pagination customization.
type FuelUpPaginateOption func(*fuelupPager) error

// WithFuelUpOrder configures pagination ordering.
func WithFuelUpOrder(order *FuelUpOrder) FuelUpPaginateOption {
	if order == nil {
		order = DefaultFuelUpOrder
	}
	o := *order
	return func(pager *fuelupPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFuelUpOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFuelUpFilter configures pagination filter.
func WithFuelUpFilter(filter func(*FuelUpQuery) (*FuelUpQuery, error)) FuelUpPaginateOption {
	return func(pager *fuelupPager) error {
		if filter == nil {
			return errors.New("FuelUpQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type fuelupPager struct {
	reverse bool
	order   *FuelUpOrder
	filter  func(*FuelUpQuery) (*FuelUpQuery, error)
}

func newFuelUpPager(opts []FuelUpPaginateOption, reverse bool) (*fuelupPager, error) {
	pager := &fuelupPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFuelUpOrder
	}
	return pager, nil
}

func (p *fuelupPager) applyFilter(query *FuelUpQuery) (*FuelUpQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *fuelupPager) toCursor(fu *FuelUp) Cursor {
	return p.order.Field.toCursor(fu)
}

func (p *fuelupPager) applyCursors(query *FuelUpQuery, after, before *Cursor) (*FuelUpQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFuelUpOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *fuelupPager) applyOrder(query *FuelUpQuery) *FuelUpQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFuelUpOrder.Field {
		query = query.Order(DefaultFuelUpOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *fuelupPager) orderExpr(query *FuelUpQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFuelUpOrder.Field {
			b.Comma().Ident(DefaultFuelUpOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FuelUp.
func (fu *FuelUpQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FuelUpPaginateOption,
) (*FuelUpConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFuelUpPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if fu, err = pager.applyFilter(fu); err != nil {
		return nil, err
	}
	conn := &FuelUpConnection{Edges: []*FuelUpEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := fu.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if fu, err = pager.applyCursors(fu, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		fu.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := fu.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	fu = pager.applyOrder(fu)
	nodes, err := fu.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FuelUpOrderField defines the ordering field of FuelUp.
type FuelUpOrderField struct {
	// Value extracts the ordering value from the given FuelUp.
	Value    func(*FuelUp) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) fuelup.OrderOption
	toCursor func(*FuelUp) Cursor
}

// FuelUpOrder defines the ordering of FuelUp.
type FuelUpOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *FuelUpOrderField `json:"field"`
}

// DefaultFuelUpOrder is the default ordering of FuelUp.
var DefaultFuelUpOrder = &FuelUpOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FuelUpOrderField{
		Value: func(fu *FuelUp) (ent.Value, error) {
			return fu.ID, nil
		},
		column: fuelup.FieldID,
		toTerm: fuelup.ByID,
		toCursor: func(fu *FuelUp) Cursor {
			return Cursor{ID: fu.ID}
		},
	},
}

// ToEdge converts FuelUp into FuelUpEdge.
func (fu *FuelUp) ToEdge(order *FuelUpOrder) *FuelUpEdge {
	if order == nil {
		order = DefaultFuelUpOrder
	}
	return &FuelUpEdge{
		Node:   fu,
		Cursor: order.Field.toCursor(fu),
	}
}

// MediaEdge is the edge representation of Media.
type MediaEdge struct {
	Node   *Media `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// MediaConnection is the connection containing edges to Media.
type MediaConnection struct {
	Edges      []*MediaEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *MediaConnection) build(nodes []*Media, pager *mediaPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Media
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Media {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Media {
			return nodes[i]
		}
	}
	c.Edges = make([]*MediaEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &MediaEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// MediaPaginateOption enables pagination customization.
type MediaPaginateOption func(*mediaPager) error

// WithMediaOrder configures pagination ordering.
func WithMediaOrder(order *MediaOrder) MediaPaginateOption {
	if order == nil {
		order = DefaultMediaOrder
	}
	o := *order
	return func(pager *mediaPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMediaOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMediaFilter configures pagination filter.
func WithMediaFilter(filter func(*MediaQuery) (*MediaQuery, error)) MediaPaginateOption {
	return func(pager *mediaPager) error {
		if filter == nil {
			return errors.New("MediaQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type mediaPager struct {
	reverse bool
	order   *MediaOrder
	filter  func(*MediaQuery) (*MediaQuery, error)
}

func newMediaPager(opts []MediaPaginateOption, reverse bool) (*mediaPager, error) {
	pager := &mediaPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMediaOrder
	}
	return pager, nil
}

func (p *mediaPager) applyFilter(query *MediaQuery) (*MediaQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *mediaPager) toCursor(m *Media) Cursor {
	return p.order.Field.toCursor(m)
}

func (p *mediaPager) applyCursors(query *MediaQuery, after, before *Cursor) (*MediaQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultMediaOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *mediaPager) applyOrder(query *MediaQuery) *MediaQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultMediaOrder.Field {
		query = query.Order(DefaultMediaOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *mediaPager) orderExpr(query *MediaQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultMediaOrder.Field {
			b.Comma().Ident(DefaultMediaOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Media.
func (m *MediaQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MediaPaginateOption,
) (*MediaConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMediaPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if m, err = pager.applyFilter(m); err != nil {
		return nil, err
	}
	conn := &MediaConnection{Edges: []*MediaEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if m, err = pager.applyCursors(m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	m = pager.applyOrder(m)
	nodes, err := m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// MediaOrderField defines the ordering field of Media.
type MediaOrderField struct {
	// Value extracts the ordering value from the given Media.
	Value    func(*Media) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) media.OrderOption
	toCursor func(*Media) Cursor
}

// MediaOrder defines the ordering of Media.
type MediaOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *MediaOrderField `json:"field"`
}

// DefaultMediaOrder is the default ordering of Media.
var DefaultMediaOrder = &MediaOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &MediaOrderField{
		Value: func(m *Media) (ent.Value, error) {
			return m.ID, nil
		},
		column: media.FieldID,
		toTerm: media.ByID,
		toCursor: func(m *Media) Cursor {
			return Cursor{ID: m.ID}
		},
	},
}

// ToEdge converts Media into MediaEdge.
func (m *Media) ToEdge(order *MediaOrder) *MediaEdge {
	if order == nil {
		order = DefaultMediaOrder
	}
	return &MediaEdge{
		Node:   m,
		Cursor: order.Field.toCursor(m),
	}
}

// OdometerReadingEdge is the edge representation of OdometerReading.
type OdometerReadingEdge struct {
	Node   *OdometerReading `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// OdometerReadingConnection is the connection containing edges to OdometerReading.
type OdometerReadingConnection struct {
	Edges      []*OdometerReadingEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *OdometerReadingConnection) build(nodes []*OdometerReading, pager *odometerreadingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OdometerReading
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OdometerReading {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OdometerReading {
			return nodes[i]
		}
	}
	c.Edges = make([]*OdometerReadingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OdometerReadingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OdometerReadingPaginateOption enables pagination customization.
type OdometerReadingPaginateOption func(*odometerreadingPager) error

// WithOdometerReadingOrder configures pagination ordering.
func WithOdometerReadingOrder(order *OdometerReadingOrder) OdometerReadingPaginateOption {
	if order == nil {
		order = DefaultOdometerReadingOrder
	}
	o := *order
	return func(pager *odometerreadingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOdometerReadingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOdometerReadingFilter configures pagination filter.
func WithOdometerReadingFilter(filter func(*OdometerReadingQuery) (*OdometerReadingQuery, error)) OdometerReadingPaginateOption {
	return func(pager *odometerreadingPager) error {
		if filter == nil {
			return errors.New("OdometerReadingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type odometerreadingPager struct {
	reverse bool
	order   *OdometerReadingOrder
	filter  func(*OdometerReadingQuery) (*OdometerReadingQuery, error)
}

func newOdometerReadingPager(opts []OdometerReadingPaginateOption, reverse bool) (*odometerreadingPager, error) {
	pager := &odometerreadingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOdometerReadingOrder
	}
	return pager, nil
}

func (p *odometerreadingPager) applyFilter(query *OdometerReadingQuery) (*OdometerReadingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *odometerreadingPager) toCursor(or *OdometerReading) Cursor {
	return p.order.Field.toCursor(or)
}

func (p *odometerreadingPager) applyCursors(query *OdometerReadingQuery, after, before *Cursor) (*OdometerReadingQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOdometerReadingOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *odometerreadingPager) applyOrder(query *OdometerReadingQuery) *OdometerReadingQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOdometerReadingOrder.Field {
		query = query.Order(DefaultOdometerReadingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *odometerreadingPager) orderExpr(query *OdometerReadingQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOdometerReadingOrder.Field {
			b.Comma().Ident(DefaultOdometerReadingOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OdometerReading.
func (or *OdometerReadingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OdometerReadingPaginateOption,
) (*OdometerReadingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOdometerReadingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if or, err = pager.applyFilter(or); err != nil {
		return nil, err
	}
	conn := &OdometerReadingConnection{Edges: []*OdometerReadingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := or.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if or, err = pager.applyCursors(or, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		or.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := or.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	or = pager.applyOrder(or)
	nodes, err := or.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OdometerReadingOrderField defines the ordering field of OdometerReading.
type OdometerReadingOrderField struct {
	// Value extracts the ordering value from the given OdometerReading.
	Value    func(*OdometerReading) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) odometerreading.OrderOption
	toCursor func(*OdometerReading) Cursor
}

// OdometerReadingOrder defines the ordering of OdometerReading.
type OdometerReadingOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *OdometerReadingOrderField `json:"field"`
}

// DefaultOdometerReadingOrder is the default ordering of OdometerReading.
var DefaultOdometerReadingOrder = &OdometerReadingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OdometerReadingOrderField{
		Value: func(or *OdometerReading) (ent.Value, error) {
			return or.ID, nil
		},
		column: odometerreading.FieldID,
		toTerm: odometerreading.ByID,
		toCursor: func(or *OdometerReading) Cursor {
			return Cursor{ID: or.ID}
		},
	},
}

// ToEdge converts OdometerReading into OdometerReadingEdge.
func (or *OdometerReading) ToEdge(order *OdometerReadingOrder) *OdometerReadingEdge {
	if order == nil {
		order = DefaultOdometerReadingOrder
	}
	return &OdometerReadingEdge{
		Node:   or,
		Cursor: order.Field.toCursor(or),
	}
}

// ProfileEdge is the edge representation of Profile.
type ProfileEdge struct {
	Node   *Profile `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProfileConnection is the connection containing edges to Profile.
type ProfileConnection struct {
	Edges      []*ProfileEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProfileConnection) build(nodes []*Profile, pager *profilePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Profile
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Profile {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Profile {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProfileEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProfileEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProfilePaginateOption enables pagination customization.
type ProfilePaginateOption func(*profilePager) error

// WithProfileOrder configures pagination ordering.
func WithProfileOrder(order *ProfileOrder) ProfilePaginateOption {
	if order == nil {
		order = DefaultProfileOrder
	}
	o := *order
	return func(pager *profilePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProfileOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProfileFilter configures pagination filter.
func WithProfileFilter(filter func(*ProfileQuery) (*ProfileQuery, error)) ProfilePaginateOption {
	return func(pager *profilePager) error {
		if filter == nil {
			return errors.New("ProfileQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type profilePager struct {
	reverse bool
	order   *ProfileOrder
	filter  func(*ProfileQuery) (*ProfileQuery, error)
}

func newProfilePager(opts []ProfilePaginateOption, reverse bool) (*profilePager, error) {
	pager := &profilePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProfileOrder
	}
	return pager, nil
}

func (p *profilePager) applyFilter(query *ProfileQuery) (*ProfileQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *profilePager) toCursor(pr *Profile) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *profilePager) applyCursors(query *ProfileQuery, after, before *Cursor) (*ProfileQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProfileOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *profilePager) applyOrder(query *ProfileQuery) *ProfileQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProfileOrder.Field {
		query = query.Order(DefaultProfileOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *profilePager) orderExpr(query *ProfileQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProfileOrder.Field {
			b.Comma().Ident(DefaultProfileOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Profile.
func (pr *ProfileQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProfilePaginateOption,
) (*ProfileConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProfilePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProfileConnection{Edges: []*ProfileEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProfileOrderField defines the ordering field of Profile.
type ProfileOrderField struct {
	// Value extracts the ordering value from the given Profile.
	Value    func(*Profile) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) profile.OrderOption
	toCursor func(*Profile) Cursor
}

// ProfileOrder defines the ordering of Profile.
type ProfileOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProfileOrderField `json:"field"`
}

// DefaultProfileOrder is the default ordering of Profile.
var DefaultProfileOrder = &ProfileOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProfileOrderField{
		Value: func(pr *Profile) (ent.Value, error) {
			return pr.ID, nil
		},
		column: profile.FieldID,
		toTerm: profile.ByID,
		toCursor: func(pr *Profile) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Profile into ProfileEdge.
func (pr *Profile) ToEdge(order *ProfileOrder) *ProfileEdge {
	if order == nil {
		order = DefaultProfileOrder
	}
	return &ProfileEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ServiceItemEdge is the edge representation of ServiceItem.
type ServiceItemEdge struct {
	Node   *ServiceItem `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// ServiceItemConnection is the connection containing edges to ServiceItem.
type ServiceItemConnection struct {
	Edges      []*ServiceItemEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *ServiceItemConnection) build(nodes []*ServiceItem, pager *serviceitemPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ServiceItem
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ServiceItem {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ServiceItem {
			return nodes[i]
		}
	}
	c.Edges = make([]*ServiceItemEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ServiceItemEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ServiceItemPaginateOption enables pagination customization.
type ServiceItemPaginateOption func(*serviceitemPager) error

// WithServiceItemOrder configures pagination ordering.
func WithServiceItemOrder(order *ServiceItemOrder) ServiceItemPaginateOption {
	if order == nil {
		order = DefaultServiceItemOrder
	}
	o := *order
	return func(pager *serviceitemPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultServiceItemOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithServiceItemFilter configures pagination filter.
func WithServiceItemFilter(filter func(*ServiceItemQuery) (*ServiceItemQuery, error)) ServiceItemPaginateOption {
	return func(pager *serviceitemPager) error {
		if filter == nil {
			return errors.New("ServiceItemQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type serviceitemPager struct {
	reverse bool
	order   *ServiceItemOrder
	filter  func(*ServiceItemQuery) (*ServiceItemQuery, error)
}

func newServiceItemPager(opts []ServiceItemPaginateOption, reverse bool) (*serviceitemPager, error) {
	pager := &serviceitemPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultServiceItemOrder
	}
	return pager, nil
}

func (p *serviceitemPager) applyFilter(query *ServiceItemQuery) (*ServiceItemQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *serviceitemPager) toCursor(si *ServiceItem) Cursor {
	return p.order.Field.toCursor(si)
}

func (p *serviceitemPager) applyCursors(query *ServiceItemQuery, after, before *Cursor) (*ServiceItemQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultServiceItemOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *serviceitemPager) applyOrder(query *ServiceItemQuery) *ServiceItemQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultServiceItemOrder.Field {
		query = query.Order(DefaultServiceItemOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *serviceitemPager) orderExpr(query *ServiceItemQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultServiceItemOrder.Field {
			b.Comma().Ident(DefaultServiceItemOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ServiceItem.
func (si *ServiceItemQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ServiceItemPaginateOption,
) (*ServiceItemConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newServiceItemPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if si, err = pager.applyFilter(si); err != nil {
		return nil, err
	}
	conn := &ServiceItemConnection{Edges: []*ServiceItemEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := si.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if si, err = pager.applyCursors(si, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		si.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := si.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	si = pager.applyOrder(si)
	nodes, err := si.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ServiceItemOrderField defines the ordering field of ServiceItem.
type ServiceItemOrderField struct {
	// Value extracts the ordering value from the given ServiceItem.
	Value    func(*ServiceItem) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) serviceitem.OrderOption
	toCursor func(*ServiceItem) Cursor
}

// ServiceItemOrder defines the ordering of ServiceItem.
type ServiceItemOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *ServiceItemOrderField `json:"field"`
}

// DefaultServiceItemOrder is the default ordering of ServiceItem.
var DefaultServiceItemOrder = &ServiceItemOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ServiceItemOrderField{
		Value: func(si *ServiceItem) (ent.Value, error) {
			return si.ID, nil
		},
		column: serviceitem.FieldID,
		toTerm: serviceitem.ByID,
		toCursor: func(si *ServiceItem) Cursor {
			return Cursor{ID: si.ID}
		},
	},
}

// ToEdge converts ServiceItem into ServiceItemEdge.
func (si *ServiceItem) ToEdge(order *ServiceItemOrder) *ServiceItemEdge {
	if order == nil {
		order = DefaultServiceItemOrder
	}
	return &ServiceItemEdge{
		Node:   si,
		Cursor: order.Field.toCursor(si),
	}
}

// ServiceLogEdge is the edge representation of ServiceLog.
type ServiceLogEdge struct {
	Node   *ServiceLog `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ServiceLogConnection is the connection containing edges to ServiceLog.
type ServiceLogConnection struct {
	Edges      []*ServiceLogEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *ServiceLogConnection) build(nodes []*ServiceLog, pager *servicelogPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ServiceLog
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ServiceLog {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ServiceLog {
			return nodes[i]
		}
	}
	c.Edges = make([]*ServiceLogEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ServiceLogEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ServiceLogPaginateOption enables pagination customization.
type ServiceLogPaginateOption func(*servicelogPager) error

// WithServiceLogOrder configures pagination ordering.
func WithServiceLogOrder(order *ServiceLogOrder) ServiceLogPaginateOption {
	if order == nil {
		order = DefaultServiceLogOrder
	}
	o := *order
	return func(pager *servicelogPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultServiceLogOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithServiceLogFilter configures pagination filter.
func WithServiceLogFilter(filter func(*ServiceLogQuery) (*ServiceLogQuery, error)) ServiceLogPaginateOption {
	return func(pager *servicelogPager) error {
		if filter == nil {
			return errors.New("ServiceLogQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type servicelogPager struct {
	reverse bool
	order   *ServiceLogOrder
	filter  func(*ServiceLogQuery) (*ServiceLogQuery, error)
}

func newServiceLogPager(opts []ServiceLogPaginateOption, reverse bool) (*servicelogPager, error) {
	pager := &servicelogPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultServiceLogOrder
	}
	return pager, nil
}

func (p *servicelogPager) applyFilter(query *ServiceLogQuery) (*ServiceLogQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *servicelogPager) toCursor(sl *ServiceLog) Cursor {
	return p.order.Field.toCursor(sl)
}

func (p *servicelogPager) applyCursors(query *ServiceLogQuery, after, before *Cursor) (*ServiceLogQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultServiceLogOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *servicelogPager) applyOrder(query *ServiceLogQuery) *ServiceLogQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultServiceLogOrder.Field {
		query = query.Order(DefaultServiceLogOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *servicelogPager) orderExpr(query *ServiceLogQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultServiceLogOrder.Field {
			b.Comma().Ident(DefaultServiceLogOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ServiceLog.
func (sl *ServiceLogQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ServiceLogPaginateOption,
) (*ServiceLogConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newServiceLogPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sl, err = pager.applyFilter(sl); err != nil {
		return nil, err
	}
	conn := &ServiceLogConnection{Edges: []*ServiceLogEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sl.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sl, err = pager.applyCursors(sl, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sl.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sl.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sl = pager.applyOrder(sl)
	nodes, err := sl.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ServiceLogOrderField defines the ordering field of ServiceLog.
type ServiceLogOrderField struct {
	// Value extracts the ordering value from the given ServiceLog.
	Value    func(*ServiceLog) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) servicelog.OrderOption
	toCursor func(*ServiceLog) Cursor
}

// ServiceLogOrder defines the ordering of ServiceLog.
type ServiceLogOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ServiceLogOrderField `json:"field"`
}

// DefaultServiceLogOrder is the default ordering of ServiceLog.
var DefaultServiceLogOrder = &ServiceLogOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ServiceLogOrderField{
		Value: func(sl *ServiceLog) (ent.Value, error) {
			return sl.ID, nil
		},
		column: servicelog.FieldID,
		toTerm: servicelog.ByID,
		toCursor: func(sl *ServiceLog) Cursor {
			return Cursor{ID: sl.ID}
		},
	},
}

// ToEdge converts ServiceLog into ServiceLogEdge.
func (sl *ServiceLog) ToEdge(order *ServiceLogOrder) *ServiceLogEdge {
	if order == nil {
		order = DefaultServiceLogOrder
	}
	return &ServiceLogEdge{
		Node:   sl,
		Cursor: order.Field.toCursor(sl),
	}
}

// ServiceScheduleEdge is the edge representation of ServiceSchedule.
type ServiceScheduleEdge struct {
	Node   *ServiceSchedule `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// ServiceScheduleConnection is the connection containing edges to ServiceSchedule.
type ServiceScheduleConnection struct {
	Edges      []*ServiceScheduleEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *ServiceScheduleConnection) build(nodes []*ServiceSchedule, pager *serviceschedulePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ServiceSchedule
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ServiceSchedule {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ServiceSchedule {
			return nodes[i]
		}
	}
	c.Edges = make([]*ServiceScheduleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ServiceScheduleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ServiceSchedulePaginateOption enables pagination customization.
type ServiceSchedulePaginateOption func(*serviceschedulePager) error

// WithServiceScheduleOrder configures pagination ordering.
func WithServiceScheduleOrder(order *ServiceScheduleOrder) ServiceSchedulePaginateOption {
	if order == nil {
		order = DefaultServiceScheduleOrder
	}
	o := *order
	return func(pager *serviceschedulePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultServiceScheduleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithServiceScheduleFilter configures pagination filter.
func WithServiceScheduleFilter(filter func(*ServiceScheduleQuery) (*ServiceScheduleQuery, error)) ServiceSchedulePaginateOption {
	return func(pager *serviceschedulePager) error {
		if filter == nil {
			return errors.New("ServiceScheduleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type serviceschedulePager struct {
	reverse bool
	order   *ServiceScheduleOrder
	filter  func(*ServiceScheduleQuery) (*ServiceScheduleQuery, error)
}

func newServiceSchedulePager(opts []ServiceSchedulePaginateOption, reverse bool) (*serviceschedulePager, error) {
	pager := &serviceschedulePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultServiceScheduleOrder
	}
	return pager, nil
}

func (p *serviceschedulePager) applyFilter(query *ServiceScheduleQuery) (*ServiceScheduleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *serviceschedulePager) toCursor(ss *ServiceSchedule) Cursor {
	return p.order.Field.toCursor(ss)
}

func (p *serviceschedulePager) applyCursors(query *ServiceScheduleQuery, after, before *Cursor) (*ServiceScheduleQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultServiceScheduleOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *serviceschedulePager) applyOrder(query *ServiceScheduleQuery) *ServiceScheduleQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultServiceScheduleOrder.Field {
		query = query.Order(DefaultServiceScheduleOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *serviceschedulePager) orderExpr(query *ServiceScheduleQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultServiceScheduleOrder.Field {
			b.Comma().Ident(DefaultServiceScheduleOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ServiceSchedule.
func (ss *ServiceScheduleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ServiceSchedulePaginateOption,
) (*ServiceScheduleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newServiceSchedulePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ss, err = pager.applyFilter(ss); err != nil {
		return nil, err
	}
	conn := &ServiceScheduleConnection{Edges: []*ServiceScheduleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ss.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ss, err = pager.applyCursors(ss, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ss.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ss.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ss = pager.applyOrder(ss)
	nodes, err := ss.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ServiceScheduleOrderField defines the ordering field of ServiceSchedule.
type ServiceScheduleOrderField struct {
	// Value extracts the ordering value from the given ServiceSchedule.
	Value    func(*ServiceSchedule) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) serviceschedule.OrderOption
	toCursor func(*ServiceSchedule) Cursor
}

// ServiceScheduleOrder defines the ordering of ServiceSchedule.
type ServiceScheduleOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *ServiceScheduleOrderField `json:"field"`
}

// DefaultServiceScheduleOrder is the default ordering of ServiceSchedule.
var DefaultServiceScheduleOrder = &ServiceScheduleOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ServiceScheduleOrderField{
		Value: func(ss *ServiceSchedule) (ent.Value, error) {
			return ss.ID, nil
		},
		column: serviceschedule.FieldID,
		toTerm: serviceschedule.ByID,
		toCursor: func(ss *ServiceSchedule) Cursor {
			return Cursor{ID: ss.ID}
		},
	},
}

// ToEdge converts ServiceSchedule into ServiceScheduleEdge.
func (ss *ServiceSchedule) ToEdge(order *ServiceScheduleOrder) *ServiceScheduleEdge {
	if order == nil {
		order = DefaultServiceScheduleOrder
	}
	return &ServiceScheduleEdge{
		Node:   ss,
		Cursor: order.Field.toCursor(ss),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := u.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}

// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/Dan6erbond/revline/ent/album"
	"github.com/Dan6erbond/revline/ent/buildlog"
	"github.com/Dan6erbond/revline/ent/car"
	"github.com/Dan6erbond/revline/ent/checkoutsession"
	"github.com/Dan6erbond/revline/ent/document"
	"github.com/Dan6erbond/revline/ent/dragresult"
	"github.com/Dan6erbond/revline/ent/dragsession"
	"github.com/Dan6erbond/revline/ent/dynoresult"
	"github.com/Dan6erbond/revline/ent/dynosession"
	"github.com/Dan6erbond/revline/ent/expense"
	"github.com/Dan6erbond/revline/ent/fuelup"
	"github.com/Dan6erbond/revline/ent/media"
	"github.com/Dan6erbond/revline/ent/mod"
	"github.com/Dan6erbond/revline/ent/modproductoption"
	"github.com/Dan6erbond/revline/ent/odometerreading"
	"github.com/Dan6erbond/revline/ent/predicate"
	"github.com/Dan6erbond/revline/ent/profile"
	"github.com/Dan6erbond/revline/ent/serviceitem"
	"github.com/Dan6erbond/revline/ent/servicelog"
	"github.com/Dan6erbond/revline/ent/serviceschedule"
	"github.com/Dan6erbond/revline/ent/subscription"
	"github.com/Dan6erbond/revline/ent/task"
	"github.com/Dan6erbond/revline/ent/user"
	"github.com/Dan6erbond/revline/ent/usersettings"
	"github.com/google/uuid"
)

// AlbumWhereInput represents a where input for filtering Album queries.
type AlbumWhereInput struct {
	Predicates []predicate.Album  `json:"-"`
	Not        *AlbumWhereInput   `json:"not,omitempty"`
	Or         []*AlbumWhereInput `json:"or,omitempty"`
	And        []*AlbumWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "media" edge predicates.
	HasMedia     *bool              `json:"hasMedia,omitempty"`
	HasMediaWith []*MediaWhereInput `json:"hasMediaWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AlbumWhereInput) AddPredicates(predicates ...predicate.Album) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AlbumWhereInput filter on the AlbumQuery builder.
func (i *AlbumWhereInput) Filter(q *AlbumQuery) (*AlbumQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAlbumWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAlbumWhereInput is returned in case the AlbumWhereInput is empty.
var ErrEmptyAlbumWhereInput = errors.New("ent: empty predicate AlbumWhereInput")

// P returns a predicate for filtering albums.
// An error is returned if the input is empty or invalid.
func (i *AlbumWhereInput) P() (predicate.Album, error) {
	var predicates []predicate.Album
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, album.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Album, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, album.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Album, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, album.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, album.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, album.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, album.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, album.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, album.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, album.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, album.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, album.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, album.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, album.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, album.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, album.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, album.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, album.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, album.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, album.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, album.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, album.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, album.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, album.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, album.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, album.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, album.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, album.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, album.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, album.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, album.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, album.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, album.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, album.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, album.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, album.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, album.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, album.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, album.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, album.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, album.TitleContainsFold(*i.TitleContainsFold))
	}

	if i.HasCar != nil {
		p := album.HasCar()
		if !*i.HasCar {
			p = album.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, album.HasCarWith(with...))
	}
	if i.HasMedia != nil {
		p := album.HasMedia()
		if !*i.HasMedia {
			p = album.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMediaWith) > 0 {
		with := make([]predicate.Media, 0, len(i.HasMediaWith))
		for _, w := range i.HasMediaWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMediaWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, album.HasMediaWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAlbumWhereInput
	case 1:
		return predicates[0], nil
	default:
		return album.And(predicates...), nil
	}
}

// BuildLogWhereInput represents a where input for filtering BuildLog queries.
type BuildLogWhereInput struct {
	Predicates []predicate.BuildLog  `json:"-"`
	Not        *BuildLogWhereInput   `json:"not,omitempty"`
	Or         []*BuildLogWhereInput `json:"or,omitempty"`
	And        []*BuildLogWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "log_time" field predicates.
	LogTime      *time.Time  `json:"logTime,omitempty"`
	LogTimeNEQ   *time.Time  `json:"logTimeNEQ,omitempty"`
	LogTimeIn    []time.Time `json:"logTimeIn,omitempty"`
	LogTimeNotIn []time.Time `json:"logTimeNotIn,omitempty"`
	LogTimeGT    *time.Time  `json:"logTimeGT,omitempty"`
	LogTimeGTE   *time.Time  `json:"logTimeGTE,omitempty"`
	LogTimeLT    *time.Time  `json:"logTimeLT,omitempty"`
	LogTimeLTE   *time.Time  `json:"logTimeLTE,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "mods" edge predicates.
	HasMods     *bool            `json:"hasMods,omitempty"`
	HasModsWith []*ModWhereInput `json:"hasModsWith,omitempty"`

	// "media" edge predicates.
	HasMedia     *bool              `json:"hasMedia,omitempty"`
	HasMediaWith []*MediaWhereInput `json:"hasMediaWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BuildLogWhereInput) AddPredicates(predicates ...predicate.BuildLog) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BuildLogWhereInput filter on the BuildLogQuery builder.
func (i *BuildLogWhereInput) Filter(q *BuildLogQuery) (*BuildLogQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBuildLogWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBuildLogWhereInput is returned in case the BuildLogWhereInput is empty.
var ErrEmptyBuildLogWhereInput = errors.New("ent: empty predicate BuildLogWhereInput")

// P returns a predicate for filtering buildlogs.
// An error is returned if the input is empty or invalid.
func (i *BuildLogWhereInput) P() (predicate.BuildLog, error) {
	var predicates []predicate.BuildLog
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, buildlog.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.BuildLog, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, buildlog.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.BuildLog, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, buildlog.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, buildlog.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, buildlog.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, buildlog.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, buildlog.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, buildlog.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, buildlog.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, buildlog.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, buildlog.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, buildlog.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, buildlog.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, buildlog.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, buildlog.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, buildlog.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, buildlog.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, buildlog.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, buildlog.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, buildlog.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, buildlog.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, buildlog.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, buildlog.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, buildlog.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, buildlog.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, buildlog.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, buildlog.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, buildlog.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, buildlog.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, buildlog.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, buildlog.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, buildlog.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, buildlog.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, buildlog.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, buildlog.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, buildlog.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, buildlog.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, buildlog.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, buildlog.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, buildlog.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.LogTime != nil {
		predicates = append(predicates, buildlog.LogTimeEQ(*i.LogTime))
	}
	if i.LogTimeNEQ != nil {
		predicates = append(predicates, buildlog.LogTimeNEQ(*i.LogTimeNEQ))
	}
	if len(i.LogTimeIn) > 0 {
		predicates = append(predicates, buildlog.LogTimeIn(i.LogTimeIn...))
	}
	if len(i.LogTimeNotIn) > 0 {
		predicates = append(predicates, buildlog.LogTimeNotIn(i.LogTimeNotIn...))
	}
	if i.LogTimeGT != nil {
		predicates = append(predicates, buildlog.LogTimeGT(*i.LogTimeGT))
	}
	if i.LogTimeGTE != nil {
		predicates = append(predicates, buildlog.LogTimeGTE(*i.LogTimeGTE))
	}
	if i.LogTimeLT != nil {
		predicates = append(predicates, buildlog.LogTimeLT(*i.LogTimeLT))
	}
	if i.LogTimeLTE != nil {
		predicates = append(predicates, buildlog.LogTimeLTE(*i.LogTimeLTE))
	}

	if i.HasCar != nil {
		p := buildlog.HasCar()
		if !*i.HasCar {
			p = buildlog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, buildlog.HasCarWith(with...))
	}
	if i.HasMods != nil {
		p := buildlog.HasMods()
		if !*i.HasMods {
			p = buildlog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasModsWith) > 0 {
		with := make([]predicate.Mod, 0, len(i.HasModsWith))
		for _, w := range i.HasModsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasModsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, buildlog.HasModsWith(with...))
	}
	if i.HasMedia != nil {
		p := buildlog.HasMedia()
		if !*i.HasMedia {
			p = buildlog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMediaWith) > 0 {
		with := make([]predicate.Media, 0, len(i.HasMediaWith))
		for _, w := range i.HasMediaWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMediaWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, buildlog.HasMediaWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBuildLogWhereInput
	case 1:
		return predicates[0], nil
	default:
		return buildlog.And(predicates...), nil
	}
}

// CarWhereInput represents a where input for filtering Car queries.
type CarWhereInput struct {
	Predicates []predicate.Car  `json:"-"`
	Not        *CarWhereInput   `json:"not,omitempty"`
	Or         []*CarWhereInput `json:"or,omitempty"`
	And        []*CarWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "make" field predicates.
	Make             *string  `json:"make,omitempty"`
	MakeNEQ          *string  `json:"makeNEQ,omitempty"`
	MakeIn           []string `json:"makeIn,omitempty"`
	MakeNotIn        []string `json:"makeNotIn,omitempty"`
	MakeGT           *string  `json:"makeGT,omitempty"`
	MakeGTE          *string  `json:"makeGTE,omitempty"`
	MakeLT           *string  `json:"makeLT,omitempty"`
	MakeLTE          *string  `json:"makeLTE,omitempty"`
	MakeContains     *string  `json:"makeContains,omitempty"`
	MakeHasPrefix    *string  `json:"makeHasPrefix,omitempty"`
	MakeHasSuffix    *string  `json:"makeHasSuffix,omitempty"`
	MakeIsNil        bool     `json:"makeIsNil,omitempty"`
	MakeNotNil       bool     `json:"makeNotNil,omitempty"`
	MakeEqualFold    *string  `json:"makeEqualFold,omitempty"`
	MakeContainsFold *string  `json:"makeContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelIsNil        bool     `json:"modelIsNil,omitempty"`
	ModelNotNil       bool     `json:"modelNotNil,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeIsNil        bool     `json:"typeIsNil,omitempty"`
	TypeNotNil       bool     `json:"typeNotNil,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "year" field predicates.
	Year       *int  `json:"year,omitempty"`
	YearNEQ    *int  `json:"yearNEQ,omitempty"`
	YearIn     []int `json:"yearIn,omitempty"`
	YearNotIn  []int `json:"yearNotIn,omitempty"`
	YearGT     *int  `json:"yearGT,omitempty"`
	YearGTE    *int  `json:"yearGTE,omitempty"`
	YearLT     *int  `json:"yearLT,omitempty"`
	YearLTE    *int  `json:"yearLTE,omitempty"`
	YearIsNil  bool  `json:"yearIsNil,omitempty"`
	YearNotNil bool  `json:"yearNotNil,omitempty"`

	// "trim" field predicates.
	Trim             *string  `json:"trim,omitempty"`
	TrimNEQ          *string  `json:"trimNEQ,omitempty"`
	TrimIn           []string `json:"trimIn,omitempty"`
	TrimNotIn        []string `json:"trimNotIn,omitempty"`
	TrimGT           *string  `json:"trimGT,omitempty"`
	TrimGTE          *string  `json:"trimGTE,omitempty"`
	TrimLT           *string  `json:"trimLT,omitempty"`
	TrimLTE          *string  `json:"trimLTE,omitempty"`
	TrimContains     *string  `json:"trimContains,omitempty"`
	TrimHasPrefix    *string  `json:"trimHasPrefix,omitempty"`
	TrimHasSuffix    *string  `json:"trimHasSuffix,omitempty"`
	TrimIsNil        bool     `json:"trimIsNil,omitempty"`
	TrimNotNil       bool     `json:"trimNotNil,omitempty"`
	TrimEqualFold    *string  `json:"trimEqualFold,omitempty"`
	TrimContainsFold *string  `json:"trimContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`

	// "drag_sessions" edge predicates.
	HasDragSessions     *bool                    `json:"hasDragSessions,omitempty"`
	HasDragSessionsWith []*DragSessionWhereInput `json:"hasDragSessionsWith,omitempty"`

	// "fuel_ups" edge predicates.
	HasFuelUps     *bool               `json:"hasFuelUps,omitempty"`
	HasFuelUpsWith []*FuelUpWhereInput `json:"hasFuelUpsWith,omitempty"`

	// "odometer_readings" edge predicates.
	HasOdometerReadings     *bool                        `json:"hasOdometerReadings,omitempty"`
	HasOdometerReadingsWith []*OdometerReadingWhereInput `json:"hasOdometerReadingsWith,omitempty"`

	// "service_items" edge predicates.
	HasServiceItems     *bool                    `json:"hasServiceItems,omitempty"`
	HasServiceItemsWith []*ServiceItemWhereInput `json:"hasServiceItemsWith,omitempty"`

	// "service_logs" edge predicates.
	HasServiceLogs     *bool                   `json:"hasServiceLogs,omitempty"`
	HasServiceLogsWith []*ServiceLogWhereInput `json:"hasServiceLogsWith,omitempty"`

	// "service_schedules" edge predicates.
	HasServiceSchedules     *bool                        `json:"hasServiceSchedules,omitempty"`
	HasServiceSchedulesWith []*ServiceScheduleWhereInput `json:"hasServiceSchedulesWith,omitempty"`

	// "media" edge predicates.
	HasMedia     *bool              `json:"hasMedia,omitempty"`
	HasMediaWith []*MediaWhereInput `json:"hasMediaWith,omitempty"`

	// "albums" edge predicates.
	HasAlbums     *bool              `json:"hasAlbums,omitempty"`
	HasAlbumsWith []*AlbumWhereInput `json:"hasAlbumsWith,omitempty"`

	// "documents" edge predicates.
	HasDocuments     *bool                 `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentWhereInput `json:"hasDocumentsWith,omitempty"`

	// "dyno_sessions" edge predicates.
	HasDynoSessions     *bool                    `json:"hasDynoSessions,omitempty"`
	HasDynoSessionsWith []*DynoSessionWhereInput `json:"hasDynoSessionsWith,omitempty"`

	// "expenses" edge predicates.
	HasExpenses     *bool                `json:"hasExpenses,omitempty"`
	HasExpensesWith []*ExpenseWhereInput `json:"hasExpensesWith,omitempty"`

	// "build_logs" edge predicates.
	HasBuildLogs     *bool                 `json:"hasBuildLogs,omitempty"`
	HasBuildLogsWith []*BuildLogWhereInput `json:"hasBuildLogsWith,omitempty"`

	// "banner_image" edge predicates.
	HasBannerImage     *bool              `json:"hasBannerImage,omitempty"`
	HasBannerImageWith []*MediaWhereInput `json:"hasBannerImageWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`

	// "mods" edge predicates.
	HasMods     *bool            `json:"hasMods,omitempty"`
	HasModsWith []*ModWhereInput `json:"hasModsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarWhereInput) AddPredicates(predicates ...predicate.Car) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarWhereInput filter on the CarQuery builder.
func (i *CarWhereInput) Filter(q *CarQuery) (*CarQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarWhereInput is returned in case the CarWhereInput is empty.
var ErrEmptyCarWhereInput = errors.New("ent: empty predicate CarWhereInput")

// P returns a predicate for filtering cars.
// An error is returned if the input is empty or invalid.
func (i *CarWhereInput) P() (predicate.Car, error) {
	var predicates []predicate.Car
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, car.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Car, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, car.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Car, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, car.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, car.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, car.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, car.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, car.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, car.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, car.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, car.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, car.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, car.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, car.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, car.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, car.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, car.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, car.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, car.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, car.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, car.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, car.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, car.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, car.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, car.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, car.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, car.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, car.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, car.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, car.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, car.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, car.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, car.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, car.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, car.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, car.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, car.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, car.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, car.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, car.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, car.NameContainsFold(*i.NameContainsFold))
	}
	if i.Make != nil {
		predicates = append(predicates, car.MakeEQ(*i.Make))
	}
	if i.MakeNEQ != nil {
		predicates = append(predicates, car.MakeNEQ(*i.MakeNEQ))
	}
	if len(i.MakeIn) > 0 {
		predicates = append(predicates, car.MakeIn(i.MakeIn...))
	}
	if len(i.MakeNotIn) > 0 {
		predicates = append(predicates, car.MakeNotIn(i.MakeNotIn...))
	}
	if i.MakeGT != nil {
		predicates = append(predicates, car.MakeGT(*i.MakeGT))
	}
	if i.MakeGTE != nil {
		predicates = append(predicates, car.MakeGTE(*i.MakeGTE))
	}
	if i.MakeLT != nil {
		predicates = append(predicates, car.MakeLT(*i.MakeLT))
	}
	if i.MakeLTE != nil {
		predicates = append(predicates, car.MakeLTE(*i.MakeLTE))
	}
	if i.MakeContains != nil {
		predicates = append(predicates, car.MakeContains(*i.MakeContains))
	}
	if i.MakeHasPrefix != nil {
		predicates = append(predicates, car.MakeHasPrefix(*i.MakeHasPrefix))
	}
	if i.MakeHasSuffix != nil {
		predicates = append(predicates, car.MakeHasSuffix(*i.MakeHasSuffix))
	}
	if i.MakeIsNil {
		predicates = append(predicates, car.MakeIsNil())
	}
	if i.MakeNotNil {
		predicates = append(predicates, car.MakeNotNil())
	}
	if i.MakeEqualFold != nil {
		predicates = append(predicates, car.MakeEqualFold(*i.MakeEqualFold))
	}
	if i.MakeContainsFold != nil {
		predicates = append(predicates, car.MakeContainsFold(*i.MakeContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, car.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, car.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, car.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, car.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, car.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, car.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, car.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, car.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, car.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, car.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, car.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelIsNil {
		predicates = append(predicates, car.ModelIsNil())
	}
	if i.ModelNotNil {
		predicates = append(predicates, car.ModelNotNil())
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, car.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, car.ModelContainsFold(*i.ModelContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, car.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, car.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, car.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, car.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, car.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, car.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, car.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, car.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, car.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, car.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, car.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeIsNil {
		predicates = append(predicates, car.TypeIsNil())
	}
	if i.TypeNotNil {
		predicates = append(predicates, car.TypeNotNil())
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, car.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, car.TypeContainsFold(*i.TypeContainsFold))
	}
	if i.Year != nil {
		predicates = append(predicates, car.YearEQ(*i.Year))
	}
	if i.YearNEQ != nil {
		predicates = append(predicates, car.YearNEQ(*i.YearNEQ))
	}
	if len(i.YearIn) > 0 {
		predicates = append(predicates, car.YearIn(i.YearIn...))
	}
	if len(i.YearNotIn) > 0 {
		predicates = append(predicates, car.YearNotIn(i.YearNotIn...))
	}
	if i.YearGT != nil {
		predicates = append(predicates, car.YearGT(*i.YearGT))
	}
	if i.YearGTE != nil {
		predicates = append(predicates, car.YearGTE(*i.YearGTE))
	}
	if i.YearLT != nil {
		predicates = append(predicates, car.YearLT(*i.YearLT))
	}
	if i.YearLTE != nil {
		predicates = append(predicates, car.YearLTE(*i.YearLTE))
	}
	if i.YearIsNil {
		predicates = append(predicates, car.YearIsNil())
	}
	if i.YearNotNil {
		predicates = append(predicates, car.YearNotNil())
	}
	if i.Trim != nil {
		predicates = append(predicates, car.TrimEQ(*i.Trim))
	}
	if i.TrimNEQ != nil {
		predicates = append(predicates, car.TrimNEQ(*i.TrimNEQ))
	}
	if len(i.TrimIn) > 0 {
		predicates = append(predicates, car.TrimIn(i.TrimIn...))
	}
	if len(i.TrimNotIn) > 0 {
		predicates = append(predicates, car.TrimNotIn(i.TrimNotIn...))
	}
	if i.TrimGT != nil {
		predicates = append(predicates, car.TrimGT(*i.TrimGT))
	}
	if i.TrimGTE != nil {
		predicates = append(predicates, car.TrimGTE(*i.TrimGTE))
	}
	if i.TrimLT != nil {
		predicates = append(predicates, car.TrimLT(*i.TrimLT))
	}
	if i.TrimLTE != nil {
		predicates = append(predicates, car.TrimLTE(*i.TrimLTE))
	}
	if i.TrimContains != nil {
		predicates = append(predicates, car.TrimContains(*i.TrimContains))
	}
	if i.TrimHasPrefix != nil {
		predicates = append(predicates, car.TrimHasPrefix(*i.TrimHasPrefix))
	}
	if i.TrimHasSuffix != nil {
		predicates = append(predicates, car.TrimHasSuffix(*i.TrimHasSuffix))
	}
	if i.TrimIsNil {
		predicates = append(predicates, car.TrimIsNil())
	}
	if i.TrimNotNil {
		predicates = append(predicates, car.TrimNotNil())
	}
	if i.TrimEqualFold != nil {
		predicates = append(predicates, car.TrimEqualFold(*i.TrimEqualFold))
	}
	if i.TrimContainsFold != nil {
		predicates = append(predicates, car.TrimContainsFold(*i.TrimContainsFold))
	}

	if i.HasOwner != nil {
		p := car.HasOwner()
		if !*i.HasOwner {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasOwnerWith(with...))
	}
	if i.HasDragSessions != nil {
		p := car.HasDragSessions()
		if !*i.HasDragSessions {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDragSessionsWith) > 0 {
		with := make([]predicate.DragSession, 0, len(i.HasDragSessionsWith))
		for _, w := range i.HasDragSessionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDragSessionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasDragSessionsWith(with...))
	}
	if i.HasFuelUps != nil {
		p := car.HasFuelUps()
		if !*i.HasFuelUps {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFuelUpsWith) > 0 {
		with := make([]predicate.FuelUp, 0, len(i.HasFuelUpsWith))
		for _, w := range i.HasFuelUpsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFuelUpsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasFuelUpsWith(with...))
	}
	if i.HasOdometerReadings != nil {
		p := car.HasOdometerReadings()
		if !*i.HasOdometerReadings {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOdometerReadingsWith) > 0 {
		with := make([]predicate.OdometerReading, 0, len(i.HasOdometerReadingsWith))
		for _, w := range i.HasOdometerReadingsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOdometerReadingsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasOdometerReadingsWith(with...))
	}
	if i.HasServiceItems != nil {
		p := car.HasServiceItems()
		if !*i.HasServiceItems {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServiceItemsWith) > 0 {
		with := make([]predicate.ServiceItem, 0, len(i.HasServiceItemsWith))
		for _, w := range i.HasServiceItemsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServiceItemsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasServiceItemsWith(with...))
	}
	if i.HasServiceLogs != nil {
		p := car.HasServiceLogs()
		if !*i.HasServiceLogs {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServiceLogsWith) > 0 {
		with := make([]predicate.ServiceLog, 0, len(i.HasServiceLogsWith))
		for _, w := range i.HasServiceLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServiceLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasServiceLogsWith(with...))
	}
	if i.HasServiceSchedules != nil {
		p := car.HasServiceSchedules()
		if !*i.HasServiceSchedules {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServiceSchedulesWith) > 0 {
		with := make([]predicate.ServiceSchedule, 0, len(i.HasServiceSchedulesWith))
		for _, w := range i.HasServiceSchedulesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServiceSchedulesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasServiceSchedulesWith(with...))
	}
	if i.HasMedia != nil {
		p := car.HasMedia()
		if !*i.HasMedia {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMediaWith) > 0 {
		with := make([]predicate.Media, 0, len(i.HasMediaWith))
		for _, w := range i.HasMediaWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMediaWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasMediaWith(with...))
	}
	if i.HasAlbums != nil {
		p := car.HasAlbums()
		if !*i.HasAlbums {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAlbumsWith) > 0 {
		with := make([]predicate.Album, 0, len(i.HasAlbumsWith))
		for _, w := range i.HasAlbumsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAlbumsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasAlbumsWith(with...))
	}
	if i.HasDocuments != nil {
		p := car.HasDocuments()
		if !*i.HasDocuments {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDocumentsWith) > 0 {
		with := make([]predicate.Document, 0, len(i.HasDocumentsWith))
		for _, w := range i.HasDocumentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDocumentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasDocumentsWith(with...))
	}
	if i.HasDynoSessions != nil {
		p := car.HasDynoSessions()
		if !*i.HasDynoSessions {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDynoSessionsWith) > 0 {
		with := make([]predicate.DynoSession, 0, len(i.HasDynoSessionsWith))
		for _, w := range i.HasDynoSessionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDynoSessionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasDynoSessionsWith(with...))
	}
	if i.HasExpenses != nil {
		p := car.HasExpenses()
		if !*i.HasExpenses {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExpensesWith) > 0 {
		with := make([]predicate.Expense, 0, len(i.HasExpensesWith))
		for _, w := range i.HasExpensesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExpensesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasExpensesWith(with...))
	}
	if i.HasBuildLogs != nil {
		p := car.HasBuildLogs()
		if !*i.HasBuildLogs {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBuildLogsWith) > 0 {
		with := make([]predicate.BuildLog, 0, len(i.HasBuildLogsWith))
		for _, w := range i.HasBuildLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBuildLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasBuildLogsWith(with...))
	}
	if i.HasBannerImage != nil {
		p := car.HasBannerImage()
		if !*i.HasBannerImage {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBannerImageWith) > 0 {
		with := make([]predicate.Media, 0, len(i.HasBannerImageWith))
		for _, w := range i.HasBannerImageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBannerImageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasBannerImageWith(with...))
	}
	if i.HasTasks != nil {
		p := car.HasTasks()
		if !*i.HasTasks {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasTasksWith(with...))
	}
	if i.HasMods != nil {
		p := car.HasMods()
		if !*i.HasMods {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasModsWith) > 0 {
		with := make([]predicate.Mod, 0, len(i.HasModsWith))
		for _, w := range i.HasModsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasModsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasModsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarWhereInput
	case 1:
		return predicates[0], nil
	default:
		return car.And(predicates...), nil
	}
}

// CheckoutSessionWhereInput represents a where input for filtering CheckoutSession queries.
type CheckoutSessionWhereInput struct {
	Predicates []predicate.CheckoutSession  `json:"-"`
	Not        *CheckoutSessionWhereInput   `json:"not,omitempty"`
	Or         []*CheckoutSessionWhereInput `json:"or,omitempty"`
	And        []*CheckoutSessionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "stripe_session_id" field predicates.
	StripeSessionID             *string  `json:"stripeSessionID,omitempty"`
	StripeSessionIDNEQ          *string  `json:"stripeSessionIDNEQ,omitempty"`
	StripeSessionIDIn           []string `json:"stripeSessionIDIn,omitempty"`
	StripeSessionIDNotIn        []string `json:"stripeSessionIDNotIn,omitempty"`
	StripeSessionIDGT           *string  `json:"stripeSessionIDGT,omitempty"`
	StripeSessionIDGTE          *string  `json:"stripeSessionIDGTE,omitempty"`
	StripeSessionIDLT           *string  `json:"stripeSessionIDLT,omitempty"`
	StripeSessionIDLTE          *string  `json:"stripeSessionIDLTE,omitempty"`
	StripeSessionIDContains     *string  `json:"stripeSessionIDContains,omitempty"`
	StripeSessionIDHasPrefix    *string  `json:"stripeSessionIDHasPrefix,omitempty"`
	StripeSessionIDHasSuffix    *string  `json:"stripeSessionIDHasSuffix,omitempty"`
	StripeSessionIDIsNil        bool     `json:"stripeSessionIDIsNil,omitempty"`
	StripeSessionIDNotNil       bool     `json:"stripeSessionIDNotNil,omitempty"`
	StripeSessionIDEqualFold    *string  `json:"stripeSessionIDEqualFold,omitempty"`
	StripeSessionIDContainsFold *string  `json:"stripeSessionIDContainsFold,omitempty"`

	// "stripe_price_id" field predicates.
	StripePriceID             *string  `json:"stripePriceID,omitempty"`
	StripePriceIDNEQ          *string  `json:"stripePriceIDNEQ,omitempty"`
	StripePriceIDIn           []string `json:"stripePriceIDIn,omitempty"`
	StripePriceIDNotIn        []string `json:"stripePriceIDNotIn,omitempty"`
	StripePriceIDGT           *string  `json:"stripePriceIDGT,omitempty"`
	StripePriceIDGTE          *string  `json:"stripePriceIDGTE,omitempty"`
	StripePriceIDLT           *string  `json:"stripePriceIDLT,omitempty"`
	StripePriceIDLTE          *string  `json:"stripePriceIDLTE,omitempty"`
	StripePriceIDContains     *string  `json:"stripePriceIDContains,omitempty"`
	StripePriceIDHasPrefix    *string  `json:"stripePriceIDHasPrefix,omitempty"`
	StripePriceIDHasSuffix    *string  `json:"stripePriceIDHasSuffix,omitempty"`
	StripePriceIDEqualFold    *string  `json:"stripePriceIDEqualFold,omitempty"`
	StripePriceIDContainsFold *string  `json:"stripePriceIDContainsFold,omitempty"`

	// "mode" field predicates.
	Mode      *checkoutsession.Mode  `json:"mode,omitempty"`
	ModeNEQ   *checkoutsession.Mode  `json:"modeNEQ,omitempty"`
	ModeIn    []checkoutsession.Mode `json:"modeIn,omitempty"`
	ModeNotIn []checkoutsession.Mode `json:"modeNotIn,omitempty"`

	// "completed" field predicates.
	Completed    *bool `json:"completed,omitempty"`
	CompletedNEQ *bool `json:"completedNEQ,omitempty"`

	// "completed_at" field predicates.
	CompletedAt       *time.Time  `json:"completedAt,omitempty"`
	CompletedAtNEQ    *time.Time  `json:"completedAtNEQ,omitempty"`
	CompletedAtIn     []time.Time `json:"completedAtIn,omitempty"`
	CompletedAtNotIn  []time.Time `json:"completedAtNotIn,omitempty"`
	CompletedAtGT     *time.Time  `json:"completedAtGT,omitempty"`
	CompletedAtGTE    *time.Time  `json:"completedAtGTE,omitempty"`
	CompletedAtLT     *time.Time  `json:"completedAtLT,omitempty"`
	CompletedAtLTE    *time.Time  `json:"completedAtLTE,omitempty"`
	CompletedAtIsNil  bool        `json:"completedAtIsNil,omitempty"`
	CompletedAtNotNil bool        `json:"completedAtNotNil,omitempty"`

	// "affiliate_6mo_code" field predicates.
	Affiliate6moCode             *string  `json:"affiliate6moCode,omitempty"`
	Affiliate6moCodeNEQ          *string  `json:"affiliate6moCodeNEQ,omitempty"`
	Affiliate6moCodeIn           []string `json:"affiliate6moCodeIn,omitempty"`
	Affiliate6moCodeNotIn        []string `json:"affiliate6moCodeNotIn,omitempty"`
	Affiliate6moCodeGT           *string  `json:"affiliate6moCodeGT,omitempty"`
	Affiliate6moCodeGTE          *string  `json:"affiliate6moCodeGTE,omitempty"`
	Affiliate6moCodeLT           *string  `json:"affiliate6moCodeLT,omitempty"`
	Affiliate6moCodeLTE          *string  `json:"affiliate6moCodeLTE,omitempty"`
	Affiliate6moCodeContains     *string  `json:"affiliate6moCodeContains,omitempty"`
	Affiliate6moCodeHasPrefix    *string  `json:"affiliate6moCodeHasPrefix,omitempty"`
	Affiliate6moCodeHasSuffix    *string  `json:"affiliate6moCodeHasSuffix,omitempty"`
	Affiliate6moCodeIsNil        bool     `json:"affiliate6moCodeIsNil,omitempty"`
	Affiliate6moCodeNotNil       bool     `json:"affiliate6moCodeNotNil,omitempty"`
	Affiliate6moCodeEqualFold    *string  `json:"affiliate6moCodeEqualFold,omitempty"`
	Affiliate6moCodeContainsFold *string  `json:"affiliate6moCodeContainsFold,omitempty"`

	// "affiliate_12mo_code" field predicates.
	Affiliate12moCode             *string  `json:"affiliate12moCode,omitempty"`
	Affiliate12moCodeNEQ          *string  `json:"affiliate12moCodeNEQ,omitempty"`
	Affiliate12moCodeIn           []string `json:"affiliate12moCodeIn,omitempty"`
	Affiliate12moCodeNotIn        []string `json:"affiliate12moCodeNotIn,omitempty"`
	Affiliate12moCodeGT           *string  `json:"affiliate12moCodeGT,omitempty"`
	Affiliate12moCodeGTE          *string  `json:"affiliate12moCodeGTE,omitempty"`
	Affiliate12moCodeLT           *string  `json:"affiliate12moCodeLT,omitempty"`
	Affiliate12moCodeLTE          *string  `json:"affiliate12moCodeLTE,omitempty"`
	Affiliate12moCodeContains     *string  `json:"affiliate12moCodeContains,omitempty"`
	Affiliate12moCodeHasPrefix    *string  `json:"affiliate12moCodeHasPrefix,omitempty"`
	Affiliate12moCodeHasSuffix    *string  `json:"affiliate12moCodeHasSuffix,omitempty"`
	Affiliate12moCodeIsNil        bool     `json:"affiliate12moCodeIsNil,omitempty"`
	Affiliate12moCodeNotNil       bool     `json:"affiliate12moCodeNotNil,omitempty"`
	Affiliate12moCodeEqualFold    *string  `json:"affiliate12moCodeEqualFold,omitempty"`
	Affiliate12moCodeContainsFold *string  `json:"affiliate12moCodeContainsFold,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "subscription" edge predicates.
	HasSubscription     *bool                         `json:"hasSubscription,omitempty"`
	HasSubscriptionWith []*SubscriptionPlanWhereInput `json:"hasSubscriptionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CheckoutSessionWhereInput) AddPredicates(predicates ...predicate.CheckoutSession) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CheckoutSessionWhereInput filter on the CheckoutSessionQuery builder.
func (i *CheckoutSessionWhereInput) Filter(q *CheckoutSessionQuery) (*CheckoutSessionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCheckoutSessionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCheckoutSessionWhereInput is returned in case the CheckoutSessionWhereInput is empty.
var ErrEmptyCheckoutSessionWhereInput = errors.New("ent: empty predicate CheckoutSessionWhereInput")

// P returns a predicate for filtering checkoutsessions.
// An error is returned if the input is empty or invalid.
func (i *CheckoutSessionWhereInput) P() (predicate.CheckoutSession, error) {
	var predicates []predicate.CheckoutSession
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, checkoutsession.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CheckoutSession, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, checkoutsession.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CheckoutSession, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, checkoutsession.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, checkoutsession.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, checkoutsession.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, checkoutsession.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, checkoutsession.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, checkoutsession.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, checkoutsession.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, checkoutsession.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, checkoutsession.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, checkoutsession.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, checkoutsession.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, checkoutsession.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, checkoutsession.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, checkoutsession.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, checkoutsession.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, checkoutsession.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, checkoutsession.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, checkoutsession.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, checkoutsession.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, checkoutsession.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, checkoutsession.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, checkoutsession.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, checkoutsession.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, checkoutsession.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, checkoutsession.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.StripeSessionID != nil {
		predicates = append(predicates, checkoutsession.StripeSessionIDEQ(*i.StripeSessionID))
	}
	if i.StripeSessionIDNEQ != nil {
		predicates = append(predicates, checkoutsession.StripeSessionIDNEQ(*i.StripeSessionIDNEQ))
	}
	if len(i.StripeSessionIDIn) > 0 {
		predicates = append(predicates, checkoutsession.StripeSessionIDIn(i.StripeSessionIDIn...))
	}
	if len(i.StripeSessionIDNotIn) > 0 {
		predicates = append(predicates, checkoutsession.StripeSessionIDNotIn(i.StripeSessionIDNotIn...))
	}
	if i.StripeSessionIDGT != nil {
		predicates = append(predicates, checkoutsession.StripeSessionIDGT(*i.StripeSessionIDGT))
	}
	if i.StripeSessionIDGTE != nil {
		predicates = append(predicates, checkoutsession.StripeSessionIDGTE(*i.StripeSessionIDGTE))
	}
	if i.StripeSessionIDLT != nil {
		predicates = append(predicates, checkoutsession.StripeSessionIDLT(*i.StripeSessionIDLT))
	}
	if i.StripeSessionIDLTE != nil {
		predicates = append(predicates, checkoutsession.StripeSessionIDLTE(*i.StripeSessionIDLTE))
	}
	if i.StripeSessionIDContains != nil {
		predicates = append(predicates, checkoutsession.StripeSessionIDContains(*i.StripeSessionIDContains))
	}
	if i.StripeSessionIDHasPrefix != nil {
		predicates = append(predicates, checkoutsession.StripeSessionIDHasPrefix(*i.StripeSessionIDHasPrefix))
	}
	if i.StripeSessionIDHasSuffix != nil {
		predicates = append(predicates, checkoutsession.StripeSessionIDHasSuffix(*i.StripeSessionIDHasSuffix))
	}
	if i.StripeSessionIDIsNil {
		predicates = append(predicates, checkoutsession.StripeSessionIDIsNil())
	}
	if i.StripeSessionIDNotNil {
		predicates = append(predicates, checkoutsession.StripeSessionIDNotNil())
	}
	if i.StripeSessionIDEqualFold != nil {
		predicates = append(predicates, checkoutsession.StripeSessionIDEqualFold(*i.StripeSessionIDEqualFold))
	}
	if i.StripeSessionIDContainsFold != nil {
		predicates = append(predicates, checkoutsession.StripeSessionIDContainsFold(*i.StripeSessionIDContainsFold))
	}
	if i.StripePriceID != nil {
		predicates = append(predicates, checkoutsession.StripePriceIDEQ(*i.StripePriceID))
	}
	if i.StripePriceIDNEQ != nil {
		predicates = append(predicates, checkoutsession.StripePriceIDNEQ(*i.StripePriceIDNEQ))
	}
	if len(i.StripePriceIDIn) > 0 {
		predicates = append(predicates, checkoutsession.StripePriceIDIn(i.StripePriceIDIn...))
	}
	if len(i.StripePriceIDNotIn) > 0 {
		predicates = append(predicates, checkoutsession.StripePriceIDNotIn(i.StripePriceIDNotIn...))
	}
	if i.StripePriceIDGT != nil {
		predicates = append(predicates, checkoutsession.StripePriceIDGT(*i.StripePriceIDGT))
	}
	if i.StripePriceIDGTE != nil {
		predicates = append(predicates, checkoutsession.StripePriceIDGTE(*i.StripePriceIDGTE))
	}
	if i.StripePriceIDLT != nil {
		predicates = append(predicates, checkoutsession.StripePriceIDLT(*i.StripePriceIDLT))
	}
	if i.StripePriceIDLTE != nil {
		predicates = append(predicates, checkoutsession.StripePriceIDLTE(*i.StripePriceIDLTE))
	}
	if i.StripePriceIDContains != nil {
		predicates = append(predicates, checkoutsession.StripePriceIDContains(*i.StripePriceIDContains))
	}
	if i.StripePriceIDHasPrefix != nil {
		predicates = append(predicates, checkoutsession.StripePriceIDHasPrefix(*i.StripePriceIDHasPrefix))
	}
	if i.StripePriceIDHasSuffix != nil {
		predicates = append(predicates, checkoutsession.StripePriceIDHasSuffix(*i.StripePriceIDHasSuffix))
	}
	if i.StripePriceIDEqualFold != nil {
		predicates = append(predicates, checkoutsession.StripePriceIDEqualFold(*i.StripePriceIDEqualFold))
	}
	if i.StripePriceIDContainsFold != nil {
		predicates = append(predicates, checkoutsession.StripePriceIDContainsFold(*i.StripePriceIDContainsFold))
	}
	if i.Mode != nil {
		predicates = append(predicates, checkoutsession.ModeEQ(*i.Mode))
	}
	if i.ModeNEQ != nil {
		predicates = append(predicates, checkoutsession.ModeNEQ(*i.ModeNEQ))
	}
	if len(i.ModeIn) > 0 {
		predicates = append(predicates, checkoutsession.ModeIn(i.ModeIn...))
	}
	if len(i.ModeNotIn) > 0 {
		predicates = append(predicates, checkoutsession.ModeNotIn(i.ModeNotIn...))
	}
	if i.Completed != nil {
		predicates = append(predicates, checkoutsession.CompletedEQ(*i.Completed))
	}
	if i.CompletedNEQ != nil {
		predicates = append(predicates, checkoutsession.CompletedNEQ(*i.CompletedNEQ))
	}
	if i.CompletedAt != nil {
		predicates = append(predicates, checkoutsession.CompletedAtEQ(*i.CompletedAt))
	}
	if i.CompletedAtNEQ != nil {
		predicates = append(predicates, checkoutsession.CompletedAtNEQ(*i.CompletedAtNEQ))
	}
	if len(i.CompletedAtIn) > 0 {
		predicates = append(predicates, checkoutsession.CompletedAtIn(i.CompletedAtIn...))
	}
	if len(i.CompletedAtNotIn) > 0 {
		predicates = append(predicates, checkoutsession.CompletedAtNotIn(i.CompletedAtNotIn...))
	}
	if i.CompletedAtGT != nil {
		predicates = append(predicates, checkoutsession.CompletedAtGT(*i.CompletedAtGT))
	}
	if i.CompletedAtGTE != nil {
		predicates = append(predicates, checkoutsession.CompletedAtGTE(*i.CompletedAtGTE))
	}
	if i.CompletedAtLT != nil {
		predicates = append(predicates, checkoutsession.CompletedAtLT(*i.CompletedAtLT))
	}
	if i.CompletedAtLTE != nil {
		predicates = append(predicates, checkoutsession.CompletedAtLTE(*i.CompletedAtLTE))
	}
	if i.CompletedAtIsNil {
		predicates = append(predicates, checkoutsession.CompletedAtIsNil())
	}
	if i.CompletedAtNotNil {
		predicates = append(predicates, checkoutsession.CompletedAtNotNil())
	}
	if i.Affiliate6moCode != nil {
		predicates = append(predicates, checkoutsession.Affiliate6moCodeEQ(*i.Affiliate6moCode))
	}
	if i.Affiliate6moCodeNEQ != nil {
		predicates = append(predicates, checkoutsession.Affiliate6moCodeNEQ(*i.Affiliate6moCodeNEQ))
	}
	if len(i.Affiliate6moCodeIn) > 0 {
		predicates = append(predicates, checkoutsession.Affiliate6moCodeIn(i.Affiliate6moCodeIn...))
	}
	if len(i.Affiliate6moCodeNotIn) > 0 {
		predicates = append(predicates, checkoutsession.Affiliate6moCodeNotIn(i.Affiliate6moCodeNotIn...))
	}
	if i.Affiliate6moCodeGT != nil {
		predicates = append(predicates, checkoutsession.Affiliate6moCodeGT(*i.Affiliate6moCodeGT))
	}
	if i.Affiliate6moCodeGTE != nil {
		predicates = append(predicates, checkoutsession.Affiliate6moCodeGTE(*i.Affiliate6moCodeGTE))
	}
	if i.Affiliate6moCodeLT != nil {
		predicates = append(predicates, checkoutsession.Affiliate6moCodeLT(*i.Affiliate6moCodeLT))
	}
	if i.Affiliate6moCodeLTE != nil {
		predicates = append(predicates, checkoutsession.Affiliate6moCodeLTE(*i.Affiliate6moCodeLTE))
	}
	if i.Affiliate6moCodeContains != nil {
		predicates = append(predicates, checkoutsession.Affiliate6moCodeContains(*i.Affiliate6moCodeContains))
	}
	if i.Affiliate6moCodeHasPrefix != nil {
		predicates = append(predicates, checkoutsession.Affiliate6moCodeHasPrefix(*i.Affiliate6moCodeHasPrefix))
	}
	if i.Affiliate6moCodeHasSuffix != nil {
		predicates = append(predicates, checkoutsession.Affiliate6moCodeHasSuffix(*i.Affiliate6moCodeHasSuffix))
	}
	if i.Affiliate6moCodeIsNil {
		predicates = append(predicates, checkoutsession.Affiliate6moCodeIsNil())
	}
	if i.Affiliate6moCodeNotNil {
		predicates = append(predicates, checkoutsession.Affiliate6moCodeNotNil())
	}
	if i.Affiliate6moCodeEqualFold != nil {
		predicates = append(predicates, checkoutsession.Affiliate6moCodeEqualFold(*i.Affiliate6moCodeEqualFold))
	}
	if i.Affiliate6moCodeContainsFold != nil {
		predicates = append(predicates, checkoutsession.Affiliate6moCodeContainsFold(*i.Affiliate6moCodeContainsFold))
	}
	if i.Affiliate12moCode != nil {
		predicates = append(predicates, checkoutsession.Affiliate12moCodeEQ(*i.Affiliate12moCode))
	}
	if i.Affiliate12moCodeNEQ != nil {
		predicates = append(predicates, checkoutsession.Affiliate12moCodeNEQ(*i.Affiliate12moCodeNEQ))
	}
	if len(i.Affiliate12moCodeIn) > 0 {
		predicates = append(predicates, checkoutsession.Affiliate12moCodeIn(i.Affiliate12moCodeIn...))
	}
	if len(i.Affiliate12moCodeNotIn) > 0 {
		predicates = append(predicates, checkoutsession.Affiliate12moCodeNotIn(i.Affiliate12moCodeNotIn...))
	}
	if i.Affiliate12moCodeGT != nil {
		predicates = append(predicates, checkoutsession.Affiliate12moCodeGT(*i.Affiliate12moCodeGT))
	}
	if i.Affiliate12moCodeGTE != nil {
		predicates = append(predicates, checkoutsession.Affiliate12moCodeGTE(*i.Affiliate12moCodeGTE))
	}
	if i.Affiliate12moCodeLT != nil {
		predicates = append(predicates, checkoutsession.Affiliate12moCodeLT(*i.Affiliate12moCodeLT))
	}
	if i.Affiliate12moCodeLTE != nil {
		predicates = append(predicates, checkoutsession.Affiliate12moCodeLTE(*i.Affiliate12moCodeLTE))
	}
	if i.Affiliate12moCodeContains != nil {
		predicates = append(predicates, checkoutsession.Affiliate12moCodeContains(*i.Affiliate12moCodeContains))
	}
	if i.Affiliate12moCodeHasPrefix != nil {
		predicates = append(predicates, checkoutsession.Affiliate12moCodeHasPrefix(*i.Affiliate12moCodeHasPrefix))
	}
	if i.Affiliate12moCodeHasSuffix != nil {
		predicates = append(predicates, checkoutsession.Affiliate12moCodeHasSuffix(*i.Affiliate12moCodeHasSuffix))
	}
	if i.Affiliate12moCodeIsNil {
		predicates = append(predicates, checkoutsession.Affiliate12moCodeIsNil())
	}
	if i.Affiliate12moCodeNotNil {
		predicates = append(predicates, checkoutsession.Affiliate12moCodeNotNil())
	}
	if i.Affiliate12moCodeEqualFold != nil {
		predicates = append(predicates, checkoutsession.Affiliate12moCodeEqualFold(*i.Affiliate12moCodeEqualFold))
	}
	if i.Affiliate12moCodeContainsFold != nil {
		predicates = append(predicates, checkoutsession.Affiliate12moCodeContainsFold(*i.Affiliate12moCodeContainsFold))
	}

	if i.HasUser != nil {
		p := checkoutsession.HasUser()
		if !*i.HasUser {
			p = checkoutsession.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, checkoutsession.HasUserWith(with...))
	}
	if i.HasSubscription != nil {
		p := checkoutsession.HasSubscription()
		if !*i.HasSubscription {
			p = checkoutsession.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubscriptionWith) > 0 {
		with := make([]predicate.Subscription, 0, len(i.HasSubscriptionWith))
		for _, w := range i.HasSubscriptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubscriptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, checkoutsession.HasSubscriptionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCheckoutSessionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return checkoutsession.And(predicates...), nil
	}
}

// DocumentWhereInput represents a where input for filtering Document queries.
type DocumentWhereInput struct {
	Predicates []predicate.Document  `json:"-"`
	Not        *DocumentWhereInput   `json:"not,omitempty"`
	Or         []*DocumentWhereInput `json:"or,omitempty"`
	And        []*DocumentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "expense" edge predicates.
	HasExpense     *bool                `json:"hasExpense,omitempty"`
	HasExpenseWith []*ExpenseWhereInput `json:"hasExpenseWith,omitempty"`

	// "fuel_up" edge predicates.
	HasFuelUp     *bool               `json:"hasFuelUp,omitempty"`
	HasFuelUpWith []*FuelUpWhereInput `json:"hasFuelUpWith,omitempty"`

	// "service_log" edge predicates.
	HasServiceLog     *bool                   `json:"hasServiceLog,omitempty"`
	HasServiceLogWith []*ServiceLogWhereInput `json:"hasServiceLogWith,omitempty"`

	// "drag_session" edge predicates.
	HasDragSession     *bool                    `json:"hasDragSession,omitempty"`
	HasDragSessionWith []*DragSessionWhereInput `json:"hasDragSessionWith,omitempty"`

	// "dyno_session" edge predicates.
	HasDynoSession     *bool                    `json:"hasDynoSession,omitempty"`
	HasDynoSessionWith []*DynoSessionWhereInput `json:"hasDynoSessionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DocumentWhereInput) AddPredicates(predicates ...predicate.Document) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DocumentWhereInput filter on the DocumentQuery builder.
func (i *DocumentWhereInput) Filter(q *DocumentQuery) (*DocumentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDocumentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDocumentWhereInput is returned in case the DocumentWhereInput is empty.
var ErrEmptyDocumentWhereInput = errors.New("ent: empty predicate DocumentWhereInput")

// P returns a predicate for filtering documents.
// An error is returned if the input is empty or invalid.
func (i *DocumentWhereInput) P() (predicate.Document, error) {
	var predicates []predicate.Document
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, document.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Document, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, document.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Document, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, document.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, document.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, document.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, document.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, document.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, document.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, document.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, document.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, document.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, document.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, document.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, document.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, document.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, document.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, document.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, document.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, document.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, document.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, document.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, document.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, document.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, document.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, document.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, document.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, document.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, document.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, document.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, document.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, document.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, document.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, document.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, document.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, document.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, document.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, document.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, document.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, document.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, document.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasCar != nil {
		p := document.HasCar()
		if !*i.HasCar {
			p = document.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, document.HasCarWith(with...))
	}
	if i.HasExpense != nil {
		p := document.HasExpense()
		if !*i.HasExpense {
			p = document.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExpenseWith) > 0 {
		with := make([]predicate.Expense, 0, len(i.HasExpenseWith))
		for _, w := range i.HasExpenseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExpenseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, document.HasExpenseWith(with...))
	}
	if i.HasFuelUp != nil {
		p := document.HasFuelUp()
		if !*i.HasFuelUp {
			p = document.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFuelUpWith) > 0 {
		with := make([]predicate.FuelUp, 0, len(i.HasFuelUpWith))
		for _, w := range i.HasFuelUpWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFuelUpWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, document.HasFuelUpWith(with...))
	}
	if i.HasServiceLog != nil {
		p := document.HasServiceLog()
		if !*i.HasServiceLog {
			p = document.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServiceLogWith) > 0 {
		with := make([]predicate.ServiceLog, 0, len(i.HasServiceLogWith))
		for _, w := range i.HasServiceLogWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServiceLogWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, document.HasServiceLogWith(with...))
	}
	if i.HasDragSession != nil {
		p := document.HasDragSession()
		if !*i.HasDragSession {
			p = document.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDragSessionWith) > 0 {
		with := make([]predicate.DragSession, 0, len(i.HasDragSessionWith))
		for _, w := range i.HasDragSessionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDragSessionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, document.HasDragSessionWith(with...))
	}
	if i.HasDynoSession != nil {
		p := document.HasDynoSession()
		if !*i.HasDynoSession {
			p = document.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDynoSessionWith) > 0 {
		with := make([]predicate.DynoSession, 0, len(i.HasDynoSessionWith))
		for _, w := range i.HasDynoSessionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDynoSessionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, document.HasDynoSessionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDocumentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return document.And(predicates...), nil
	}
}

// DragResultWhereInput represents a where input for filtering DragResult queries.
type DragResultWhereInput struct {
	Predicates []predicate.DragResult  `json:"-"`
	Not        *DragResultWhereInput   `json:"not,omitempty"`
	Or         []*DragResultWhereInput `json:"or,omitempty"`
	And        []*DragResultWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "unit" field predicates.
	Unit      *dragresult.Unit  `json:"unit,omitempty"`
	UnitNEQ   *dragresult.Unit  `json:"unitNEQ,omitempty"`
	UnitIn    []dragresult.Unit `json:"unitIn,omitempty"`
	UnitNotIn []dragresult.Unit `json:"unitNotIn,omitempty"`

	// "value" field predicates.
	Value      *float64  `json:"value,omitempty"`
	ValueNEQ   *float64  `json:"valueNEQ,omitempty"`
	ValueIn    []float64 `json:"valueIn,omitempty"`
	ValueNotIn []float64 `json:"valueNotIn,omitempty"`
	ValueGT    *float64  `json:"valueGT,omitempty"`
	ValueGTE   *float64  `json:"valueGTE,omitempty"`
	ValueLT    *float64  `json:"valueLT,omitempty"`
	ValueLTE   *float64  `json:"valueLTE,omitempty"`

	// "result" field predicates.
	Result      *float64  `json:"result,omitempty"`
	ResultNEQ   *float64  `json:"resultNEQ,omitempty"`
	ResultIn    []float64 `json:"resultIn,omitempty"`
	ResultNotIn []float64 `json:"resultNotIn,omitempty"`
	ResultGT    *float64  `json:"resultGT,omitempty"`
	ResultGTE   *float64  `json:"resultGTE,omitempty"`
	ResultLT    *float64  `json:"resultLT,omitempty"`
	ResultLTE   *float64  `json:"resultLTE,omitempty"`

	// "session" edge predicates.
	HasSession     *bool                    `json:"hasSession,omitempty"`
	HasSessionWith []*DragSessionWhereInput `json:"hasSessionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DragResultWhereInput) AddPredicates(predicates ...predicate.DragResult) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DragResultWhereInput filter on the DragResultQuery builder.
func (i *DragResultWhereInput) Filter(q *DragResultQuery) (*DragResultQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDragResultWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDragResultWhereInput is returned in case the DragResultWhereInput is empty.
var ErrEmptyDragResultWhereInput = errors.New("ent: empty predicate DragResultWhereInput")

// P returns a predicate for filtering dragresults.
// An error is returned if the input is empty or invalid.
func (i *DragResultWhereInput) P() (predicate.DragResult, error) {
	var predicates []predicate.DragResult
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, dragresult.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DragResult, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, dragresult.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DragResult, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, dragresult.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, dragresult.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, dragresult.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, dragresult.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, dragresult.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, dragresult.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, dragresult.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, dragresult.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, dragresult.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, dragresult.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, dragresult.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, dragresult.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, dragresult.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, dragresult.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, dragresult.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, dragresult.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, dragresult.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, dragresult.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, dragresult.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, dragresult.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, dragresult.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, dragresult.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, dragresult.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, dragresult.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, dragresult.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Unit != nil {
		predicates = append(predicates, dragresult.UnitEQ(*i.Unit))
	}
	if i.UnitNEQ != nil {
		predicates = append(predicates, dragresult.UnitNEQ(*i.UnitNEQ))
	}
	if len(i.UnitIn) > 0 {
		predicates = append(predicates, dragresult.UnitIn(i.UnitIn...))
	}
	if len(i.UnitNotIn) > 0 {
		predicates = append(predicates, dragresult.UnitNotIn(i.UnitNotIn...))
	}
	if i.Value != nil {
		predicates = append(predicates, dragresult.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, dragresult.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, dragresult.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, dragresult.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, dragresult.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, dragresult.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, dragresult.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, dragresult.ValueLTE(*i.ValueLTE))
	}
	if i.Result != nil {
		predicates = append(predicates, dragresult.ResultEQ(*i.Result))
	}
	if i.ResultNEQ != nil {
		predicates = append(predicates, dragresult.ResultNEQ(*i.ResultNEQ))
	}
	if len(i.ResultIn) > 0 {
		predicates = append(predicates, dragresult.ResultIn(i.ResultIn...))
	}
	if len(i.ResultNotIn) > 0 {
		predicates = append(predicates, dragresult.ResultNotIn(i.ResultNotIn...))
	}
	if i.ResultGT != nil {
		predicates = append(predicates, dragresult.ResultGT(*i.ResultGT))
	}
	if i.ResultGTE != nil {
		predicates = append(predicates, dragresult.ResultGTE(*i.ResultGTE))
	}
	if i.ResultLT != nil {
		predicates = append(predicates, dragresult.ResultLT(*i.ResultLT))
	}
	if i.ResultLTE != nil {
		predicates = append(predicates, dragresult.ResultLTE(*i.ResultLTE))
	}

	if i.HasSession != nil {
		p := dragresult.HasSession()
		if !*i.HasSession {
			p = dragresult.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSessionWith) > 0 {
		with := make([]predicate.DragSession, 0, len(i.HasSessionWith))
		for _, w := range i.HasSessionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSessionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dragresult.HasSessionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDragResultWhereInput
	case 1:
		return predicates[0], nil
	default:
		return dragresult.And(predicates...), nil
	}
}

// DragSessionWhereInput represents a where input for filtering DragSession queries.
type DragSessionWhereInput struct {
	Predicates []predicate.DragSession  `json:"-"`
	Not        *DragSessionWhereInput   `json:"not,omitempty"`
	Or         []*DragSessionWhereInput `json:"or,omitempty"`
	And        []*DragSessionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "results" edge predicates.
	HasResults     *bool                   `json:"hasResults,omitempty"`
	HasResultsWith []*DragResultWhereInput `json:"hasResultsWith,omitempty"`

	// "documents" edge predicates.
	HasDocuments     *bool                 `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentWhereInput `json:"hasDocumentsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DragSessionWhereInput) AddPredicates(predicates ...predicate.DragSession) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DragSessionWhereInput filter on the DragSessionQuery builder.
func (i *DragSessionWhereInput) Filter(q *DragSessionQuery) (*DragSessionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDragSessionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDragSessionWhereInput is returned in case the DragSessionWhereInput is empty.
var ErrEmptyDragSessionWhereInput = errors.New("ent: empty predicate DragSessionWhereInput")

// P returns a predicate for filtering dragsessions.
// An error is returned if the input is empty or invalid.
func (i *DragSessionWhereInput) P() (predicate.DragSession, error) {
	var predicates []predicate.DragSession
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, dragsession.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DragSession, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, dragsession.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DragSession, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, dragsession.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, dragsession.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, dragsession.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, dragsession.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, dragsession.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, dragsession.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, dragsession.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, dragsession.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, dragsession.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, dragsession.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, dragsession.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, dragsession.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, dragsession.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, dragsession.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, dragsession.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, dragsession.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, dragsession.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, dragsession.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, dragsession.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, dragsession.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, dragsession.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, dragsession.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, dragsession.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, dragsession.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, dragsession.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, dragsession.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, dragsession.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, dragsession.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, dragsession.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, dragsession.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, dragsession.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, dragsession.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, dragsession.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, dragsession.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, dragsession.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, dragsession.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, dragsession.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, dragsession.TitleContainsFold(*i.TitleContainsFold))
	}

	if i.HasCar != nil {
		p := dragsession.HasCar()
		if !*i.HasCar {
			p = dragsession.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dragsession.HasCarWith(with...))
	}
	if i.HasResults != nil {
		p := dragsession.HasResults()
		if !*i.HasResults {
			p = dragsession.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasResultsWith) > 0 {
		with := make([]predicate.DragResult, 0, len(i.HasResultsWith))
		for _, w := range i.HasResultsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasResultsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dragsession.HasResultsWith(with...))
	}
	if i.HasDocuments != nil {
		p := dragsession.HasDocuments()
		if !*i.HasDocuments {
			p = dragsession.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDocumentsWith) > 0 {
		with := make([]predicate.Document, 0, len(i.HasDocumentsWith))
		for _, w := range i.HasDocumentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDocumentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dragsession.HasDocumentsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDragSessionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return dragsession.And(predicates...), nil
	}
}

// DynoResultWhereInput represents a where input for filtering DynoResult queries.
type DynoResultWhereInput struct {
	Predicates []predicate.DynoResult  `json:"-"`
	Not        *DynoResultWhereInput   `json:"not,omitempty"`
	Or         []*DynoResultWhereInput `json:"or,omitempty"`
	And        []*DynoResultWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "rpm" field predicates.
	Rpm      *int  `json:"rpm,omitempty"`
	RpmNEQ   *int  `json:"rpmNEQ,omitempty"`
	RpmIn    []int `json:"rpmIn,omitempty"`
	RpmNotIn []int `json:"rpmNotIn,omitempty"`
	RpmGT    *int  `json:"rpmGT,omitempty"`
	RpmGTE   *int  `json:"rpmGTE,omitempty"`
	RpmLT    *int  `json:"rpmLT,omitempty"`
	RpmLTE   *int  `json:"rpmLTE,omitempty"`

	// "power_kw" field predicates.
	PowerKw       *float64  `json:"powerKw,omitempty"`
	PowerKwNEQ    *float64  `json:"powerKwNEQ,omitempty"`
	PowerKwIn     []float64 `json:"powerKwIn,omitempty"`
	PowerKwNotIn  []float64 `json:"powerKwNotIn,omitempty"`
	PowerKwGT     *float64  `json:"powerKwGT,omitempty"`
	PowerKwGTE    *float64  `json:"powerKwGTE,omitempty"`
	PowerKwLT     *float64  `json:"powerKwLT,omitempty"`
	PowerKwLTE    *float64  `json:"powerKwLTE,omitempty"`
	PowerKwIsNil  bool      `json:"powerKwIsNil,omitempty"`
	PowerKwNotNil bool      `json:"powerKwNotNil,omitempty"`

	// "torque_nm" field predicates.
	TorqueNm       *float64  `json:"torqueNm,omitempty"`
	TorqueNmNEQ    *float64  `json:"torqueNmNEQ,omitempty"`
	TorqueNmIn     []float64 `json:"torqueNmIn,omitempty"`
	TorqueNmNotIn  []float64 `json:"torqueNmNotIn,omitempty"`
	TorqueNmGT     *float64  `json:"torqueNmGT,omitempty"`
	TorqueNmGTE    *float64  `json:"torqueNmGTE,omitempty"`
	TorqueNmLT     *float64  `json:"torqueNmLT,omitempty"`
	TorqueNmLTE    *float64  `json:"torqueNmLTE,omitempty"`
	TorqueNmIsNil  bool      `json:"torqueNmIsNil,omitempty"`
	TorqueNmNotNil bool      `json:"torqueNmNotNil,omitempty"`

	// "session" edge predicates.
	HasSession     *bool                    `json:"hasSession,omitempty"`
	HasSessionWith []*DynoSessionWhereInput `json:"hasSessionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DynoResultWhereInput) AddPredicates(predicates ...predicate.DynoResult) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DynoResultWhereInput filter on the DynoResultQuery builder.
func (i *DynoResultWhereInput) Filter(q *DynoResultQuery) (*DynoResultQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDynoResultWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDynoResultWhereInput is returned in case the DynoResultWhereInput is empty.
var ErrEmptyDynoResultWhereInput = errors.New("ent: empty predicate DynoResultWhereInput")

// P returns a predicate for filtering dynoresults.
// An error is returned if the input is empty or invalid.
func (i *DynoResultWhereInput) P() (predicate.DynoResult, error) {
	var predicates []predicate.DynoResult
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, dynoresult.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DynoResult, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, dynoresult.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DynoResult, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, dynoresult.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, dynoresult.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, dynoresult.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, dynoresult.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, dynoresult.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, dynoresult.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, dynoresult.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, dynoresult.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, dynoresult.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, dynoresult.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, dynoresult.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, dynoresult.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, dynoresult.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, dynoresult.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, dynoresult.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, dynoresult.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, dynoresult.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, dynoresult.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, dynoresult.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, dynoresult.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, dynoresult.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, dynoresult.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, dynoresult.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, dynoresult.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, dynoresult.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Rpm != nil {
		predicates = append(predicates, dynoresult.RpmEQ(*i.Rpm))
	}
	if i.RpmNEQ != nil {
		predicates = append(predicates, dynoresult.RpmNEQ(*i.RpmNEQ))
	}
	if len(i.RpmIn) > 0 {
		predicates = append(predicates, dynoresult.RpmIn(i.RpmIn...))
	}
	if len(i.RpmNotIn) > 0 {
		predicates = append(predicates, dynoresult.RpmNotIn(i.RpmNotIn...))
	}
	if i.RpmGT != nil {
		predicates = append(predicates, dynoresult.RpmGT(*i.RpmGT))
	}
	if i.RpmGTE != nil {
		predicates = append(predicates, dynoresult.RpmGTE(*i.RpmGTE))
	}
	if i.RpmLT != nil {
		predicates = append(predicates, dynoresult.RpmLT(*i.RpmLT))
	}
	if i.RpmLTE != nil {
		predicates = append(predicates, dynoresult.RpmLTE(*i.RpmLTE))
	}
	if i.PowerKw != nil {
		predicates = append(predicates, dynoresult.PowerKwEQ(*i.PowerKw))
	}
	if i.PowerKwNEQ != nil {
		predicates = append(predicates, dynoresult.PowerKwNEQ(*i.PowerKwNEQ))
	}
	if len(i.PowerKwIn) > 0 {
		predicates = append(predicates, dynoresult.PowerKwIn(i.PowerKwIn...))
	}
	if len(i.PowerKwNotIn) > 0 {
		predicates = append(predicates, dynoresult.PowerKwNotIn(i.PowerKwNotIn...))
	}
	if i.PowerKwGT != nil {
		predicates = append(predicates, dynoresult.PowerKwGT(*i.PowerKwGT))
	}
	if i.PowerKwGTE != nil {
		predicates = append(predicates, dynoresult.PowerKwGTE(*i.PowerKwGTE))
	}
	if i.PowerKwLT != nil {
		predicates = append(predicates, dynoresult.PowerKwLT(*i.PowerKwLT))
	}
	if i.PowerKwLTE != nil {
		predicates = append(predicates, dynoresult.PowerKwLTE(*i.PowerKwLTE))
	}
	if i.PowerKwIsNil {
		predicates = append(predicates, dynoresult.PowerKwIsNil())
	}
	if i.PowerKwNotNil {
		predicates = append(predicates, dynoresult.PowerKwNotNil())
	}
	if i.TorqueNm != nil {
		predicates = append(predicates, dynoresult.TorqueNmEQ(*i.TorqueNm))
	}
	if i.TorqueNmNEQ != nil {
		predicates = append(predicates, dynoresult.TorqueNmNEQ(*i.TorqueNmNEQ))
	}
	if len(i.TorqueNmIn) > 0 {
		predicates = append(predicates, dynoresult.TorqueNmIn(i.TorqueNmIn...))
	}
	if len(i.TorqueNmNotIn) > 0 {
		predicates = append(predicates, dynoresult.TorqueNmNotIn(i.TorqueNmNotIn...))
	}
	if i.TorqueNmGT != nil {
		predicates = append(predicates, dynoresult.TorqueNmGT(*i.TorqueNmGT))
	}
	if i.TorqueNmGTE != nil {
		predicates = append(predicates, dynoresult.TorqueNmGTE(*i.TorqueNmGTE))
	}
	if i.TorqueNmLT != nil {
		predicates = append(predicates, dynoresult.TorqueNmLT(*i.TorqueNmLT))
	}
	if i.TorqueNmLTE != nil {
		predicates = append(predicates, dynoresult.TorqueNmLTE(*i.TorqueNmLTE))
	}
	if i.TorqueNmIsNil {
		predicates = append(predicates, dynoresult.TorqueNmIsNil())
	}
	if i.TorqueNmNotNil {
		predicates = append(predicates, dynoresult.TorqueNmNotNil())
	}

	if i.HasSession != nil {
		p := dynoresult.HasSession()
		if !*i.HasSession {
			p = dynoresult.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSessionWith) > 0 {
		with := make([]predicate.DynoSession, 0, len(i.HasSessionWith))
		for _, w := range i.HasSessionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSessionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dynoresult.HasSessionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDynoResultWhereInput
	case 1:
		return predicates[0], nil
	default:
		return dynoresult.And(predicates...), nil
	}
}

// DynoSessionWhereInput represents a where input for filtering DynoSession queries.
type DynoSessionWhereInput struct {
	Predicates []predicate.DynoSession  `json:"-"`
	Not        *DynoSessionWhereInput   `json:"not,omitempty"`
	Or         []*DynoSessionWhereInput `json:"or,omitempty"`
	And        []*DynoSessionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "results" edge predicates.
	HasResults     *bool                   `json:"hasResults,omitempty"`
	HasResultsWith []*DynoResultWhereInput `json:"hasResultsWith,omitempty"`

	// "documents" edge predicates.
	HasDocuments     *bool                 `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentWhereInput `json:"hasDocumentsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DynoSessionWhereInput) AddPredicates(predicates ...predicate.DynoSession) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DynoSessionWhereInput filter on the DynoSessionQuery builder.
func (i *DynoSessionWhereInput) Filter(q *DynoSessionQuery) (*DynoSessionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDynoSessionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDynoSessionWhereInput is returned in case the DynoSessionWhereInput is empty.
var ErrEmptyDynoSessionWhereInput = errors.New("ent: empty predicate DynoSessionWhereInput")

// P returns a predicate for filtering dynosessions.
// An error is returned if the input is empty or invalid.
func (i *DynoSessionWhereInput) P() (predicate.DynoSession, error) {
	var predicates []predicate.DynoSession
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, dynosession.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DynoSession, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, dynosession.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DynoSession, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, dynosession.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, dynosession.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, dynosession.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, dynosession.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, dynosession.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, dynosession.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, dynosession.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, dynosession.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, dynosession.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, dynosession.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, dynosession.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, dynosession.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, dynosession.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, dynosession.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, dynosession.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, dynosession.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, dynosession.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, dynosession.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, dynosession.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, dynosession.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, dynosession.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, dynosession.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, dynosession.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, dynosession.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, dynosession.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, dynosession.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, dynosession.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, dynosession.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, dynosession.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, dynosession.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, dynosession.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, dynosession.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, dynosession.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, dynosession.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, dynosession.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, dynosession.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, dynosession.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, dynosession.TitleContainsFold(*i.TitleContainsFold))
	}

	if i.HasCar != nil {
		p := dynosession.HasCar()
		if !*i.HasCar {
			p = dynosession.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dynosession.HasCarWith(with...))
	}
	if i.HasResults != nil {
		p := dynosession.HasResults()
		if !*i.HasResults {
			p = dynosession.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasResultsWith) > 0 {
		with := make([]predicate.DynoResult, 0, len(i.HasResultsWith))
		for _, w := range i.HasResultsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasResultsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dynosession.HasResultsWith(with...))
	}
	if i.HasDocuments != nil {
		p := dynosession.HasDocuments()
		if !*i.HasDocuments {
			p = dynosession.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDocumentsWith) > 0 {
		with := make([]predicate.Document, 0, len(i.HasDocumentsWith))
		for _, w := range i.HasDocumentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDocumentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dynosession.HasDocumentsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDynoSessionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return dynosession.And(predicates...), nil
	}
}

// ExpenseWhereInput represents a where input for filtering Expense queries.
type ExpenseWhereInput struct {
	Predicates []predicate.Expense  `json:"-"`
	Not        *ExpenseWhereInput   `json:"not,omitempty"`
	Or         []*ExpenseWhereInput `json:"or,omitempty"`
	And        []*ExpenseWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "occurred_at" field predicates.
	OccurredAt      *time.Time  `json:"occurredAt,omitempty"`
	OccurredAtNEQ   *time.Time  `json:"occurredAtNEQ,omitempty"`
	OccurredAtIn    []time.Time `json:"occurredAtIn,omitempty"`
	OccurredAtNotIn []time.Time `json:"occurredAtNotIn,omitempty"`
	OccurredAtGT    *time.Time  `json:"occurredAtGT,omitempty"`
	OccurredAtGTE   *time.Time  `json:"occurredAtGTE,omitempty"`
	OccurredAtLT    *time.Time  `json:"occurredAtLT,omitempty"`
	OccurredAtLTE   *time.Time  `json:"occurredAtLTE,omitempty"`

	// "type" field predicates.
	Type      *expense.Type  `json:"type,omitempty"`
	TypeNEQ   *expense.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []expense.Type `json:"typeIn,omitempty"`
	TypeNotIn []expense.Type `json:"typeNotIn,omitempty"`

	// "amount" field predicates.
	Amount      *float64  `json:"amount,omitempty"`
	AmountNEQ   *float64  `json:"amountNEQ,omitempty"`
	AmountIn    []float64 `json:"amountIn,omitempty"`
	AmountNotIn []float64 `json:"amountNotIn,omitempty"`
	AmountGT    *float64  `json:"amountGT,omitempty"`
	AmountGTE   *float64  `json:"amountGTE,omitempty"`
	AmountLT    *float64  `json:"amountLT,omitempty"`
	AmountLTE   *float64  `json:"amountLTE,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "fuel_up" edge predicates.
	HasFuelUp     *bool               `json:"hasFuelUp,omitempty"`
	HasFuelUpWith []*FuelUpWhereInput `json:"hasFuelUpWith,omitempty"`

	// "service_log" edge predicates.
	HasServiceLog     *bool                   `json:"hasServiceLog,omitempty"`
	HasServiceLogWith []*ServiceLogWhereInput `json:"hasServiceLogWith,omitempty"`

	// "documents" edge predicates.
	HasDocuments     *bool                 `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentWhereInput `json:"hasDocumentsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ExpenseWhereInput) AddPredicates(predicates ...predicate.Expense) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ExpenseWhereInput filter on the ExpenseQuery builder.
func (i *ExpenseWhereInput) Filter(q *ExpenseQuery) (*ExpenseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyExpenseWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyExpenseWhereInput is returned in case the ExpenseWhereInput is empty.
var ErrEmptyExpenseWhereInput = errors.New("ent: empty predicate ExpenseWhereInput")

// P returns a predicate for filtering expenses.
// An error is returned if the input is empty or invalid.
func (i *ExpenseWhereInput) P() (predicate.Expense, error) {
	var predicates []predicate.Expense
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, expense.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Expense, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, expense.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Expense, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, expense.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, expense.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, expense.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, expense.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, expense.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, expense.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, expense.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, expense.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, expense.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, expense.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, expense.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, expense.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, expense.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, expense.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, expense.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, expense.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, expense.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, expense.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, expense.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, expense.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, expense.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, expense.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, expense.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, expense.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, expense.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.OccurredAt != nil {
		predicates = append(predicates, expense.OccurredAtEQ(*i.OccurredAt))
	}
	if i.OccurredAtNEQ != nil {
		predicates = append(predicates, expense.OccurredAtNEQ(*i.OccurredAtNEQ))
	}
	if len(i.OccurredAtIn) > 0 {
		predicates = append(predicates, expense.OccurredAtIn(i.OccurredAtIn...))
	}
	if len(i.OccurredAtNotIn) > 0 {
		predicates = append(predicates, expense.OccurredAtNotIn(i.OccurredAtNotIn...))
	}
	if i.OccurredAtGT != nil {
		predicates = append(predicates, expense.OccurredAtGT(*i.OccurredAtGT))
	}
	if i.OccurredAtGTE != nil {
		predicates = append(predicates, expense.OccurredAtGTE(*i.OccurredAtGTE))
	}
	if i.OccurredAtLT != nil {
		predicates = append(predicates, expense.OccurredAtLT(*i.OccurredAtLT))
	}
	if i.OccurredAtLTE != nil {
		predicates = append(predicates, expense.OccurredAtLTE(*i.OccurredAtLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, expense.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, expense.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, expense.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, expense.TypeNotIn(i.TypeNotIn...))
	}
	if i.Amount != nil {
		predicates = append(predicates, expense.AmountEQ(*i.Amount))
	}
	if i.AmountNEQ != nil {
		predicates = append(predicates, expense.AmountNEQ(*i.AmountNEQ))
	}
	if len(i.AmountIn) > 0 {
		predicates = append(predicates, expense.AmountIn(i.AmountIn...))
	}
	if len(i.AmountNotIn) > 0 {
		predicates = append(predicates, expense.AmountNotIn(i.AmountNotIn...))
	}
	if i.AmountGT != nil {
		predicates = append(predicates, expense.AmountGT(*i.AmountGT))
	}
	if i.AmountGTE != nil {
		predicates = append(predicates, expense.AmountGTE(*i.AmountGTE))
	}
	if i.AmountLT != nil {
		predicates = append(predicates, expense.AmountLT(*i.AmountLT))
	}
	if i.AmountLTE != nil {
		predicates = append(predicates, expense.AmountLTE(*i.AmountLTE))
	}

	if i.HasCar != nil {
		p := expense.HasCar()
		if !*i.HasCar {
			p = expense.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, expense.HasCarWith(with...))
	}
	if i.HasFuelUp != nil {
		p := expense.HasFuelUp()
		if !*i.HasFuelUp {
			p = expense.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFuelUpWith) > 0 {
		with := make([]predicate.FuelUp, 0, len(i.HasFuelUpWith))
		for _, w := range i.HasFuelUpWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFuelUpWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, expense.HasFuelUpWith(with...))
	}
	if i.HasServiceLog != nil {
		p := expense.HasServiceLog()
		if !*i.HasServiceLog {
			p = expense.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServiceLogWith) > 0 {
		with := make([]predicate.ServiceLog, 0, len(i.HasServiceLogWith))
		for _, w := range i.HasServiceLogWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServiceLogWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, expense.HasServiceLogWith(with...))
	}
	if i.HasDocuments != nil {
		p := expense.HasDocuments()
		if !*i.HasDocuments {
			p = expense.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDocumentsWith) > 0 {
		with := make([]predicate.Document, 0, len(i.HasDocumentsWith))
		for _, w := range i.HasDocumentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDocumentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, expense.HasDocumentsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyExpenseWhereInput
	case 1:
		return predicates[0], nil
	default:
		return expense.And(predicates...), nil
	}
}

// FuelUpWhereInput represents a where input for filtering FuelUp queries.
type FuelUpWhereInput struct {
	Predicates []predicate.FuelUp  `json:"-"`
	Not        *FuelUpWhereInput   `json:"not,omitempty"`
	Or         []*FuelUpWhereInput `json:"or,omitempty"`
	And        []*FuelUpWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "occurred_at" field predicates.
	OccurredAt      *time.Time  `json:"occurredAt,omitempty"`
	OccurredAtNEQ   *time.Time  `json:"occurredAtNEQ,omitempty"`
	OccurredAtIn    []time.Time `json:"occurredAtIn,omitempty"`
	OccurredAtNotIn []time.Time `json:"occurredAtNotIn,omitempty"`
	OccurredAtGT    *time.Time  `json:"occurredAtGT,omitempty"`
	OccurredAtGTE   *time.Time  `json:"occurredAtGTE,omitempty"`
	OccurredAtLT    *time.Time  `json:"occurredAtLT,omitempty"`
	OccurredAtLTE   *time.Time  `json:"occurredAtLTE,omitempty"`

	// "station" field predicates.
	Station             *string  `json:"station,omitempty"`
	StationNEQ          *string  `json:"stationNEQ,omitempty"`
	StationIn           []string `json:"stationIn,omitempty"`
	StationNotIn        []string `json:"stationNotIn,omitempty"`
	StationGT           *string  `json:"stationGT,omitempty"`
	StationGTE          *string  `json:"stationGTE,omitempty"`
	StationLT           *string  `json:"stationLT,omitempty"`
	StationLTE          *string  `json:"stationLTE,omitempty"`
	StationContains     *string  `json:"stationContains,omitempty"`
	StationHasPrefix    *string  `json:"stationHasPrefix,omitempty"`
	StationHasSuffix    *string  `json:"stationHasSuffix,omitempty"`
	StationEqualFold    *string  `json:"stationEqualFold,omitempty"`
	StationContainsFold *string  `json:"stationContainsFold,omitempty"`

	// "amount_liters" field predicates.
	AmountLiters      *float64  `json:"amountLiters,omitempty"`
	AmountLitersNEQ   *float64  `json:"amountLitersNEQ,omitempty"`
	AmountLitersIn    []float64 `json:"amountLitersIn,omitempty"`
	AmountLitersNotIn []float64 `json:"amountLitersNotIn,omitempty"`
	AmountLitersGT    *float64  `json:"amountLitersGT,omitempty"`
	AmountLitersGTE   *float64  `json:"amountLitersGTE,omitempty"`
	AmountLitersLT    *float64  `json:"amountLitersLT,omitempty"`
	AmountLitersLTE   *float64  `json:"amountLitersLTE,omitempty"`

	// "fuel_category" field predicates.
	FuelCategory      *fuelup.FuelCategory  `json:"fuelCategory,omitempty"`
	FuelCategoryNEQ   *fuelup.FuelCategory  `json:"fuelCategoryNEQ,omitempty"`
	FuelCategoryIn    []fuelup.FuelCategory `json:"fuelCategoryIn,omitempty"`
	FuelCategoryNotIn []fuelup.FuelCategory `json:"fuelCategoryNotIn,omitempty"`

	// "octane_rating" field predicates.
	OctaneRating       *fuelup.OctaneRating  `json:"octaneRating,omitempty"`
	OctaneRatingNEQ    *fuelup.OctaneRating  `json:"octaneRatingNEQ,omitempty"`
	OctaneRatingIn     []fuelup.OctaneRating `json:"octaneRatingIn,omitempty"`
	OctaneRatingNotIn  []fuelup.OctaneRating `json:"octaneRatingNotIn,omitempty"`
	OctaneRatingIsNil  bool                  `json:"octaneRatingIsNil,omitempty"`
	OctaneRatingNotNil bool                  `json:"octaneRatingNotNil,omitempty"`

	// "is_full_tank" field predicates.
	IsFullTank    *bool `json:"isFullTank,omitempty"`
	IsFullTankNEQ *bool `json:"isFullTankNEQ,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesIsNil        bool     `json:"notesIsNil,omitempty"`
	NotesNotNil       bool     `json:"notesNotNil,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "odometer_reading" edge predicates.
	HasOdometerReading     *bool                        `json:"hasOdometerReading,omitempty"`
	HasOdometerReadingWith []*OdometerReadingWhereInput `json:"hasOdometerReadingWith,omitempty"`

	// "expense" edge predicates.
	HasExpense     *bool                `json:"hasExpense,omitempty"`
	HasExpenseWith []*ExpenseWhereInput `json:"hasExpenseWith,omitempty"`

	// "documents" edge predicates.
	HasDocuments     *bool                 `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentWhereInput `json:"hasDocumentsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FuelUpWhereInput) AddPredicates(predicates ...predicate.FuelUp) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FuelUpWhereInput filter on the FuelUpQuery builder.
func (i *FuelUpWhereInput) Filter(q *FuelUpQuery) (*FuelUpQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFuelUpWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFuelUpWhereInput is returned in case the FuelUpWhereInput is empty.
var ErrEmptyFuelUpWhereInput = errors.New("ent: empty predicate FuelUpWhereInput")

// P returns a predicate for filtering fuelups.
// An error is returned if the input is empty or invalid.
func (i *FuelUpWhereInput) P() (predicate.FuelUp, error) {
	var predicates []predicate.FuelUp
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, fuelup.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.FuelUp, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, fuelup.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.FuelUp, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, fuelup.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, fuelup.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, fuelup.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, fuelup.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, fuelup.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, fuelup.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, fuelup.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, fuelup.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, fuelup.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, fuelup.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, fuelup.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, fuelup.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, fuelup.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, fuelup.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, fuelup.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, fuelup.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, fuelup.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, fuelup.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, fuelup.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, fuelup.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, fuelup.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, fuelup.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, fuelup.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, fuelup.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, fuelup.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.OccurredAt != nil {
		predicates = append(predicates, fuelup.OccurredAtEQ(*i.OccurredAt))
	}
	if i.OccurredAtNEQ != nil {
		predicates = append(predicates, fuelup.OccurredAtNEQ(*i.OccurredAtNEQ))
	}
	if len(i.OccurredAtIn) > 0 {
		predicates = append(predicates, fuelup.OccurredAtIn(i.OccurredAtIn...))
	}
	if len(i.OccurredAtNotIn) > 0 {
		predicates = append(predicates, fuelup.OccurredAtNotIn(i.OccurredAtNotIn...))
	}
	if i.OccurredAtGT != nil {
		predicates = append(predicates, fuelup.OccurredAtGT(*i.OccurredAtGT))
	}
	if i.OccurredAtGTE != nil {
		predicates = append(predicates, fuelup.OccurredAtGTE(*i.OccurredAtGTE))
	}
	if i.OccurredAtLT != nil {
		predicates = append(predicates, fuelup.OccurredAtLT(*i.OccurredAtLT))
	}
	if i.OccurredAtLTE != nil {
		predicates = append(predicates, fuelup.OccurredAtLTE(*i.OccurredAtLTE))
	}
	if i.Station != nil {
		predicates = append(predicates, fuelup.StationEQ(*i.Station))
	}
	if i.StationNEQ != nil {
		predicates = append(predicates, fuelup.StationNEQ(*i.StationNEQ))
	}
	if len(i.StationIn) > 0 {
		predicates = append(predicates, fuelup.StationIn(i.StationIn...))
	}
	if len(i.StationNotIn) > 0 {
		predicates = append(predicates, fuelup.StationNotIn(i.StationNotIn...))
	}
	if i.StationGT != nil {
		predicates = append(predicates, fuelup.StationGT(*i.StationGT))
	}
	if i.StationGTE != nil {
		predicates = append(predicates, fuelup.StationGTE(*i.StationGTE))
	}
	if i.StationLT != nil {
		predicates = append(predicates, fuelup.StationLT(*i.StationLT))
	}
	if i.StationLTE != nil {
		predicates = append(predicates, fuelup.StationLTE(*i.StationLTE))
	}
	if i.StationContains != nil {
		predicates = append(predicates, fuelup.StationContains(*i.StationContains))
	}
	if i.StationHasPrefix != nil {
		predicates = append(predicates, fuelup.StationHasPrefix(*i.StationHasPrefix))
	}
	if i.StationHasSuffix != nil {
		predicates = append(predicates, fuelup.StationHasSuffix(*i.StationHasSuffix))
	}
	if i.StationEqualFold != nil {
		predicates = append(predicates, fuelup.StationEqualFold(*i.StationEqualFold))
	}
	if i.StationContainsFold != nil {
		predicates = append(predicates, fuelup.StationContainsFold(*i.StationContainsFold))
	}
	if i.AmountLiters != nil {
		predicates = append(predicates, fuelup.AmountLitersEQ(*i.AmountLiters))
	}
	if i.AmountLitersNEQ != nil {
		predicates = append(predicates, fuelup.AmountLitersNEQ(*i.AmountLitersNEQ))
	}
	if len(i.AmountLitersIn) > 0 {
		predicates = append(predicates, fuelup.AmountLitersIn(i.AmountLitersIn...))
	}
	if len(i.AmountLitersNotIn) > 0 {
		predicates = append(predicates, fuelup.AmountLitersNotIn(i.AmountLitersNotIn...))
	}
	if i.AmountLitersGT != nil {
		predicates = append(predicates, fuelup.AmountLitersGT(*i.AmountLitersGT))
	}
	if i.AmountLitersGTE != nil {
		predicates = append(predicates, fuelup.AmountLitersGTE(*i.AmountLitersGTE))
	}
	if i.AmountLitersLT != nil {
		predicates = append(predicates, fuelup.AmountLitersLT(*i.AmountLitersLT))
	}
	if i.AmountLitersLTE != nil {
		predicates = append(predicates, fuelup.AmountLitersLTE(*i.AmountLitersLTE))
	}
	if i.FuelCategory != nil {
		predicates = append(predicates, fuelup.FuelCategoryEQ(*i.FuelCategory))
	}
	if i.FuelCategoryNEQ != nil {
		predicates = append(predicates, fuelup.FuelCategoryNEQ(*i.FuelCategoryNEQ))
	}
	if len(i.FuelCategoryIn) > 0 {
		predicates = append(predicates, fuelup.FuelCategoryIn(i.FuelCategoryIn...))
	}
	if len(i.FuelCategoryNotIn) > 0 {
		predicates = append(predicates, fuelup.FuelCategoryNotIn(i.FuelCategoryNotIn...))
	}
	if i.OctaneRating != nil {
		predicates = append(predicates, fuelup.OctaneRatingEQ(*i.OctaneRating))
	}
	if i.OctaneRatingNEQ != nil {
		predicates = append(predicates, fuelup.OctaneRatingNEQ(*i.OctaneRatingNEQ))
	}
	if len(i.OctaneRatingIn) > 0 {
		predicates = append(predicates, fuelup.OctaneRatingIn(i.OctaneRatingIn...))
	}
	if len(i.OctaneRatingNotIn) > 0 {
		predicates = append(predicates, fuelup.OctaneRatingNotIn(i.OctaneRatingNotIn...))
	}
	if i.OctaneRatingIsNil {
		predicates = append(predicates, fuelup.OctaneRatingIsNil())
	}
	if i.OctaneRatingNotNil {
		predicates = append(predicates, fuelup.OctaneRatingNotNil())
	}
	if i.IsFullTank != nil {
		predicates = append(predicates, fuelup.IsFullTankEQ(*i.IsFullTank))
	}
	if i.IsFullTankNEQ != nil {
		predicates = append(predicates, fuelup.IsFullTankNEQ(*i.IsFullTankNEQ))
	}
	if i.Notes != nil {
		predicates = append(predicates, fuelup.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, fuelup.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, fuelup.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, fuelup.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, fuelup.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, fuelup.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, fuelup.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, fuelup.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, fuelup.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, fuelup.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, fuelup.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesIsNil {
		predicates = append(predicates, fuelup.NotesIsNil())
	}
	if i.NotesNotNil {
		predicates = append(predicates, fuelup.NotesNotNil())
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, fuelup.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, fuelup.NotesContainsFold(*i.NotesContainsFold))
	}

	if i.HasCar != nil {
		p := fuelup.HasCar()
		if !*i.HasCar {
			p = fuelup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, fuelup.HasCarWith(with...))
	}
	if i.HasOdometerReading != nil {
		p := fuelup.HasOdometerReading()
		if !*i.HasOdometerReading {
			p = fuelup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOdometerReadingWith) > 0 {
		with := make([]predicate.OdometerReading, 0, len(i.HasOdometerReadingWith))
		for _, w := range i.HasOdometerReadingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOdometerReadingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, fuelup.HasOdometerReadingWith(with...))
	}
	if i.HasExpense != nil {
		p := fuelup.HasExpense()
		if !*i.HasExpense {
			p = fuelup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExpenseWith) > 0 {
		with := make([]predicate.Expense, 0, len(i.HasExpenseWith))
		for _, w := range i.HasExpenseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExpenseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, fuelup.HasExpenseWith(with...))
	}
	if i.HasDocuments != nil {
		p := fuelup.HasDocuments()
		if !*i.HasDocuments {
			p = fuelup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDocumentsWith) > 0 {
		with := make([]predicate.Document, 0, len(i.HasDocumentsWith))
		for _, w := range i.HasDocumentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDocumentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, fuelup.HasDocumentsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFuelUpWhereInput
	case 1:
		return predicates[0], nil
	default:
		return fuelup.And(predicates...), nil
	}
}

// MediaWhereInput represents a where input for filtering Media queries.
type MediaWhereInput struct {
	Predicates []predicate.Media  `json:"-"`
	Not        *MediaWhereInput   `json:"not,omitempty"`
	Or         []*MediaWhereInput `json:"or,omitempty"`
	And        []*MediaWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        bool     `json:"titleIsNil,omitempty"`
	TitleNotNil       bool     `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "mod_product_option" edge predicates.
	HasModProductOption     *bool                         `json:"hasModProductOption,omitempty"`
	HasModProductOptionWith []*ModProductOptionWhereInput `json:"hasModProductOptionWith,omitempty"`

	// "build_log" edge predicates.
	HasBuildLog     *bool                 `json:"hasBuildLog,omitempty"`
	HasBuildLogWith []*BuildLogWhereInput `json:"hasBuildLogWith,omitempty"`

	// "albums" edge predicates.
	HasAlbums     *bool              `json:"hasAlbums,omitempty"`
	HasAlbumsWith []*AlbumWhereInput `json:"hasAlbumsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MediaWhereInput) AddPredicates(predicates ...predicate.Media) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MediaWhereInput filter on the MediaQuery builder.
func (i *MediaWhereInput) Filter(q *MediaQuery) (*MediaQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMediaWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMediaWhereInput is returned in case the MediaWhereInput is empty.
var ErrEmptyMediaWhereInput = errors.New("ent: empty predicate MediaWhereInput")

// P returns a predicate for filtering mediaslice.
// An error is returned if the input is empty or invalid.
func (i *MediaWhereInput) P() (predicate.Media, error) {
	var predicates []predicate.Media
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, media.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Media, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, media.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Media, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, media.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, media.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, media.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, media.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, media.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, media.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, media.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, media.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, media.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, media.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, media.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, media.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, media.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, media.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, media.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, media.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, media.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, media.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, media.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, media.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, media.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, media.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, media.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, media.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, media.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, media.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, media.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, media.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, media.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, media.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, media.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, media.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, media.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, media.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, media.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, media.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleIsNil {
		predicates = append(predicates, media.TitleIsNil())
	}
	if i.TitleNotNil {
		predicates = append(predicates, media.TitleNotNil())
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, media.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, media.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, media.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, media.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, media.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, media.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, media.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, media.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, media.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, media.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, media.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, media.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, media.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, media.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, media.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, media.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, media.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasUser != nil {
		p := media.HasUser()
		if !*i.HasUser {
			p = media.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, media.HasUserWith(with...))
	}
	if i.HasCar != nil {
		p := media.HasCar()
		if !*i.HasCar {
			p = media.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, media.HasCarWith(with...))
	}
	if i.HasModProductOption != nil {
		p := media.HasModProductOption()
		if !*i.HasModProductOption {
			p = media.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasModProductOptionWith) > 0 {
		with := make([]predicate.ModProductOption, 0, len(i.HasModProductOptionWith))
		for _, w := range i.HasModProductOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasModProductOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, media.HasModProductOptionWith(with...))
	}
	if i.HasBuildLog != nil {
		p := media.HasBuildLog()
		if !*i.HasBuildLog {
			p = media.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBuildLogWith) > 0 {
		with := make([]predicate.BuildLog, 0, len(i.HasBuildLogWith))
		for _, w := range i.HasBuildLogWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBuildLogWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, media.HasBuildLogWith(with...))
	}
	if i.HasAlbums != nil {
		p := media.HasAlbums()
		if !*i.HasAlbums {
			p = media.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAlbumsWith) > 0 {
		with := make([]predicate.Album, 0, len(i.HasAlbumsWith))
		for _, w := range i.HasAlbumsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAlbumsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, media.HasAlbumsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMediaWhereInput
	case 1:
		return predicates[0], nil
	default:
		return media.And(predicates...), nil
	}
}

// ModWhereInput represents a where input for filtering Mod queries.
type ModWhereInput struct {
	Predicates []predicate.Mod  `json:"-"`
	Not        *ModWhereInput   `json:"not,omitempty"`
	Or         []*ModWhereInput `json:"or,omitempty"`
	And        []*ModWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "category" field predicates.
	Category      *mod.Category  `json:"category,omitempty"`
	CategoryNEQ   *mod.Category  `json:"categoryNEQ,omitempty"`
	CategoryIn    []mod.Category `json:"categoryIn,omitempty"`
	CategoryNotIn []mod.Category `json:"categoryNotIn,omitempty"`

	// "status" field predicates.
	Status      *mod.Status  `json:"status,omitempty"`
	StatusNEQ   *mod.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []mod.Status `json:"statusIn,omitempty"`
	StatusNotIn []mod.Status `json:"statusNotIn,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "stage" field predicates.
	Stage             *string  `json:"stage,omitempty"`
	StageNEQ          *string  `json:"stageNEQ,omitempty"`
	StageIn           []string `json:"stageIn,omitempty"`
	StageNotIn        []string `json:"stageNotIn,omitempty"`
	StageGT           *string  `json:"stageGT,omitempty"`
	StageGTE          *string  `json:"stageGTE,omitempty"`
	StageLT           *string  `json:"stageLT,omitempty"`
	StageLTE          *string  `json:"stageLTE,omitempty"`
	StageContains     *string  `json:"stageContains,omitempty"`
	StageHasPrefix    *string  `json:"stageHasPrefix,omitempty"`
	StageHasSuffix    *string  `json:"stageHasSuffix,omitempty"`
	StageIsNil        bool     `json:"stageIsNil,omitempty"`
	StageNotNil       bool     `json:"stageNotNil,omitempty"`
	StageEqualFold    *string  `json:"stageEqualFold,omitempty"`
	StageContainsFold *string  `json:"stageContainsFold,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`

	// "product_options" edge predicates.
	HasProductOptions     *bool                         `json:"hasProductOptions,omitempty"`
	HasProductOptionsWith []*ModProductOptionWhereInput `json:"hasProductOptionsWith,omitempty"`

	// "build_logs" edge predicates.
	HasBuildLogs     *bool                 `json:"hasBuildLogs,omitempty"`
	HasBuildLogsWith []*BuildLogWhereInput `json:"hasBuildLogsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ModWhereInput) AddPredicates(predicates ...predicate.Mod) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ModWhereInput filter on the ModQuery builder.
func (i *ModWhereInput) Filter(q *ModQuery) (*ModQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyModWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyModWhereInput is returned in case the ModWhereInput is empty.
var ErrEmptyModWhereInput = errors.New("ent: empty predicate ModWhereInput")

// P returns a predicate for filtering mods.
// An error is returned if the input is empty or invalid.
func (i *ModWhereInput) P() (predicate.Mod, error) {
	var predicates []predicate.Mod
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, mod.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Mod, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, mod.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Mod, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, mod.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, mod.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, mod.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, mod.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, mod.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, mod.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, mod.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, mod.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, mod.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, mod.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, mod.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, mod.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, mod.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, mod.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, mod.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, mod.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, mod.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, mod.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, mod.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, mod.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, mod.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, mod.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, mod.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, mod.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, mod.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, mod.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, mod.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, mod.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, mod.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, mod.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, mod.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, mod.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, mod.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, mod.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, mod.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, mod.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, mod.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, mod.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Category != nil {
		predicates = append(predicates, mod.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, mod.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, mod.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, mod.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.Status != nil {
		predicates = append(predicates, mod.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, mod.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, mod.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, mod.StatusNotIn(i.StatusNotIn...))
	}
	if i.Description != nil {
		predicates = append(predicates, mod.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, mod.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, mod.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, mod.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, mod.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, mod.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, mod.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, mod.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, mod.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, mod.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, mod.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, mod.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, mod.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, mod.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, mod.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Stage != nil {
		predicates = append(predicates, mod.StageEQ(*i.Stage))
	}
	if i.StageNEQ != nil {
		predicates = append(predicates, mod.StageNEQ(*i.StageNEQ))
	}
	if len(i.StageIn) > 0 {
		predicates = append(predicates, mod.StageIn(i.StageIn...))
	}
	if len(i.StageNotIn) > 0 {
		predicates = append(predicates, mod.StageNotIn(i.StageNotIn...))
	}
	if i.StageGT != nil {
		predicates = append(predicates, mod.StageGT(*i.StageGT))
	}
	if i.StageGTE != nil {
		predicates = append(predicates, mod.StageGTE(*i.StageGTE))
	}
	if i.StageLT != nil {
		predicates = append(predicates, mod.StageLT(*i.StageLT))
	}
	if i.StageLTE != nil {
		predicates = append(predicates, mod.StageLTE(*i.StageLTE))
	}
	if i.StageContains != nil {
		predicates = append(predicates, mod.StageContains(*i.StageContains))
	}
	if i.StageHasPrefix != nil {
		predicates = append(predicates, mod.StageHasPrefix(*i.StageHasPrefix))
	}
	if i.StageHasSuffix != nil {
		predicates = append(predicates, mod.StageHasSuffix(*i.StageHasSuffix))
	}
	if i.StageIsNil {
		predicates = append(predicates, mod.StageIsNil())
	}
	if i.StageNotNil {
		predicates = append(predicates, mod.StageNotNil())
	}
	if i.StageEqualFold != nil {
		predicates = append(predicates, mod.StageEqualFold(*i.StageEqualFold))
	}
	if i.StageContainsFold != nil {
		predicates = append(predicates, mod.StageContainsFold(*i.StageContainsFold))
	}

	if i.HasCar != nil {
		p := mod.HasCar()
		if !*i.HasCar {
			p = mod.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, mod.HasCarWith(with...))
	}
	if i.HasTasks != nil {
		p := mod.HasTasks()
		if !*i.HasTasks {
			p = mod.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, mod.HasTasksWith(with...))
	}
	if i.HasProductOptions != nil {
		p := mod.HasProductOptions()
		if !*i.HasProductOptions {
			p = mod.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductOptionsWith) > 0 {
		with := make([]predicate.ModProductOption, 0, len(i.HasProductOptionsWith))
		for _, w := range i.HasProductOptionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductOptionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, mod.HasProductOptionsWith(with...))
	}
	if i.HasBuildLogs != nil {
		p := mod.HasBuildLogs()
		if !*i.HasBuildLogs {
			p = mod.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBuildLogsWith) > 0 {
		with := make([]predicate.BuildLog, 0, len(i.HasBuildLogsWith))
		for _, w := range i.HasBuildLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBuildLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, mod.HasBuildLogsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyModWhereInput
	case 1:
		return predicates[0], nil
	default:
		return mod.And(predicates...), nil
	}
}

// ModProductOptionWhereInput represents a where input for filtering ModProductOption queries.
type ModProductOptionWhereInput struct {
	Predicates []predicate.ModProductOption  `json:"-"`
	Not        *ModProductOptionWhereInput   `json:"not,omitempty"`
	Or         []*ModProductOptionWhereInput `json:"or,omitempty"`
	And        []*ModProductOptionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "vendor" field predicates.
	Vendor             *string  `json:"vendor,omitempty"`
	VendorNEQ          *string  `json:"vendorNEQ,omitempty"`
	VendorIn           []string `json:"vendorIn,omitempty"`
	VendorNotIn        []string `json:"vendorNotIn,omitempty"`
	VendorGT           *string  `json:"vendorGT,omitempty"`
	VendorGTE          *string  `json:"vendorGTE,omitempty"`
	VendorLT           *string  `json:"vendorLT,omitempty"`
	VendorLTE          *string  `json:"vendorLTE,omitempty"`
	VendorContains     *string  `json:"vendorContains,omitempty"`
	VendorHasPrefix    *string  `json:"vendorHasPrefix,omitempty"`
	VendorHasSuffix    *string  `json:"vendorHasSuffix,omitempty"`
	VendorIsNil        bool     `json:"vendorIsNil,omitempty"`
	VendorNotNil       bool     `json:"vendorNotNil,omitempty"`
	VendorEqualFold    *string  `json:"vendorEqualFold,omitempty"`
	VendorContainsFold *string  `json:"vendorContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "link" field predicates.
	Link             *string  `json:"link,omitempty"`
	LinkNEQ          *string  `json:"linkNEQ,omitempty"`
	LinkIn           []string `json:"linkIn,omitempty"`
	LinkNotIn        []string `json:"linkNotIn,omitempty"`
	LinkGT           *string  `json:"linkGT,omitempty"`
	LinkGTE          *string  `json:"linkGTE,omitempty"`
	LinkLT           *string  `json:"linkLT,omitempty"`
	LinkLTE          *string  `json:"linkLTE,omitempty"`
	LinkContains     *string  `json:"linkContains,omitempty"`
	LinkHasPrefix    *string  `json:"linkHasPrefix,omitempty"`
	LinkHasSuffix    *string  `json:"linkHasSuffix,omitempty"`
	LinkIsNil        bool     `json:"linkIsNil,omitempty"`
	LinkNotNil       bool     `json:"linkNotNil,omitempty"`
	LinkEqualFold    *string  `json:"linkEqualFold,omitempty"`
	LinkContainsFold *string  `json:"linkContainsFold,omitempty"`

	// "price" field predicates.
	Price       *float64  `json:"price,omitempty"`
	PriceNEQ    *float64  `json:"priceNEQ,omitempty"`
	PriceIn     []float64 `json:"priceIn,omitempty"`
	PriceNotIn  []float64 `json:"priceNotIn,omitempty"`
	PriceGT     *float64  `json:"priceGT,omitempty"`
	PriceGTE    *float64  `json:"priceGTE,omitempty"`
	PriceLT     *float64  `json:"priceLT,omitempty"`
	PriceLTE    *float64  `json:"priceLTE,omitempty"`
	PriceIsNil  bool      `json:"priceIsNil,omitempty"`
	PriceNotNil bool      `json:"priceNotNil,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesIsNil        bool     `json:"notesIsNil,omitempty"`
	NotesNotNil       bool     `json:"notesNotNil,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "mod" edge predicates.
	HasMod     *bool            `json:"hasMod,omitempty"`
	HasModWith []*ModWhereInput `json:"hasModWith,omitempty"`

	// "media" edge predicates.
	HasMedia     *bool              `json:"hasMedia,omitempty"`
	HasMediaWith []*MediaWhereInput `json:"hasMediaWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ModProductOptionWhereInput) AddPredicates(predicates ...predicate.ModProductOption) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ModProductOptionWhereInput filter on the ModProductOptionQuery builder.
func (i *ModProductOptionWhereInput) Filter(q *ModProductOptionQuery) (*ModProductOptionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyModProductOptionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyModProductOptionWhereInput is returned in case the ModProductOptionWhereInput is empty.
var ErrEmptyModProductOptionWhereInput = errors.New("ent: empty predicate ModProductOptionWhereInput")

// P returns a predicate for filtering modproductoptions.
// An error is returned if the input is empty or invalid.
func (i *ModProductOptionWhereInput) P() (predicate.ModProductOption, error) {
	var predicates []predicate.ModProductOption
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, modproductoption.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ModProductOption, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, modproductoption.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ModProductOption, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, modproductoption.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, modproductoption.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, modproductoption.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, modproductoption.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, modproductoption.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, modproductoption.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, modproductoption.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, modproductoption.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, modproductoption.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, modproductoption.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, modproductoption.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, modproductoption.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, modproductoption.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, modproductoption.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, modproductoption.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, modproductoption.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, modproductoption.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, modproductoption.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, modproductoption.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, modproductoption.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, modproductoption.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, modproductoption.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, modproductoption.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, modproductoption.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, modproductoption.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Vendor != nil {
		predicates = append(predicates, modproductoption.VendorEQ(*i.Vendor))
	}
	if i.VendorNEQ != nil {
		predicates = append(predicates, modproductoption.VendorNEQ(*i.VendorNEQ))
	}
	if len(i.VendorIn) > 0 {
		predicates = append(predicates, modproductoption.VendorIn(i.VendorIn...))
	}
	if len(i.VendorNotIn) > 0 {
		predicates = append(predicates, modproductoption.VendorNotIn(i.VendorNotIn...))
	}
	if i.VendorGT != nil {
		predicates = append(predicates, modproductoption.VendorGT(*i.VendorGT))
	}
	if i.VendorGTE != nil {
		predicates = append(predicates, modproductoption.VendorGTE(*i.VendorGTE))
	}
	if i.VendorLT != nil {
		predicates = append(predicates, modproductoption.VendorLT(*i.VendorLT))
	}
	if i.VendorLTE != nil {
		predicates = append(predicates, modproductoption.VendorLTE(*i.VendorLTE))
	}
	if i.VendorContains != nil {
		predicates = append(predicates, modproductoption.VendorContains(*i.VendorContains))
	}
	if i.VendorHasPrefix != nil {
		predicates = append(predicates, modproductoption.VendorHasPrefix(*i.VendorHasPrefix))
	}
	if i.VendorHasSuffix != nil {
		predicates = append(predicates, modproductoption.VendorHasSuffix(*i.VendorHasSuffix))
	}
	if i.VendorIsNil {
		predicates = append(predicates, modproductoption.VendorIsNil())
	}
	if i.VendorNotNil {
		predicates = append(predicates, modproductoption.VendorNotNil())
	}
	if i.VendorEqualFold != nil {
		predicates = append(predicates, modproductoption.VendorEqualFold(*i.VendorEqualFold))
	}
	if i.VendorContainsFold != nil {
		predicates = append(predicates, modproductoption.VendorContainsFold(*i.VendorContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, modproductoption.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, modproductoption.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, modproductoption.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, modproductoption.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, modproductoption.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, modproductoption.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, modproductoption.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, modproductoption.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, modproductoption.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, modproductoption.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, modproductoption.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, modproductoption.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, modproductoption.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, modproductoption.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, modproductoption.NameContainsFold(*i.NameContainsFold))
	}
	if i.Link != nil {
		predicates = append(predicates, modproductoption.LinkEQ(*i.Link))
	}
	if i.LinkNEQ != nil {
		predicates = append(predicates, modproductoption.LinkNEQ(*i.LinkNEQ))
	}
	if len(i.LinkIn) > 0 {
		predicates = append(predicates, modproductoption.LinkIn(i.LinkIn...))
	}
	if len(i.LinkNotIn) > 0 {
		predicates = append(predicates, modproductoption.LinkNotIn(i.LinkNotIn...))
	}
	if i.LinkGT != nil {
		predicates = append(predicates, modproductoption.LinkGT(*i.LinkGT))
	}
	if i.LinkGTE != nil {
		predicates = append(predicates, modproductoption.LinkGTE(*i.LinkGTE))
	}
	if i.LinkLT != nil {
		predicates = append(predicates, modproductoption.LinkLT(*i.LinkLT))
	}
	if i.LinkLTE != nil {
		predicates = append(predicates, modproductoption.LinkLTE(*i.LinkLTE))
	}
	if i.LinkContains != nil {
		predicates = append(predicates, modproductoption.LinkContains(*i.LinkContains))
	}
	if i.LinkHasPrefix != nil {
		predicates = append(predicates, modproductoption.LinkHasPrefix(*i.LinkHasPrefix))
	}
	if i.LinkHasSuffix != nil {
		predicates = append(predicates, modproductoption.LinkHasSuffix(*i.LinkHasSuffix))
	}
	if i.LinkIsNil {
		predicates = append(predicates, modproductoption.LinkIsNil())
	}
	if i.LinkNotNil {
		predicates = append(predicates, modproductoption.LinkNotNil())
	}
	if i.LinkEqualFold != nil {
		predicates = append(predicates, modproductoption.LinkEqualFold(*i.LinkEqualFold))
	}
	if i.LinkContainsFold != nil {
		predicates = append(predicates, modproductoption.LinkContainsFold(*i.LinkContainsFold))
	}
	if i.Price != nil {
		predicates = append(predicates, modproductoption.PriceEQ(*i.Price))
	}
	if i.PriceNEQ != nil {
		predicates = append(predicates, modproductoption.PriceNEQ(*i.PriceNEQ))
	}
	if len(i.PriceIn) > 0 {
		predicates = append(predicates, modproductoption.PriceIn(i.PriceIn...))
	}
	if len(i.PriceNotIn) > 0 {
		predicates = append(predicates, modproductoption.PriceNotIn(i.PriceNotIn...))
	}
	if i.PriceGT != nil {
		predicates = append(predicates, modproductoption.PriceGT(*i.PriceGT))
	}
	if i.PriceGTE != nil {
		predicates = append(predicates, modproductoption.PriceGTE(*i.PriceGTE))
	}
	if i.PriceLT != nil {
		predicates = append(predicates, modproductoption.PriceLT(*i.PriceLT))
	}
	if i.PriceLTE != nil {
		predicates = append(predicates, modproductoption.PriceLTE(*i.PriceLTE))
	}
	if i.PriceIsNil {
		predicates = append(predicates, modproductoption.PriceIsNil())
	}
	if i.PriceNotNil {
		predicates = append(predicates, modproductoption.PriceNotNil())
	}
	if i.Notes != nil {
		predicates = append(predicates, modproductoption.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, modproductoption.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, modproductoption.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, modproductoption.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, modproductoption.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, modproductoption.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, modproductoption.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, modproductoption.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, modproductoption.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, modproductoption.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, modproductoption.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesIsNil {
		predicates = append(predicates, modproductoption.NotesIsNil())
	}
	if i.NotesNotNil {
		predicates = append(predicates, modproductoption.NotesNotNil())
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, modproductoption.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, modproductoption.NotesContainsFold(*i.NotesContainsFold))
	}

	if i.HasMod != nil {
		p := modproductoption.HasMod()
		if !*i.HasMod {
			p = modproductoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasModWith) > 0 {
		with := make([]predicate.Mod, 0, len(i.HasModWith))
		for _, w := range i.HasModWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasModWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, modproductoption.HasModWith(with...))
	}
	if i.HasMedia != nil {
		p := modproductoption.HasMedia()
		if !*i.HasMedia {
			p = modproductoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMediaWith) > 0 {
		with := make([]predicate.Media, 0, len(i.HasMediaWith))
		for _, w := range i.HasMediaWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMediaWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, modproductoption.HasMediaWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyModProductOptionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return modproductoption.And(predicates...), nil
	}
}

// OdometerReadingWhereInput represents a where input for filtering OdometerReading queries.
type OdometerReadingWhereInput struct {
	Predicates []predicate.OdometerReading  `json:"-"`
	Not        *OdometerReadingWhereInput   `json:"not,omitempty"`
	Or         []*OdometerReadingWhereInput `json:"or,omitempty"`
	And        []*OdometerReadingWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "reading_km" field predicates.
	ReadingKm      *float64  `json:"readingKm,omitempty"`
	ReadingKmNEQ   *float64  `json:"readingKmNEQ,omitempty"`
	ReadingKmIn    []float64 `json:"readingKmIn,omitempty"`
	ReadingKmNotIn []float64 `json:"readingKmNotIn,omitempty"`
	ReadingKmGT    *float64  `json:"readingKmGT,omitempty"`
	ReadingKmGTE   *float64  `json:"readingKmGTE,omitempty"`
	ReadingKmLT    *float64  `json:"readingKmLT,omitempty"`
	ReadingKmLTE   *float64  `json:"readingKmLTE,omitempty"`

	// "reading_time" field predicates.
	ReadingTime      *time.Time  `json:"readingTime,omitempty"`
	ReadingTimeNEQ   *time.Time  `json:"readingTimeNEQ,omitempty"`
	ReadingTimeIn    []time.Time `json:"readingTimeIn,omitempty"`
	ReadingTimeNotIn []time.Time `json:"readingTimeNotIn,omitempty"`
	ReadingTimeGT    *time.Time  `json:"readingTimeGT,omitempty"`
	ReadingTimeGTE   *time.Time  `json:"readingTimeGTE,omitempty"`
	ReadingTimeLT    *time.Time  `json:"readingTimeLT,omitempty"`
	ReadingTimeLTE   *time.Time  `json:"readingTimeLTE,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesIsNil        bool     `json:"notesIsNil,omitempty"`
	NotesNotNil       bool     `json:"notesNotNil,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "fuel_up" edge predicates.
	HasFuelUp     *bool               `json:"hasFuelUp,omitempty"`
	HasFuelUpWith []*FuelUpWhereInput `json:"hasFuelUpWith,omitempty"`

	// "service_log" edge predicates.
	HasServiceLog     *bool                   `json:"hasServiceLog,omitempty"`
	HasServiceLogWith []*ServiceLogWhereInput `json:"hasServiceLogWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OdometerReadingWhereInput) AddPredicates(predicates ...predicate.OdometerReading) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OdometerReadingWhereInput filter on the OdometerReadingQuery builder.
func (i *OdometerReadingWhereInput) Filter(q *OdometerReadingQuery) (*OdometerReadingQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOdometerReadingWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOdometerReadingWhereInput is returned in case the OdometerReadingWhereInput is empty.
var ErrEmptyOdometerReadingWhereInput = errors.New("ent: empty predicate OdometerReadingWhereInput")

// P returns a predicate for filtering odometerreadings.
// An error is returned if the input is empty or invalid.
func (i *OdometerReadingWhereInput) P() (predicate.OdometerReading, error) {
	var predicates []predicate.OdometerReading
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, odometerreading.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OdometerReading, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, odometerreading.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OdometerReading, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, odometerreading.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, odometerreading.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, odometerreading.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, odometerreading.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, odometerreading.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, odometerreading.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, odometerreading.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, odometerreading.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, odometerreading.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, odometerreading.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, odometerreading.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, odometerreading.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, odometerreading.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, odometerreading.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, odometerreading.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, odometerreading.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, odometerreading.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, odometerreading.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, odometerreading.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, odometerreading.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, odometerreading.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, odometerreading.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, odometerreading.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, odometerreading.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, odometerreading.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.ReadingKm != nil {
		predicates = append(predicates, odometerreading.ReadingKmEQ(*i.ReadingKm))
	}
	if i.ReadingKmNEQ != nil {
		predicates = append(predicates, odometerreading.ReadingKmNEQ(*i.ReadingKmNEQ))
	}
	if len(i.ReadingKmIn) > 0 {
		predicates = append(predicates, odometerreading.ReadingKmIn(i.ReadingKmIn...))
	}
	if len(i.ReadingKmNotIn) > 0 {
		predicates = append(predicates, odometerreading.ReadingKmNotIn(i.ReadingKmNotIn...))
	}
	if i.ReadingKmGT != nil {
		predicates = append(predicates, odometerreading.ReadingKmGT(*i.ReadingKmGT))
	}
	if i.ReadingKmGTE != nil {
		predicates = append(predicates, odometerreading.ReadingKmGTE(*i.ReadingKmGTE))
	}
	if i.ReadingKmLT != nil {
		predicates = append(predicates, odometerreading.ReadingKmLT(*i.ReadingKmLT))
	}
	if i.ReadingKmLTE != nil {
		predicates = append(predicates, odometerreading.ReadingKmLTE(*i.ReadingKmLTE))
	}
	if i.ReadingTime != nil {
		predicates = append(predicates, odometerreading.ReadingTimeEQ(*i.ReadingTime))
	}
	if i.ReadingTimeNEQ != nil {
		predicates = append(predicates, odometerreading.ReadingTimeNEQ(*i.ReadingTimeNEQ))
	}
	if len(i.ReadingTimeIn) > 0 {
		predicates = append(predicates, odometerreading.ReadingTimeIn(i.ReadingTimeIn...))
	}
	if len(i.ReadingTimeNotIn) > 0 {
		predicates = append(predicates, odometerreading.ReadingTimeNotIn(i.ReadingTimeNotIn...))
	}
	if i.ReadingTimeGT != nil {
		predicates = append(predicates, odometerreading.ReadingTimeGT(*i.ReadingTimeGT))
	}
	if i.ReadingTimeGTE != nil {
		predicates = append(predicates, odometerreading.ReadingTimeGTE(*i.ReadingTimeGTE))
	}
	if i.ReadingTimeLT != nil {
		predicates = append(predicates, odometerreading.ReadingTimeLT(*i.ReadingTimeLT))
	}
	if i.ReadingTimeLTE != nil {
		predicates = append(predicates, odometerreading.ReadingTimeLTE(*i.ReadingTimeLTE))
	}
	if i.Notes != nil {
		predicates = append(predicates, odometerreading.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, odometerreading.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, odometerreading.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, odometerreading.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, odometerreading.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, odometerreading.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, odometerreading.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, odometerreading.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, odometerreading.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, odometerreading.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, odometerreading.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesIsNil {
		predicates = append(predicates, odometerreading.NotesIsNil())
	}
	if i.NotesNotNil {
		predicates = append(predicates, odometerreading.NotesNotNil())
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, odometerreading.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, odometerreading.NotesContainsFold(*i.NotesContainsFold))
	}

	if i.HasCar != nil {
		p := odometerreading.HasCar()
		if !*i.HasCar {
			p = odometerreading.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, odometerreading.HasCarWith(with...))
	}
	if i.HasFuelUp != nil {
		p := odometerreading.HasFuelUp()
		if !*i.HasFuelUp {
			p = odometerreading.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFuelUpWith) > 0 {
		with := make([]predicate.FuelUp, 0, len(i.HasFuelUpWith))
		for _, w := range i.HasFuelUpWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFuelUpWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, odometerreading.HasFuelUpWith(with...))
	}
	if i.HasServiceLog != nil {
		p := odometerreading.HasServiceLog()
		if !*i.HasServiceLog {
			p = odometerreading.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServiceLogWith) > 0 {
		with := make([]predicate.ServiceLog, 0, len(i.HasServiceLogWith))
		for _, w := range i.HasServiceLogWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServiceLogWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, odometerreading.HasServiceLogWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOdometerReadingWhereInput
	case 1:
		return predicates[0], nil
	default:
		return odometerreading.And(predicates...), nil
	}
}

// ProfileWhereInput represents a where input for filtering Profile queries.
type ProfileWhereInput struct {
	Predicates []predicate.Profile  `json:"-"`
	Not        *ProfileWhereInput   `json:"not,omitempty"`
	Or         []*ProfileWhereInput `json:"or,omitempty"`
	And        []*ProfileWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "username" field predicates.
	Username             *string  `json:"username,omitempty"`
	UsernameNEQ          *string  `json:"usernameNEQ,omitempty"`
	UsernameIn           []string `json:"usernameIn,omitempty"`
	UsernameNotIn        []string `json:"usernameNotIn,omitempty"`
	UsernameGT           *string  `json:"usernameGT,omitempty"`
	UsernameGTE          *string  `json:"usernameGTE,omitempty"`
	UsernameLT           *string  `json:"usernameLT,omitempty"`
	UsernameLTE          *string  `json:"usernameLTE,omitempty"`
	UsernameContains     *string  `json:"usernameContains,omitempty"`
	UsernameHasPrefix    *string  `json:"usernameHasPrefix,omitempty"`
	UsernameHasSuffix    *string  `json:"usernameHasSuffix,omitempty"`
	UsernameIsNil        bool     `json:"usernameIsNil,omitempty"`
	UsernameNotNil       bool     `json:"usernameNotNil,omitempty"`
	UsernameEqualFold    *string  `json:"usernameEqualFold,omitempty"`
	UsernameContainsFold *string  `json:"usernameContainsFold,omitempty"`

	// "first_name" field predicates.
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNEQ          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGT           *string  `json:"firstNameGT,omitempty"`
	FirstNameGTE          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLT           *string  `json:"firstNameLT,omitempty"`
	FirstNameLTE          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameIsNil        bool     `json:"firstNameIsNil,omitempty"`
	FirstNameNotNil       bool     `json:"firstNameNotNil,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`

	// "last_name" field predicates.
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNEQ          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGT           *string  `json:"lastNameGT,omitempty"`
	LastNameGTE          *string  `json:"lastNameGTE,omitempty"`
	LastNameLT           *string  `json:"lastNameLT,omitempty"`
	LastNameLTE          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        bool     `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       bool     `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`

	// "visibility" field predicates.
	Visibility      *profile.Visibility  `json:"visibility,omitempty"`
	VisibilityNEQ   *profile.Visibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn    []profile.Visibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn []profile.Visibility `json:"visibilityNotIn,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProfileWhereInput) AddPredicates(predicates ...predicate.Profile) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProfileWhereInput filter on the ProfileQuery builder.
func (i *ProfileWhereInput) Filter(q *ProfileQuery) (*ProfileQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProfileWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProfileWhereInput is returned in case the ProfileWhereInput is empty.
var ErrEmptyProfileWhereInput = errors.New("ent: empty predicate ProfileWhereInput")

// P returns a predicate for filtering profiles.
// An error is returned if the input is empty or invalid.
func (i *ProfileWhereInput) P() (predicate.Profile, error) {
	var predicates []predicate.Profile
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, profile.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Profile, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, profile.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Profile, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, profile.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, profile.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, profile.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, profile.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, profile.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, profile.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, profile.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, profile.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, profile.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, profile.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, profile.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, profile.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, profile.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, profile.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, profile.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, profile.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, profile.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, profile.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, profile.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, profile.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, profile.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, profile.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, profile.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, profile.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, profile.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Username != nil {
		predicates = append(predicates, profile.UsernameEQ(*i.Username))
	}
	if i.UsernameNEQ != nil {
		predicates = append(predicates, profile.UsernameNEQ(*i.UsernameNEQ))
	}
	if len(i.UsernameIn) > 0 {
		predicates = append(predicates, profile.UsernameIn(i.UsernameIn...))
	}
	if len(i.UsernameNotIn) > 0 {
		predicates = append(predicates, profile.UsernameNotIn(i.UsernameNotIn...))
	}
	if i.UsernameGT != nil {
		predicates = append(predicates, profile.UsernameGT(*i.UsernameGT))
	}
	if i.UsernameGTE != nil {
		predicates = append(predicates, profile.UsernameGTE(*i.UsernameGTE))
	}
	if i.UsernameLT != nil {
		predicates = append(predicates, profile.UsernameLT(*i.UsernameLT))
	}
	if i.UsernameLTE != nil {
		predicates = append(predicates, profile.UsernameLTE(*i.UsernameLTE))
	}
	if i.UsernameContains != nil {
		predicates = append(predicates, profile.UsernameContains(*i.UsernameContains))
	}
	if i.UsernameHasPrefix != nil {
		predicates = append(predicates, profile.UsernameHasPrefix(*i.UsernameHasPrefix))
	}
	if i.UsernameHasSuffix != nil {
		predicates = append(predicates, profile.UsernameHasSuffix(*i.UsernameHasSuffix))
	}
	if i.UsernameIsNil {
		predicates = append(predicates, profile.UsernameIsNil())
	}
	if i.UsernameNotNil {
		predicates = append(predicates, profile.UsernameNotNil())
	}
	if i.UsernameEqualFold != nil {
		predicates = append(predicates, profile.UsernameEqualFold(*i.UsernameEqualFold))
	}
	if i.UsernameContainsFold != nil {
		predicates = append(predicates, profile.UsernameContainsFold(*i.UsernameContainsFold))
	}
	if i.FirstName != nil {
		predicates = append(predicates, profile.FirstNameEQ(*i.FirstName))
	}
	if i.FirstNameNEQ != nil {
		predicates = append(predicates, profile.FirstNameNEQ(*i.FirstNameNEQ))
	}
	if len(i.FirstNameIn) > 0 {
		predicates = append(predicates, profile.FirstNameIn(i.FirstNameIn...))
	}
	if len(i.FirstNameNotIn) > 0 {
		predicates = append(predicates, profile.FirstNameNotIn(i.FirstNameNotIn...))
	}
	if i.FirstNameGT != nil {
		predicates = append(predicates, profile.FirstNameGT(*i.FirstNameGT))
	}
	if i.FirstNameGTE != nil {
		predicates = append(predicates, profile.FirstNameGTE(*i.FirstNameGTE))
	}
	if i.FirstNameLT != nil {
		predicates = append(predicates, profile.FirstNameLT(*i.FirstNameLT))
	}
	if i.FirstNameLTE != nil {
		predicates = append(predicates, profile.FirstNameLTE(*i.FirstNameLTE))
	}
	if i.FirstNameContains != nil {
		predicates = append(predicates, profile.FirstNameContains(*i.FirstNameContains))
	}
	if i.FirstNameHasPrefix != nil {
		predicates = append(predicates, profile.FirstNameHasPrefix(*i.FirstNameHasPrefix))
	}
	if i.FirstNameHasSuffix != nil {
		predicates = append(predicates, profile.FirstNameHasSuffix(*i.FirstNameHasSuffix))
	}
	if i.FirstNameIsNil {
		predicates = append(predicates, profile.FirstNameIsNil())
	}
	if i.FirstNameNotNil {
		predicates = append(predicates, profile.FirstNameNotNil())
	}
	if i.FirstNameEqualFold != nil {
		predicates = append(predicates, profile.FirstNameEqualFold(*i.FirstNameEqualFold))
	}
	if i.FirstNameContainsFold != nil {
		predicates = append(predicates, profile.FirstNameContainsFold(*i.FirstNameContainsFold))
	}
	if i.LastName != nil {
		predicates = append(predicates, profile.LastNameEQ(*i.LastName))
	}
	if i.LastNameNEQ != nil {
		predicates = append(predicates, profile.LastNameNEQ(*i.LastNameNEQ))
	}
	if len(i.LastNameIn) > 0 {
		predicates = append(predicates, profile.LastNameIn(i.LastNameIn...))
	}
	if len(i.LastNameNotIn) > 0 {
		predicates = append(predicates, profile.LastNameNotIn(i.LastNameNotIn...))
	}
	if i.LastNameGT != nil {
		predicates = append(predicates, profile.LastNameGT(*i.LastNameGT))
	}
	if i.LastNameGTE != nil {
		predicates = append(predicates, profile.LastNameGTE(*i.LastNameGTE))
	}
	if i.LastNameLT != nil {
		predicates = append(predicates, profile.LastNameLT(*i.LastNameLT))
	}
	if i.LastNameLTE != nil {
		predicates = append(predicates, profile.LastNameLTE(*i.LastNameLTE))
	}
	if i.LastNameContains != nil {
		predicates = append(predicates, profile.LastNameContains(*i.LastNameContains))
	}
	if i.LastNameHasPrefix != nil {
		predicates = append(predicates, profile.LastNameHasPrefix(*i.LastNameHasPrefix))
	}
	if i.LastNameHasSuffix != nil {
		predicates = append(predicates, profile.LastNameHasSuffix(*i.LastNameHasSuffix))
	}
	if i.LastNameIsNil {
		predicates = append(predicates, profile.LastNameIsNil())
	}
	if i.LastNameNotNil {
		predicates = append(predicates, profile.LastNameNotNil())
	}
	if i.LastNameEqualFold != nil {
		predicates = append(predicates, profile.LastNameEqualFold(*i.LastNameEqualFold))
	}
	if i.LastNameContainsFold != nil {
		predicates = append(predicates, profile.LastNameContainsFold(*i.LastNameContainsFold))
	}
	if i.Visibility != nil {
		predicates = append(predicates, profile.VisibilityEQ(*i.Visibility))
	}
	if i.VisibilityNEQ != nil {
		predicates = append(predicates, profile.VisibilityNEQ(*i.VisibilityNEQ))
	}
	if len(i.VisibilityIn) > 0 {
		predicates = append(predicates, profile.VisibilityIn(i.VisibilityIn...))
	}
	if len(i.VisibilityNotIn) > 0 {
		predicates = append(predicates, profile.VisibilityNotIn(i.VisibilityNotIn...))
	}

	if i.HasUser != nil {
		p := profile.HasUser()
		if !*i.HasUser {
			p = profile.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, profile.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProfileWhereInput
	case 1:
		return predicates[0], nil
	default:
		return profile.And(predicates...), nil
	}
}

// ServiceItemWhereInput represents a where input for filtering ServiceItem queries.
type ServiceItemWhereInput struct {
	Predicates []predicate.ServiceItem  `json:"-"`
	Not        *ServiceItemWhereInput   `json:"not,omitempty"`
	Or         []*ServiceItemWhereInput `json:"or,omitempty"`
	And        []*ServiceItemWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "estimated_minutes" field predicates.
	EstimatedMinutes       *int  `json:"estimatedMinutes,omitempty"`
	EstimatedMinutesNEQ    *int  `json:"estimatedMinutesNEQ,omitempty"`
	EstimatedMinutesIn     []int `json:"estimatedMinutesIn,omitempty"`
	EstimatedMinutesNotIn  []int `json:"estimatedMinutesNotIn,omitempty"`
	EstimatedMinutesGT     *int  `json:"estimatedMinutesGT,omitempty"`
	EstimatedMinutesGTE    *int  `json:"estimatedMinutesGTE,omitempty"`
	EstimatedMinutesLT     *int  `json:"estimatedMinutesLT,omitempty"`
	EstimatedMinutesLTE    *int  `json:"estimatedMinutesLTE,omitempty"`
	EstimatedMinutesIsNil  bool  `json:"estimatedMinutesIsNil,omitempty"`
	EstimatedMinutesNotNil bool  `json:"estimatedMinutesNotNil,omitempty"`

	// "default_interval_km" field predicates.
	DefaultIntervalKm       *float64  `json:"defaultIntervalKm,omitempty"`
	DefaultIntervalKmNEQ    *float64  `json:"defaultIntervalKmNEQ,omitempty"`
	DefaultIntervalKmIn     []float64 `json:"defaultIntervalKmIn,omitempty"`
	DefaultIntervalKmNotIn  []float64 `json:"defaultIntervalKmNotIn,omitempty"`
	DefaultIntervalKmGT     *float64  `json:"defaultIntervalKmGT,omitempty"`
	DefaultIntervalKmGTE    *float64  `json:"defaultIntervalKmGTE,omitempty"`
	DefaultIntervalKmLT     *float64  `json:"defaultIntervalKmLT,omitempty"`
	DefaultIntervalKmLTE    *float64  `json:"defaultIntervalKmLTE,omitempty"`
	DefaultIntervalKmIsNil  bool      `json:"defaultIntervalKmIsNil,omitempty"`
	DefaultIntervalKmNotNil bool      `json:"defaultIntervalKmNotNil,omitempty"`

	// "default_interval_months" field predicates.
	DefaultIntervalMonths       *int  `json:"defaultIntervalMonths,omitempty"`
	DefaultIntervalMonthsNEQ    *int  `json:"defaultIntervalMonthsNEQ,omitempty"`
	DefaultIntervalMonthsIn     []int `json:"defaultIntervalMonthsIn,omitempty"`
	DefaultIntervalMonthsNotIn  []int `json:"defaultIntervalMonthsNotIn,omitempty"`
	DefaultIntervalMonthsGT     *int  `json:"defaultIntervalMonthsGT,omitempty"`
	DefaultIntervalMonthsGTE    *int  `json:"defaultIntervalMonthsGTE,omitempty"`
	DefaultIntervalMonthsLT     *int  `json:"defaultIntervalMonthsLT,omitempty"`
	DefaultIntervalMonthsLTE    *int  `json:"defaultIntervalMonthsLTE,omitempty"`
	DefaultIntervalMonthsIsNil  bool  `json:"defaultIntervalMonthsIsNil,omitempty"`
	DefaultIntervalMonthsNotNil bool  `json:"defaultIntervalMonthsNotNil,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesIsNil        bool     `json:"notesIsNil,omitempty"`
	NotesNotNil       bool     `json:"notesNotNil,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "schedules" edge predicates.
	HasSchedules     *bool                        `json:"hasSchedules,omitempty"`
	HasSchedulesWith []*ServiceScheduleWhereInput `json:"hasSchedulesWith,omitempty"`

	// "logs" edge predicates.
	HasLogs     *bool                   `json:"hasLogs,omitempty"`
	HasLogsWith []*ServiceLogWhereInput `json:"hasLogsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServiceItemWhereInput) AddPredicates(predicates ...predicate.ServiceItem) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServiceItemWhereInput filter on the ServiceItemQuery builder.
func (i *ServiceItemWhereInput) Filter(q *ServiceItemQuery) (*ServiceItemQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServiceItemWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServiceItemWhereInput is returned in case the ServiceItemWhereInput is empty.
var ErrEmptyServiceItemWhereInput = errors.New("ent: empty predicate ServiceItemWhereInput")

// P returns a predicate for filtering serviceitems.
// An error is returned if the input is empty or invalid.
func (i *ServiceItemWhereInput) P() (predicate.ServiceItem, error) {
	var predicates []predicate.ServiceItem
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, serviceitem.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServiceItem, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, serviceitem.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServiceItem, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, serviceitem.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, serviceitem.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, serviceitem.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, serviceitem.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, serviceitem.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, serviceitem.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, serviceitem.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, serviceitem.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, serviceitem.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, serviceitem.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, serviceitem.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, serviceitem.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, serviceitem.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, serviceitem.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, serviceitem.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, serviceitem.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, serviceitem.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, serviceitem.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, serviceitem.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, serviceitem.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, serviceitem.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, serviceitem.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, serviceitem.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, serviceitem.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, serviceitem.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, serviceitem.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, serviceitem.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, serviceitem.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, serviceitem.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, serviceitem.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, serviceitem.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, serviceitem.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, serviceitem.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, serviceitem.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, serviceitem.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, serviceitem.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, serviceitem.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, serviceitem.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.EstimatedMinutes != nil {
		predicates = append(predicates, serviceitem.EstimatedMinutesEQ(*i.EstimatedMinutes))
	}
	if i.EstimatedMinutesNEQ != nil {
		predicates = append(predicates, serviceitem.EstimatedMinutesNEQ(*i.EstimatedMinutesNEQ))
	}
	if len(i.EstimatedMinutesIn) > 0 {
		predicates = append(predicates, serviceitem.EstimatedMinutesIn(i.EstimatedMinutesIn...))
	}
	if len(i.EstimatedMinutesNotIn) > 0 {
		predicates = append(predicates, serviceitem.EstimatedMinutesNotIn(i.EstimatedMinutesNotIn...))
	}
	if i.EstimatedMinutesGT != nil {
		predicates = append(predicates, serviceitem.EstimatedMinutesGT(*i.EstimatedMinutesGT))
	}
	if i.EstimatedMinutesGTE != nil {
		predicates = append(predicates, serviceitem.EstimatedMinutesGTE(*i.EstimatedMinutesGTE))
	}
	if i.EstimatedMinutesLT != nil {
		predicates = append(predicates, serviceitem.EstimatedMinutesLT(*i.EstimatedMinutesLT))
	}
	if i.EstimatedMinutesLTE != nil {
		predicates = append(predicates, serviceitem.EstimatedMinutesLTE(*i.EstimatedMinutesLTE))
	}
	if i.EstimatedMinutesIsNil {
		predicates = append(predicates, serviceitem.EstimatedMinutesIsNil())
	}
	if i.EstimatedMinutesNotNil {
		predicates = append(predicates, serviceitem.EstimatedMinutesNotNil())
	}
	if i.DefaultIntervalKm != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalKmEQ(*i.DefaultIntervalKm))
	}
	if i.DefaultIntervalKmNEQ != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalKmNEQ(*i.DefaultIntervalKmNEQ))
	}
	if len(i.DefaultIntervalKmIn) > 0 {
		predicates = append(predicates, serviceitem.DefaultIntervalKmIn(i.DefaultIntervalKmIn...))
	}
	if len(i.DefaultIntervalKmNotIn) > 0 {
		predicates = append(predicates, serviceitem.DefaultIntervalKmNotIn(i.DefaultIntervalKmNotIn...))
	}
	if i.DefaultIntervalKmGT != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalKmGT(*i.DefaultIntervalKmGT))
	}
	if i.DefaultIntervalKmGTE != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalKmGTE(*i.DefaultIntervalKmGTE))
	}
	if i.DefaultIntervalKmLT != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalKmLT(*i.DefaultIntervalKmLT))
	}
	if i.DefaultIntervalKmLTE != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalKmLTE(*i.DefaultIntervalKmLTE))
	}
	if i.DefaultIntervalKmIsNil {
		predicates = append(predicates, serviceitem.DefaultIntervalKmIsNil())
	}
	if i.DefaultIntervalKmNotNil {
		predicates = append(predicates, serviceitem.DefaultIntervalKmNotNil())
	}
	if i.DefaultIntervalMonths != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsEQ(*i.DefaultIntervalMonths))
	}
	if i.DefaultIntervalMonthsNEQ != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsNEQ(*i.DefaultIntervalMonthsNEQ))
	}
	if len(i.DefaultIntervalMonthsIn) > 0 {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsIn(i.DefaultIntervalMonthsIn...))
	}
	if len(i.DefaultIntervalMonthsNotIn) > 0 {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsNotIn(i.DefaultIntervalMonthsNotIn...))
	}
	if i.DefaultIntervalMonthsGT != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsGT(*i.DefaultIntervalMonthsGT))
	}
	if i.DefaultIntervalMonthsGTE != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsGTE(*i.DefaultIntervalMonthsGTE))
	}
	if i.DefaultIntervalMonthsLT != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsLT(*i.DefaultIntervalMonthsLT))
	}
	if i.DefaultIntervalMonthsLTE != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsLTE(*i.DefaultIntervalMonthsLTE))
	}
	if i.DefaultIntervalMonthsIsNil {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsIsNil())
	}
	if i.DefaultIntervalMonthsNotNil {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsNotNil())
	}
	if i.Notes != nil {
		predicates = append(predicates, serviceitem.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, serviceitem.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, serviceitem.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, serviceitem.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, serviceitem.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, serviceitem.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, serviceitem.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, serviceitem.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, serviceitem.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, serviceitem.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, serviceitem.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesIsNil {
		predicates = append(predicates, serviceitem.NotesIsNil())
	}
	if i.NotesNotNil {
		predicates = append(predicates, serviceitem.NotesNotNil())
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, serviceitem.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, serviceitem.NotesContainsFold(*i.NotesContainsFold))
	}

	if i.HasCar != nil {
		p := serviceitem.HasCar()
		if !*i.HasCar {
			p = serviceitem.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serviceitem.HasCarWith(with...))
	}
	if i.HasSchedules != nil {
		p := serviceitem.HasSchedules()
		if !*i.HasSchedules {
			p = serviceitem.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSchedulesWith) > 0 {
		with := make([]predicate.ServiceSchedule, 0, len(i.HasSchedulesWith))
		for _, w := range i.HasSchedulesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSchedulesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serviceitem.HasSchedulesWith(with...))
	}
	if i.HasLogs != nil {
		p := serviceitem.HasLogs()
		if !*i.HasLogs {
			p = serviceitem.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLogsWith) > 0 {
		with := make([]predicate.ServiceLog, 0, len(i.HasLogsWith))
		for _, w := range i.HasLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serviceitem.HasLogsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServiceItemWhereInput
	case 1:
		return predicates[0], nil
	default:
		return serviceitem.And(predicates...), nil
	}
}

// ServiceLogWhereInput represents a where input for filtering ServiceLog queries.
type ServiceLogWhereInput struct {
	Predicates []predicate.ServiceLog  `json:"-"`
	Not        *ServiceLogWhereInput   `json:"not,omitempty"`
	Or         []*ServiceLogWhereInput `json:"or,omitempty"`
	And        []*ServiceLogWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "date_performed" field predicates.
	DatePerformed      *time.Time  `json:"datePerformed,omitempty"`
	DatePerformedNEQ   *time.Time  `json:"datePerformedNEQ,omitempty"`
	DatePerformedIn    []time.Time `json:"datePerformedIn,omitempty"`
	DatePerformedNotIn []time.Time `json:"datePerformedNotIn,omitempty"`
	DatePerformedGT    *time.Time  `json:"datePerformedGT,omitempty"`
	DatePerformedGTE   *time.Time  `json:"datePerformedGTE,omitempty"`
	DatePerformedLT    *time.Time  `json:"datePerformedLT,omitempty"`
	DatePerformedLTE   *time.Time  `json:"datePerformedLTE,omitempty"`

	// "performed_by" field predicates.
	PerformedBy             *string  `json:"performedBy,omitempty"`
	PerformedByNEQ          *string  `json:"performedByNEQ,omitempty"`
	PerformedByIn           []string `json:"performedByIn,omitempty"`
	PerformedByNotIn        []string `json:"performedByNotIn,omitempty"`
	PerformedByGT           *string  `json:"performedByGT,omitempty"`
	PerformedByGTE          *string  `json:"performedByGTE,omitempty"`
	PerformedByLT           *string  `json:"performedByLT,omitempty"`
	PerformedByLTE          *string  `json:"performedByLTE,omitempty"`
	PerformedByContains     *string  `json:"performedByContains,omitempty"`
	PerformedByHasPrefix    *string  `json:"performedByHasPrefix,omitempty"`
	PerformedByHasSuffix    *string  `json:"performedByHasSuffix,omitempty"`
	PerformedByIsNil        bool     `json:"performedByIsNil,omitempty"`
	PerformedByNotNil       bool     `json:"performedByNotNil,omitempty"`
	PerformedByEqualFold    *string  `json:"performedByEqualFold,omitempty"`
	PerformedByContainsFold *string  `json:"performedByContainsFold,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesIsNil        bool     `json:"notesIsNil,omitempty"`
	NotesNotNil       bool     `json:"notesNotNil,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "items" edge predicates.
	HasItems     *bool                    `json:"hasItems,omitempty"`
	HasItemsWith []*ServiceItemWhereInput `json:"hasItemsWith,omitempty"`

	// "schedule" edge predicates.
	HasSchedule     *bool                        `json:"hasSchedule,omitempty"`
	HasScheduleWith []*ServiceScheduleWhereInput `json:"hasScheduleWith,omitempty"`

	// "odometer_reading" edge predicates.
	HasOdometerReading     *bool                        `json:"hasOdometerReading,omitempty"`
	HasOdometerReadingWith []*OdometerReadingWhereInput `json:"hasOdometerReadingWith,omitempty"`

	// "expense" edge predicates.
	HasExpense     *bool                `json:"hasExpense,omitempty"`
	HasExpenseWith []*ExpenseWhereInput `json:"hasExpenseWith,omitempty"`

	// "documents" edge predicates.
	HasDocuments     *bool                 `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentWhereInput `json:"hasDocumentsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServiceLogWhereInput) AddPredicates(predicates ...predicate.ServiceLog) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServiceLogWhereInput filter on the ServiceLogQuery builder.
func (i *ServiceLogWhereInput) Filter(q *ServiceLogQuery) (*ServiceLogQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServiceLogWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServiceLogWhereInput is returned in case the ServiceLogWhereInput is empty.
var ErrEmptyServiceLogWhereInput = errors.New("ent: empty predicate ServiceLogWhereInput")

// P returns a predicate for filtering servicelogs.
// An error is returned if the input is empty or invalid.
func (i *ServiceLogWhereInput) P() (predicate.ServiceLog, error) {
	var predicates []predicate.ServiceLog
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servicelog.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServiceLog, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servicelog.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServiceLog, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servicelog.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servicelog.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servicelog.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servicelog.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servicelog.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servicelog.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servicelog.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servicelog.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servicelog.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, servicelog.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, servicelog.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, servicelog.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, servicelog.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, servicelog.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, servicelog.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, servicelog.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, servicelog.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, servicelog.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, servicelog.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, servicelog.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, servicelog.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, servicelog.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, servicelog.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, servicelog.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, servicelog.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.DatePerformed != nil {
		predicates = append(predicates, servicelog.DatePerformedEQ(*i.DatePerformed))
	}
	if i.DatePerformedNEQ != nil {
		predicates = append(predicates, servicelog.DatePerformedNEQ(*i.DatePerformedNEQ))
	}
	if len(i.DatePerformedIn) > 0 {
		predicates = append(predicates, servicelog.DatePerformedIn(i.DatePerformedIn...))
	}
	if len(i.DatePerformedNotIn) > 0 {
		predicates = append(predicates, servicelog.DatePerformedNotIn(i.DatePerformedNotIn...))
	}
	if i.DatePerformedGT != nil {
		predicates = append(predicates, servicelog.DatePerformedGT(*i.DatePerformedGT))
	}
	if i.DatePerformedGTE != nil {
		predicates = append(predicates, servicelog.DatePerformedGTE(*i.DatePerformedGTE))
	}
	if i.DatePerformedLT != nil {
		predicates = append(predicates, servicelog.DatePerformedLT(*i.DatePerformedLT))
	}
	if i.DatePerformedLTE != nil {
		predicates = append(predicates, servicelog.DatePerformedLTE(*i.DatePerformedLTE))
	}
	if i.PerformedBy != nil {
		predicates = append(predicates, servicelog.PerformedByEQ(*i.PerformedBy))
	}
	if i.PerformedByNEQ != nil {
		predicates = append(predicates, servicelog.PerformedByNEQ(*i.PerformedByNEQ))
	}
	if len(i.PerformedByIn) > 0 {
		predicates = append(predicates, servicelog.PerformedByIn(i.PerformedByIn...))
	}
	if len(i.PerformedByNotIn) > 0 {
		predicates = append(predicates, servicelog.PerformedByNotIn(i.PerformedByNotIn...))
	}
	if i.PerformedByGT != nil {
		predicates = append(predicates, servicelog.PerformedByGT(*i.PerformedByGT))
	}
	if i.PerformedByGTE != nil {
		predicates = append(predicates, servicelog.PerformedByGTE(*i.PerformedByGTE))
	}
	if i.PerformedByLT != nil {
		predicates = append(predicates, servicelog.PerformedByLT(*i.PerformedByLT))
	}
	if i.PerformedByLTE != nil {
		predicates = append(predicates, servicelog.PerformedByLTE(*i.PerformedByLTE))
	}
	if i.PerformedByContains != nil {
		predicates = append(predicates, servicelog.PerformedByContains(*i.PerformedByContains))
	}
	if i.PerformedByHasPrefix != nil {
		predicates = append(predicates, servicelog.PerformedByHasPrefix(*i.PerformedByHasPrefix))
	}
	if i.PerformedByHasSuffix != nil {
		predicates = append(predicates, servicelog.PerformedByHasSuffix(*i.PerformedByHasSuffix))
	}
	if i.PerformedByIsNil {
		predicates = append(predicates, servicelog.PerformedByIsNil())
	}
	if i.PerformedByNotNil {
		predicates = append(predicates, servicelog.PerformedByNotNil())
	}
	if i.PerformedByEqualFold != nil {
		predicates = append(predicates, servicelog.PerformedByEqualFold(*i.PerformedByEqualFold))
	}
	if i.PerformedByContainsFold != nil {
		predicates = append(predicates, servicelog.PerformedByContainsFold(*i.PerformedByContainsFold))
	}
	if i.Notes != nil {
		predicates = append(predicates, servicelog.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, servicelog.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, servicelog.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, servicelog.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, servicelog.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, servicelog.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, servicelog.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, servicelog.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, servicelog.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, servicelog.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, servicelog.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesIsNil {
		predicates = append(predicates, servicelog.NotesIsNil())
	}
	if i.NotesNotNil {
		predicates = append(predicates, servicelog.NotesNotNil())
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, servicelog.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, servicelog.NotesContainsFold(*i.NotesContainsFold))
	}

	if i.HasCar != nil {
		p := servicelog.HasCar()
		if !*i.HasCar {
			p = servicelog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servicelog.HasCarWith(with...))
	}
	if i.HasItems != nil {
		p := servicelog.HasItems()
		if !*i.HasItems {
			p = servicelog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemsWith) > 0 {
		with := make([]predicate.ServiceItem, 0, len(i.HasItemsWith))
		for _, w := range i.HasItemsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasItemsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servicelog.HasItemsWith(with...))
	}
	if i.HasSchedule != nil {
		p := servicelog.HasSchedule()
		if !*i.HasSchedule {
			p = servicelog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasScheduleWith) > 0 {
		with := make([]predicate.ServiceSchedule, 0, len(i.HasScheduleWith))
		for _, w := range i.HasScheduleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasScheduleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servicelog.HasScheduleWith(with...))
	}
	if i.HasOdometerReading != nil {
		p := servicelog.HasOdometerReading()
		if !*i.HasOdometerReading {
			p = servicelog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOdometerReadingWith) > 0 {
		with := make([]predicate.OdometerReading, 0, len(i.HasOdometerReadingWith))
		for _, w := range i.HasOdometerReadingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOdometerReadingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servicelog.HasOdometerReadingWith(with...))
	}
	if i.HasExpense != nil {
		p := servicelog.HasExpense()
		if !*i.HasExpense {
			p = servicelog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExpenseWith) > 0 {
		with := make([]predicate.Expense, 0, len(i.HasExpenseWith))
		for _, w := range i.HasExpenseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExpenseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servicelog.HasExpenseWith(with...))
	}
	if i.HasDocuments != nil {
		p := servicelog.HasDocuments()
		if !*i.HasDocuments {
			p = servicelog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDocumentsWith) > 0 {
		with := make([]predicate.Document, 0, len(i.HasDocumentsWith))
		for _, w := range i.HasDocumentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDocumentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servicelog.HasDocumentsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServiceLogWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servicelog.And(predicates...), nil
	}
}

// ServiceScheduleWhereInput represents a where input for filtering ServiceSchedule queries.
type ServiceScheduleWhereInput struct {
	Predicates []predicate.ServiceSchedule  `json:"-"`
	Not        *ServiceScheduleWhereInput   `json:"not,omitempty"`
	Or         []*ServiceScheduleWhereInput `json:"or,omitempty"`
	And        []*ServiceScheduleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "repeat_every_km" field predicates.
	RepeatEveryKm       *float64  `json:"repeatEveryKm,omitempty"`
	RepeatEveryKmNEQ    *float64  `json:"repeatEveryKmNEQ,omitempty"`
	RepeatEveryKmIn     []float64 `json:"repeatEveryKmIn,omitempty"`
	RepeatEveryKmNotIn  []float64 `json:"repeatEveryKmNotIn,omitempty"`
	RepeatEveryKmGT     *float64  `json:"repeatEveryKmGT,omitempty"`
	RepeatEveryKmGTE    *float64  `json:"repeatEveryKmGTE,omitempty"`
	RepeatEveryKmLT     *float64  `json:"repeatEveryKmLT,omitempty"`
	RepeatEveryKmLTE    *float64  `json:"repeatEveryKmLTE,omitempty"`
	RepeatEveryKmIsNil  bool      `json:"repeatEveryKmIsNil,omitempty"`
	RepeatEveryKmNotNil bool      `json:"repeatEveryKmNotNil,omitempty"`

	// "starts_at_km" field predicates.
	StartsAtKm       *float64  `json:"startsAtKm,omitempty"`
	StartsAtKmNEQ    *float64  `json:"startsAtKmNEQ,omitempty"`
	StartsAtKmIn     []float64 `json:"startsAtKmIn,omitempty"`
	StartsAtKmNotIn  []float64 `json:"startsAtKmNotIn,omitempty"`
	StartsAtKmGT     *float64  `json:"startsAtKmGT,omitempty"`
	StartsAtKmGTE    *float64  `json:"startsAtKmGTE,omitempty"`
	StartsAtKmLT     *float64  `json:"startsAtKmLT,omitempty"`
	StartsAtKmLTE    *float64  `json:"startsAtKmLTE,omitempty"`
	StartsAtKmIsNil  bool      `json:"startsAtKmIsNil,omitempty"`
	StartsAtKmNotNil bool      `json:"startsAtKmNotNil,omitempty"`

	// "repeat_every_months" field predicates.
	RepeatEveryMonths       *int  `json:"repeatEveryMonths,omitempty"`
	RepeatEveryMonthsNEQ    *int  `json:"repeatEveryMonthsNEQ,omitempty"`
	RepeatEveryMonthsIn     []int `json:"repeatEveryMonthsIn,omitempty"`
	RepeatEveryMonthsNotIn  []int `json:"repeatEveryMonthsNotIn,omitempty"`
	RepeatEveryMonthsGT     *int  `json:"repeatEveryMonthsGT,omitempty"`
	RepeatEveryMonthsGTE    *int  `json:"repeatEveryMonthsGTE,omitempty"`
	RepeatEveryMonthsLT     *int  `json:"repeatEveryMonthsLT,omitempty"`
	RepeatEveryMonthsLTE    *int  `json:"repeatEveryMonthsLTE,omitempty"`
	RepeatEveryMonthsIsNil  bool  `json:"repeatEveryMonthsIsNil,omitempty"`
	RepeatEveryMonthsNotNil bool  `json:"repeatEveryMonthsNotNil,omitempty"`

	// "starts_at_months" field predicates.
	StartsAtMonths       *int  `json:"startsAtMonths,omitempty"`
	StartsAtMonthsNEQ    *int  `json:"startsAtMonthsNEQ,omitempty"`
	StartsAtMonthsIn     []int `json:"startsAtMonthsIn,omitempty"`
	StartsAtMonthsNotIn  []int `json:"startsAtMonthsNotIn,omitempty"`
	StartsAtMonthsGT     *int  `json:"startsAtMonthsGT,omitempty"`
	StartsAtMonthsGTE    *int  `json:"startsAtMonthsGTE,omitempty"`
	StartsAtMonthsLT     *int  `json:"startsAtMonthsLT,omitempty"`
	StartsAtMonthsLTE    *int  `json:"startsAtMonthsLTE,omitempty"`
	StartsAtMonthsIsNil  bool  `json:"startsAtMonthsIsNil,omitempty"`
	StartsAtMonthsNotNil bool  `json:"startsAtMonthsNotNil,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesIsNil        bool     `json:"notesIsNil,omitempty"`
	NotesNotNil       bool     `json:"notesNotNil,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "archived" field predicates.
	Archived    *bool `json:"archived,omitempty"`
	ArchivedNEQ *bool `json:"archivedNEQ,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "items" edge predicates.
	HasItems     *bool                    `json:"hasItems,omitempty"`
	HasItemsWith []*ServiceItemWhereInput `json:"hasItemsWith,omitempty"`

	// "logs" edge predicates.
	HasLogs     *bool                   `json:"hasLogs,omitempty"`
	HasLogsWith []*ServiceLogWhereInput `json:"hasLogsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServiceScheduleWhereInput) AddPredicates(predicates ...predicate.ServiceSchedule) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServiceScheduleWhereInput filter on the ServiceScheduleQuery builder.
func (i *ServiceScheduleWhereInput) Filter(q *ServiceScheduleQuery) (*ServiceScheduleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServiceScheduleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServiceScheduleWhereInput is returned in case the ServiceScheduleWhereInput is empty.
var ErrEmptyServiceScheduleWhereInput = errors.New("ent: empty predicate ServiceScheduleWhereInput")

// P returns a predicate for filtering serviceschedules.
// An error is returned if the input is empty or invalid.
func (i *ServiceScheduleWhereInput) P() (predicate.ServiceSchedule, error) {
	var predicates []predicate.ServiceSchedule
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, serviceschedule.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServiceSchedule, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, serviceschedule.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServiceSchedule, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, serviceschedule.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, serviceschedule.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, serviceschedule.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, serviceschedule.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, serviceschedule.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, serviceschedule.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, serviceschedule.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, serviceschedule.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, serviceschedule.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, serviceschedule.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, serviceschedule.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, serviceschedule.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, serviceschedule.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, serviceschedule.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, serviceschedule.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, serviceschedule.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, serviceschedule.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, serviceschedule.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, serviceschedule.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, serviceschedule.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, serviceschedule.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, serviceschedule.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, serviceschedule.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, serviceschedule.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, serviceschedule.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, serviceschedule.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, serviceschedule.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, serviceschedule.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, serviceschedule.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, serviceschedule.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, serviceschedule.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, serviceschedule.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, serviceschedule.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, serviceschedule.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, serviceschedule.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, serviceschedule.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, serviceschedule.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, serviceschedule.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.RepeatEveryKm != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryKmEQ(*i.RepeatEveryKm))
	}
	if i.RepeatEveryKmNEQ != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryKmNEQ(*i.RepeatEveryKmNEQ))
	}
	if len(i.RepeatEveryKmIn) > 0 {
		predicates = append(predicates, serviceschedule.RepeatEveryKmIn(i.RepeatEveryKmIn...))
	}
	if len(i.RepeatEveryKmNotIn) > 0 {
		predicates = append(predicates, serviceschedule.RepeatEveryKmNotIn(i.RepeatEveryKmNotIn...))
	}
	if i.RepeatEveryKmGT != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryKmGT(*i.RepeatEveryKmGT))
	}
	if i.RepeatEveryKmGTE != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryKmGTE(*i.RepeatEveryKmGTE))
	}
	if i.RepeatEveryKmLT != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryKmLT(*i.RepeatEveryKmLT))
	}
	if i.RepeatEveryKmLTE != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryKmLTE(*i.RepeatEveryKmLTE))
	}
	if i.RepeatEveryKmIsNil {
		predicates = append(predicates, serviceschedule.RepeatEveryKmIsNil())
	}
	if i.RepeatEveryKmNotNil {
		predicates = append(predicates, serviceschedule.RepeatEveryKmNotNil())
	}
	if i.StartsAtKm != nil {
		predicates = append(predicates, serviceschedule.StartsAtKmEQ(*i.StartsAtKm))
	}
	if i.StartsAtKmNEQ != nil {
		predicates = append(predicates, serviceschedule.StartsAtKmNEQ(*i.StartsAtKmNEQ))
	}
	if len(i.StartsAtKmIn) > 0 {
		predicates = append(predicates, serviceschedule.StartsAtKmIn(i.StartsAtKmIn...))
	}
	if len(i.StartsAtKmNotIn) > 0 {
		predicates = append(predicates, serviceschedule.StartsAtKmNotIn(i.StartsAtKmNotIn...))
	}
	if i.StartsAtKmGT != nil {
		predicates = append(predicates, serviceschedule.StartsAtKmGT(*i.StartsAtKmGT))
	}
	if i.StartsAtKmGTE != nil {
		predicates = append(predicates, serviceschedule.StartsAtKmGTE(*i.StartsAtKmGTE))
	}
	if i.StartsAtKmLT != nil {
		predicates = append(predicates, serviceschedule.StartsAtKmLT(*i.StartsAtKmLT))
	}
	if i.StartsAtKmLTE != nil {
		predicates = append(predicates, serviceschedule.StartsAtKmLTE(*i.StartsAtKmLTE))
	}
	if i.StartsAtKmIsNil {
		predicates = append(predicates, serviceschedule.StartsAtKmIsNil())
	}
	if i.StartsAtKmNotNil {
		predicates = append(predicates, serviceschedule.StartsAtKmNotNil())
	}
	if i.RepeatEveryMonths != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsEQ(*i.RepeatEveryMonths))
	}
	if i.RepeatEveryMonthsNEQ != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsNEQ(*i.RepeatEveryMonthsNEQ))
	}
	if len(i.RepeatEveryMonthsIn) > 0 {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsIn(i.RepeatEveryMonthsIn...))
	}
	if len(i.RepeatEveryMonthsNotIn) > 0 {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsNotIn(i.RepeatEveryMonthsNotIn...))
	}
	if i.RepeatEveryMonthsGT != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsGT(*i.RepeatEveryMonthsGT))
	}
	if i.RepeatEveryMonthsGTE != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsGTE(*i.RepeatEveryMonthsGTE))
	}
	if i.RepeatEveryMonthsLT != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsLT(*i.RepeatEveryMonthsLT))
	}
	if i.RepeatEveryMonthsLTE != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsLTE(*i.RepeatEveryMonthsLTE))
	}
	if i.RepeatEveryMonthsIsNil {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsIsNil())
	}
	if i.RepeatEveryMonthsNotNil {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsNotNil())
	}
	if i.StartsAtMonths != nil {
		predicates = append(predicates, serviceschedule.StartsAtMonthsEQ(*i.StartsAtMonths))
	}
	if i.StartsAtMonthsNEQ != nil {
		predicates = append(predicates, serviceschedule.StartsAtMonthsNEQ(*i.StartsAtMonthsNEQ))
	}
	if len(i.StartsAtMonthsIn) > 0 {
		predicates = append(predicates, serviceschedule.StartsAtMonthsIn(i.StartsAtMonthsIn...))
	}
	if len(i.StartsAtMonthsNotIn) > 0 {
		predicates = append(predicates, serviceschedule.StartsAtMonthsNotIn(i.StartsAtMonthsNotIn...))
	}
	if i.StartsAtMonthsGT != nil {
		predicates = append(predicates, serviceschedule.StartsAtMonthsGT(*i.StartsAtMonthsGT))
	}
	if i.StartsAtMonthsGTE != nil {
		predicates = append(predicates, serviceschedule.StartsAtMonthsGTE(*i.StartsAtMonthsGTE))
	}
	if i.StartsAtMonthsLT != nil {
		predicates = append(predicates, serviceschedule.StartsAtMonthsLT(*i.StartsAtMonthsLT))
	}
	if i.StartsAtMonthsLTE != nil {
		predicates = append(predicates, serviceschedule.StartsAtMonthsLTE(*i.StartsAtMonthsLTE))
	}
	if i.StartsAtMonthsIsNil {
		predicates = append(predicates, serviceschedule.StartsAtMonthsIsNil())
	}
	if i.StartsAtMonthsNotNil {
		predicates = append(predicates, serviceschedule.StartsAtMonthsNotNil())
	}
	if i.Notes != nil {
		predicates = append(predicates, serviceschedule.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, serviceschedule.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, serviceschedule.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, serviceschedule.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, serviceschedule.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, serviceschedule.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, serviceschedule.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, serviceschedule.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, serviceschedule.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, serviceschedule.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, serviceschedule.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesIsNil {
		predicates = append(predicates, serviceschedule.NotesIsNil())
	}
	if i.NotesNotNil {
		predicates = append(predicates, serviceschedule.NotesNotNil())
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, serviceschedule.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, serviceschedule.NotesContainsFold(*i.NotesContainsFold))
	}
	if i.Archived != nil {
		predicates = append(predicates, serviceschedule.ArchivedEQ(*i.Archived))
	}
	if i.ArchivedNEQ != nil {
		predicates = append(predicates, serviceschedule.ArchivedNEQ(*i.ArchivedNEQ))
	}

	if i.HasCar != nil {
		p := serviceschedule.HasCar()
		if !*i.HasCar {
			p = serviceschedule.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serviceschedule.HasCarWith(with...))
	}
	if i.HasItems != nil {
		p := serviceschedule.HasItems()
		if !*i.HasItems {
			p = serviceschedule.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemsWith) > 0 {
		with := make([]predicate.ServiceItem, 0, len(i.HasItemsWith))
		for _, w := range i.HasItemsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasItemsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serviceschedule.HasItemsWith(with...))
	}
	if i.HasLogs != nil {
		p := serviceschedule.HasLogs()
		if !*i.HasLogs {
			p = serviceschedule.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLogsWith) > 0 {
		with := make([]predicate.ServiceLog, 0, len(i.HasLogsWith))
		for _, w := range i.HasLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serviceschedule.HasLogsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServiceScheduleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return serviceschedule.And(predicates...), nil
	}
}

// SubscriptionPlanWhereInput represents a where input for filtering Subscription queries.
type SubscriptionPlanWhereInput struct {
	Predicates []predicate.Subscription      `json:"-"`
	Not        *SubscriptionPlanWhereInput   `json:"not,omitempty"`
	Or         []*SubscriptionPlanWhereInput `json:"or,omitempty"`
	And        []*SubscriptionPlanWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "stripe_subscription_id" field predicates.
	StripeSubscriptionID             *string  `json:"stripeSubscriptionID,omitempty"`
	StripeSubscriptionIDNEQ          *string  `json:"stripeSubscriptionIDNEQ,omitempty"`
	StripeSubscriptionIDIn           []string `json:"stripeSubscriptionIDIn,omitempty"`
	StripeSubscriptionIDNotIn        []string `json:"stripeSubscriptionIDNotIn,omitempty"`
	StripeSubscriptionIDGT           *string  `json:"stripeSubscriptionIDGT,omitempty"`
	StripeSubscriptionIDGTE          *string  `json:"stripeSubscriptionIDGTE,omitempty"`
	StripeSubscriptionIDLT           *string  `json:"stripeSubscriptionIDLT,omitempty"`
	StripeSubscriptionIDLTE          *string  `json:"stripeSubscriptionIDLTE,omitempty"`
	StripeSubscriptionIDContains     *string  `json:"stripeSubscriptionIDContains,omitempty"`
	StripeSubscriptionIDHasPrefix    *string  `json:"stripeSubscriptionIDHasPrefix,omitempty"`
	StripeSubscriptionIDHasSuffix    *string  `json:"stripeSubscriptionIDHasSuffix,omitempty"`
	StripeSubscriptionIDIsNil        bool     `json:"stripeSubscriptionIDIsNil,omitempty"`
	StripeSubscriptionIDNotNil       bool     `json:"stripeSubscriptionIDNotNil,omitempty"`
	StripeSubscriptionIDEqualFold    *string  `json:"stripeSubscriptionIDEqualFold,omitempty"`
	StripeSubscriptionIDContainsFold *string  `json:"stripeSubscriptionIDContainsFold,omitempty"`

	// "tier" field predicates.
	Tier      *subscription.Tier  `json:"tier,omitempty"`
	TierNEQ   *subscription.Tier  `json:"tierNEQ,omitempty"`
	TierIn    []subscription.Tier `json:"tierIn,omitempty"`
	TierNotIn []subscription.Tier `json:"tierNotIn,omitempty"`

	// "status" field predicates.
	Status      *subscription.Status  `json:"status,omitempty"`
	StatusNEQ   *subscription.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []subscription.Status `json:"statusIn,omitempty"`
	StatusNotIn []subscription.Status `json:"statusNotIn,omitempty"`

	// "canceled_at" field predicates.
	CanceledAt       *time.Time  `json:"canceledAt,omitempty"`
	CanceledAtNEQ    *time.Time  `json:"canceledAtNEQ,omitempty"`
	CanceledAtIn     []time.Time `json:"canceledAtIn,omitempty"`
	CanceledAtNotIn  []time.Time `json:"canceledAtNotIn,omitempty"`
	CanceledAtGT     *time.Time  `json:"canceledAtGT,omitempty"`
	CanceledAtGTE    *time.Time  `json:"canceledAtGTE,omitempty"`
	CanceledAtLT     *time.Time  `json:"canceledAtLT,omitempty"`
	CanceledAtLTE    *time.Time  `json:"canceledAtLTE,omitempty"`
	CanceledAtIsNil  bool        `json:"canceledAtIsNil,omitempty"`
	CanceledAtNotNil bool        `json:"canceledAtNotNil,omitempty"`

	// "cancel_at_period_end" field predicates.
	CancelAtPeriodEnd    *bool `json:"cancelAtPeriodEnd,omitempty"`
	CancelAtPeriodEndNEQ *bool `json:"cancelAtPeriodEndNEQ,omitempty"`

	// "trial_end" field predicates.
	TrialEnd       *time.Time  `json:"trialEnd,omitempty"`
	TrialEndNEQ    *time.Time  `json:"trialEndNEQ,omitempty"`
	TrialEndIn     []time.Time `json:"trialEndIn,omitempty"`
	TrialEndNotIn  []time.Time `json:"trialEndNotIn,omitempty"`
	TrialEndGT     *time.Time  `json:"trialEndGT,omitempty"`
	TrialEndGTE    *time.Time  `json:"trialEndGTE,omitempty"`
	TrialEndLT     *time.Time  `json:"trialEndLT,omitempty"`
	TrialEndLTE    *time.Time  `json:"trialEndLTE,omitempty"`
	TrialEndIsNil  bool        `json:"trialEndIsNil,omitempty"`
	TrialEndNotNil bool        `json:"trialEndNotNil,omitempty"`

	// "affiliate_6mo_code" field predicates.
	Affiliate6moCode             *string  `json:"affiliate6moCode,omitempty"`
	Affiliate6moCodeNEQ          *string  `json:"affiliate6moCodeNEQ,omitempty"`
	Affiliate6moCodeIn           []string `json:"affiliate6moCodeIn,omitempty"`
	Affiliate6moCodeNotIn        []string `json:"affiliate6moCodeNotIn,omitempty"`
	Affiliate6moCodeGT           *string  `json:"affiliate6moCodeGT,omitempty"`
	Affiliate6moCodeGTE          *string  `json:"affiliate6moCodeGTE,omitempty"`
	Affiliate6moCodeLT           *string  `json:"affiliate6moCodeLT,omitempty"`
	Affiliate6moCodeLTE          *string  `json:"affiliate6moCodeLTE,omitempty"`
	Affiliate6moCodeContains     *string  `json:"affiliate6moCodeContains,omitempty"`
	Affiliate6moCodeHasPrefix    *string  `json:"affiliate6moCodeHasPrefix,omitempty"`
	Affiliate6moCodeHasSuffix    *string  `json:"affiliate6moCodeHasSuffix,omitempty"`
	Affiliate6moCodeIsNil        bool     `json:"affiliate6moCodeIsNil,omitempty"`
	Affiliate6moCodeNotNil       bool     `json:"affiliate6moCodeNotNil,omitempty"`
	Affiliate6moCodeEqualFold    *string  `json:"affiliate6moCodeEqualFold,omitempty"`
	Affiliate6moCodeContainsFold *string  `json:"affiliate6moCodeContainsFold,omitempty"`

	// "affiliate_12mo_code" field predicates.
	Affiliate12moCode             *string  `json:"affiliate12moCode,omitempty"`
	Affiliate12moCodeNEQ          *string  `json:"affiliate12moCodeNEQ,omitempty"`
	Affiliate12moCodeIn           []string `json:"affiliate12moCodeIn,omitempty"`
	Affiliate12moCodeNotIn        []string `json:"affiliate12moCodeNotIn,omitempty"`
	Affiliate12moCodeGT           *string  `json:"affiliate12moCodeGT,omitempty"`
	Affiliate12moCodeGTE          *string  `json:"affiliate12moCodeGTE,omitempty"`
	Affiliate12moCodeLT           *string  `json:"affiliate12moCodeLT,omitempty"`
	Affiliate12moCodeLTE          *string  `json:"affiliate12moCodeLTE,omitempty"`
	Affiliate12moCodeContains     *string  `json:"affiliate12moCodeContains,omitempty"`
	Affiliate12moCodeHasPrefix    *string  `json:"affiliate12moCodeHasPrefix,omitempty"`
	Affiliate12moCodeHasSuffix    *string  `json:"affiliate12moCodeHasSuffix,omitempty"`
	Affiliate12moCodeIsNil        bool     `json:"affiliate12moCodeIsNil,omitempty"`
	Affiliate12moCodeNotNil       bool     `json:"affiliate12moCodeNotNil,omitempty"`
	Affiliate12moCodeEqualFold    *string  `json:"affiliate12moCodeEqualFold,omitempty"`
	Affiliate12moCodeContainsFold *string  `json:"affiliate12moCodeContainsFold,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "checkout_session" edge predicates.
	HasCheckoutSession     *bool                        `json:"hasCheckoutSession,omitempty"`
	HasCheckoutSessionWith []*CheckoutSessionWhereInput `json:"hasCheckoutSessionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SubscriptionPlanWhereInput) AddPredicates(predicates ...predicate.Subscription) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SubscriptionPlanWhereInput filter on the SubscriptionQuery builder.
func (i *SubscriptionPlanWhereInput) Filter(q *SubscriptionQuery) (*SubscriptionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySubscriptionPlanWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySubscriptionPlanWhereInput is returned in case the SubscriptionPlanWhereInput is empty.
var ErrEmptySubscriptionPlanWhereInput = errors.New("ent: empty predicate SubscriptionPlanWhereInput")

// P returns a predicate for filtering subscriptions.
// An error is returned if the input is empty or invalid.
func (i *SubscriptionPlanWhereInput) P() (predicate.Subscription, error) {
	var predicates []predicate.Subscription
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, subscription.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Subscription, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, subscription.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Subscription, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, subscription.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, subscription.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, subscription.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, subscription.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, subscription.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, subscription.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, subscription.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, subscription.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, subscription.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, subscription.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, subscription.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, subscription.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, subscription.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, subscription.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, subscription.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, subscription.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, subscription.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, subscription.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, subscription.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, subscription.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, subscription.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, subscription.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, subscription.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, subscription.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, subscription.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.StripeSubscriptionID != nil {
		predicates = append(predicates, subscription.StripeSubscriptionIDEQ(*i.StripeSubscriptionID))
	}
	if i.StripeSubscriptionIDNEQ != nil {
		predicates = append(predicates, subscription.StripeSubscriptionIDNEQ(*i.StripeSubscriptionIDNEQ))
	}
	if len(i.StripeSubscriptionIDIn) > 0 {
		predicates = append(predicates, subscription.StripeSubscriptionIDIn(i.StripeSubscriptionIDIn...))
	}
	if len(i.StripeSubscriptionIDNotIn) > 0 {
		predicates = append(predicates, subscription.StripeSubscriptionIDNotIn(i.StripeSubscriptionIDNotIn...))
	}
	if i.StripeSubscriptionIDGT != nil {
		predicates = append(predicates, subscription.StripeSubscriptionIDGT(*i.StripeSubscriptionIDGT))
	}
	if i.StripeSubscriptionIDGTE != nil {
		predicates = append(predicates, subscription.StripeSubscriptionIDGTE(*i.StripeSubscriptionIDGTE))
	}
	if i.StripeSubscriptionIDLT != nil {
		predicates = append(predicates, subscription.StripeSubscriptionIDLT(*i.StripeSubscriptionIDLT))
	}
	if i.StripeSubscriptionIDLTE != nil {
		predicates = append(predicates, subscription.StripeSubscriptionIDLTE(*i.StripeSubscriptionIDLTE))
	}
	if i.StripeSubscriptionIDContains != nil {
		predicates = append(predicates, subscription.StripeSubscriptionIDContains(*i.StripeSubscriptionIDContains))
	}
	if i.StripeSubscriptionIDHasPrefix != nil {
		predicates = append(predicates, subscription.StripeSubscriptionIDHasPrefix(*i.StripeSubscriptionIDHasPrefix))
	}
	if i.StripeSubscriptionIDHasSuffix != nil {
		predicates = append(predicates, subscription.StripeSubscriptionIDHasSuffix(*i.StripeSubscriptionIDHasSuffix))
	}
	if i.StripeSubscriptionIDIsNil {
		predicates = append(predicates, subscription.StripeSubscriptionIDIsNil())
	}
	if i.StripeSubscriptionIDNotNil {
		predicates = append(predicates, subscription.StripeSubscriptionIDNotNil())
	}
	if i.StripeSubscriptionIDEqualFold != nil {
		predicates = append(predicates, subscription.StripeSubscriptionIDEqualFold(*i.StripeSubscriptionIDEqualFold))
	}
	if i.StripeSubscriptionIDContainsFold != nil {
		predicates = append(predicates, subscription.StripeSubscriptionIDContainsFold(*i.StripeSubscriptionIDContainsFold))
	}
	if i.Tier != nil {
		predicates = append(predicates, subscription.TierEQ(*i.Tier))
	}
	if i.TierNEQ != nil {
		predicates = append(predicates, subscription.TierNEQ(*i.TierNEQ))
	}
	if len(i.TierIn) > 0 {
		predicates = append(predicates, subscription.TierIn(i.TierIn...))
	}
	if len(i.TierNotIn) > 0 {
		predicates = append(predicates, subscription.TierNotIn(i.TierNotIn...))
	}
	if i.Status != nil {
		predicates = append(predicates, subscription.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, subscription.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, subscription.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, subscription.StatusNotIn(i.StatusNotIn...))
	}
	if i.CanceledAt != nil {
		predicates = append(predicates, subscription.CanceledAtEQ(*i.CanceledAt))
	}
	if i.CanceledAtNEQ != nil {
		predicates = append(predicates, subscription.CanceledAtNEQ(*i.CanceledAtNEQ))
	}
	if len(i.CanceledAtIn) > 0 {
		predicates = append(predicates, subscription.CanceledAtIn(i.CanceledAtIn...))
	}
	if len(i.CanceledAtNotIn) > 0 {
		predicates = append(predicates, subscription.CanceledAtNotIn(i.CanceledAtNotIn...))
	}
	if i.CanceledAtGT != nil {
		predicates = append(predicates, subscription.CanceledAtGT(*i.CanceledAtGT))
	}
	if i.CanceledAtGTE != nil {
		predicates = append(predicates, subscription.CanceledAtGTE(*i.CanceledAtGTE))
	}
	if i.CanceledAtLT != nil {
		predicates = append(predicates, subscription.CanceledAtLT(*i.CanceledAtLT))
	}
	if i.CanceledAtLTE != nil {
		predicates = append(predicates, subscription.CanceledAtLTE(*i.CanceledAtLTE))
	}
	if i.CanceledAtIsNil {
		predicates = append(predicates, subscription.CanceledAtIsNil())
	}
	if i.CanceledAtNotNil {
		predicates = append(predicates, subscription.CanceledAtNotNil())
	}
	if i.CancelAtPeriodEnd != nil {
		predicates = append(predicates, subscription.CancelAtPeriodEndEQ(*i.CancelAtPeriodEnd))
	}
	if i.CancelAtPeriodEndNEQ != nil {
		predicates = append(predicates, subscription.CancelAtPeriodEndNEQ(*i.CancelAtPeriodEndNEQ))
	}
	if i.TrialEnd != nil {
		predicates = append(predicates, subscription.TrialEndEQ(*i.TrialEnd))
	}
	if i.TrialEndNEQ != nil {
		predicates = append(predicates, subscription.TrialEndNEQ(*i.TrialEndNEQ))
	}
	if len(i.TrialEndIn) > 0 {
		predicates = append(predicates, subscription.TrialEndIn(i.TrialEndIn...))
	}
	if len(i.TrialEndNotIn) > 0 {
		predicates = append(predicates, subscription.TrialEndNotIn(i.TrialEndNotIn...))
	}
	if i.TrialEndGT != nil {
		predicates = append(predicates, subscription.TrialEndGT(*i.TrialEndGT))
	}
	if i.TrialEndGTE != nil {
		predicates = append(predicates, subscription.TrialEndGTE(*i.TrialEndGTE))
	}
	if i.TrialEndLT != nil {
		predicates = append(predicates, subscription.TrialEndLT(*i.TrialEndLT))
	}
	if i.TrialEndLTE != nil {
		predicates = append(predicates, subscription.TrialEndLTE(*i.TrialEndLTE))
	}
	if i.TrialEndIsNil {
		predicates = append(predicates, subscription.TrialEndIsNil())
	}
	if i.TrialEndNotNil {
		predicates = append(predicates, subscription.TrialEndNotNil())
	}
	if i.Affiliate6moCode != nil {
		predicates = append(predicates, subscription.Affiliate6moCodeEQ(*i.Affiliate6moCode))
	}
	if i.Affiliate6moCodeNEQ != nil {
		predicates = append(predicates, subscription.Affiliate6moCodeNEQ(*i.Affiliate6moCodeNEQ))
	}
	if len(i.Affiliate6moCodeIn) > 0 {
		predicates = append(predicates, subscription.Affiliate6moCodeIn(i.Affiliate6moCodeIn...))
	}
	if len(i.Affiliate6moCodeNotIn) > 0 {
		predicates = append(predicates, subscription.Affiliate6moCodeNotIn(i.Affiliate6moCodeNotIn...))
	}
	if i.Affiliate6moCodeGT != nil {
		predicates = append(predicates, subscription.Affiliate6moCodeGT(*i.Affiliate6moCodeGT))
	}
	if i.Affiliate6moCodeGTE != nil {
		predicates = append(predicates, subscription.Affiliate6moCodeGTE(*i.Affiliate6moCodeGTE))
	}
	if i.Affiliate6moCodeLT != nil {
		predicates = append(predicates, subscription.Affiliate6moCodeLT(*i.Affiliate6moCodeLT))
	}
	if i.Affiliate6moCodeLTE != nil {
		predicates = append(predicates, subscription.Affiliate6moCodeLTE(*i.Affiliate6moCodeLTE))
	}
	if i.Affiliate6moCodeContains != nil {
		predicates = append(predicates, subscription.Affiliate6moCodeContains(*i.Affiliate6moCodeContains))
	}
	if i.Affiliate6moCodeHasPrefix != nil {
		predicates = append(predicates, subscription.Affiliate6moCodeHasPrefix(*i.Affiliate6moCodeHasPrefix))
	}
	if i.Affiliate6moCodeHasSuffix != nil {
		predicates = append(predicates, subscription.Affiliate6moCodeHasSuffix(*i.Affiliate6moCodeHasSuffix))
	}
	if i.Affiliate6moCodeIsNil {
		predicates = append(predicates, subscription.Affiliate6moCodeIsNil())
	}
	if i.Affiliate6moCodeNotNil {
		predicates = append(predicates, subscription.Affiliate6moCodeNotNil())
	}
	if i.Affiliate6moCodeEqualFold != nil {
		predicates = append(predicates, subscription.Affiliate6moCodeEqualFold(*i.Affiliate6moCodeEqualFold))
	}
	if i.Affiliate6moCodeContainsFold != nil {
		predicates = append(predicates, subscription.Affiliate6moCodeContainsFold(*i.Affiliate6moCodeContainsFold))
	}
	if i.Affiliate12moCode != nil {
		predicates = append(predicates, subscription.Affiliate12moCodeEQ(*i.Affiliate12moCode))
	}
	if i.Affiliate12moCodeNEQ != nil {
		predicates = append(predicates, subscription.Affiliate12moCodeNEQ(*i.Affiliate12moCodeNEQ))
	}
	if len(i.Affiliate12moCodeIn) > 0 {
		predicates = append(predicates, subscription.Affiliate12moCodeIn(i.Affiliate12moCodeIn...))
	}
	if len(i.Affiliate12moCodeNotIn) > 0 {
		predicates = append(predicates, subscription.Affiliate12moCodeNotIn(i.Affiliate12moCodeNotIn...))
	}
	if i.Affiliate12moCodeGT != nil {
		predicates = append(predicates, subscription.Affiliate12moCodeGT(*i.Affiliate12moCodeGT))
	}
	if i.Affiliate12moCodeGTE != nil {
		predicates = append(predicates, subscription.Affiliate12moCodeGTE(*i.Affiliate12moCodeGTE))
	}
	if i.Affiliate12moCodeLT != nil {
		predicates = append(predicates, subscription.Affiliate12moCodeLT(*i.Affiliate12moCodeLT))
	}
	if i.Affiliate12moCodeLTE != nil {
		predicates = append(predicates, subscription.Affiliate12moCodeLTE(*i.Affiliate12moCodeLTE))
	}
	if i.Affiliate12moCodeContains != nil {
		predicates = append(predicates, subscription.Affiliate12moCodeContains(*i.Affiliate12moCodeContains))
	}
	if i.Affiliate12moCodeHasPrefix != nil {
		predicates = append(predicates, subscription.Affiliate12moCodeHasPrefix(*i.Affiliate12moCodeHasPrefix))
	}
	if i.Affiliate12moCodeHasSuffix != nil {
		predicates = append(predicates, subscription.Affiliate12moCodeHasSuffix(*i.Affiliate12moCodeHasSuffix))
	}
	if i.Affiliate12moCodeIsNil {
		predicates = append(predicates, subscription.Affiliate12moCodeIsNil())
	}
	if i.Affiliate12moCodeNotNil {
		predicates = append(predicates, subscription.Affiliate12moCodeNotNil())
	}
	if i.Affiliate12moCodeEqualFold != nil {
		predicates = append(predicates, subscription.Affiliate12moCodeEqualFold(*i.Affiliate12moCodeEqualFold))
	}
	if i.Affiliate12moCodeContainsFold != nil {
		predicates = append(predicates, subscription.Affiliate12moCodeContainsFold(*i.Affiliate12moCodeContainsFold))
	}

	if i.HasUser != nil {
		p := subscription.HasUser()
		if !*i.HasUser {
			p = subscription.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subscription.HasUserWith(with...))
	}
	if i.HasCheckoutSession != nil {
		p := subscription.HasCheckoutSession()
		if !*i.HasCheckoutSession {
			p = subscription.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCheckoutSessionWith) > 0 {
		with := make([]predicate.CheckoutSession, 0, len(i.HasCheckoutSessionWith))
		for _, w := range i.HasCheckoutSessionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCheckoutSessionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, subscription.HasCheckoutSessionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySubscriptionPlanWhereInput
	case 1:
		return predicates[0], nil
	default:
		return subscription.And(predicates...), nil
	}
}

// TaskWhereInput represents a where input for filtering Task queries.
type TaskWhereInput struct {
	Predicates []predicate.Task  `json:"-"`
	Not        *TaskWhereInput   `json:"not,omitempty"`
	Or         []*TaskWhereInput `json:"or,omitempty"`
	And        []*TaskWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "status" field predicates.
	Status      *task.Status  `json:"status,omitempty"`
	StatusNEQ   *task.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []task.Status `json:"statusIn,omitempty"`
	StatusNotIn []task.Status `json:"statusNotIn,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "rank" field predicates.
	Rank      *float64  `json:"rank,omitempty"`
	RankNEQ   *float64  `json:"rankNEQ,omitempty"`
	RankIn    []float64 `json:"rankIn,omitempty"`
	RankNotIn []float64 `json:"rankNotIn,omitempty"`
	RankGT    *float64  `json:"rankGT,omitempty"`
	RankGTE   *float64  `json:"rankGTE,omitempty"`
	RankLT    *float64  `json:"rankLT,omitempty"`
	RankLTE   *float64  `json:"rankLTE,omitempty"`

	// "estimate" field predicates.
	Estimate       *float64  `json:"estimate,omitempty"`
	EstimateNEQ    *float64  `json:"estimateNEQ,omitempty"`
	EstimateIn     []float64 `json:"estimateIn,omitempty"`
	EstimateNotIn  []float64 `json:"estimateNotIn,omitempty"`
	EstimateGT     *float64  `json:"estimateGT,omitempty"`
	EstimateGTE    *float64  `json:"estimateGTE,omitempty"`
	EstimateLT     *float64  `json:"estimateLT,omitempty"`
	EstimateLTE    *float64  `json:"estimateLTE,omitempty"`
	EstimateIsNil  bool      `json:"estimateIsNil,omitempty"`
	EstimateNotNil bool      `json:"estimateNotNil,omitempty"`

	// "priority" field predicates.
	Priority       *task.Priority  `json:"priority,omitempty"`
	PriorityNEQ    *task.Priority  `json:"priorityNEQ,omitempty"`
	PriorityIn     []task.Priority `json:"priorityIn,omitempty"`
	PriorityNotIn  []task.Priority `json:"priorityNotIn,omitempty"`
	PriorityIsNil  bool            `json:"priorityIsNil,omitempty"`
	PriorityNotNil bool            `json:"priorityNotNil,omitempty"`

	// "effort" field predicates.
	Effort       *task.Effort  `json:"effort,omitempty"`
	EffortNEQ    *task.Effort  `json:"effortNEQ,omitempty"`
	EffortIn     []task.Effort `json:"effortIn,omitempty"`
	EffortNotIn  []task.Effort `json:"effortNotIn,omitempty"`
	EffortIsNil  bool          `json:"effortIsNil,omitempty"`
	EffortNotNil bool          `json:"effortNotNil,omitempty"`

	// "difficulty" field predicates.
	Difficulty       *task.Difficulty  `json:"difficulty,omitempty"`
	DifficultyNEQ    *task.Difficulty  `json:"difficultyNEQ,omitempty"`
	DifficultyIn     []task.Difficulty `json:"difficultyIn,omitempty"`
	DifficultyNotIn  []task.Difficulty `json:"difficultyNotIn,omitempty"`
	DifficultyIsNil  bool              `json:"difficultyIsNil,omitempty"`
	DifficultyNotNil bool              `json:"difficultyNotNil,omitempty"`

	// "category" field predicates.
	Category       *task.Category  `json:"category,omitempty"`
	CategoryNEQ    *task.Category  `json:"categoryNEQ,omitempty"`
	CategoryIn     []task.Category `json:"categoryIn,omitempty"`
	CategoryNotIn  []task.Category `json:"categoryNotIn,omitempty"`
	CategoryIsNil  bool            `json:"categoryIsNil,omitempty"`
	CategoryNotNil bool            `json:"categoryNotNil,omitempty"`

	// "budget" field predicates.
	Budget       *float64  `json:"budget,omitempty"`
	BudgetNEQ    *float64  `json:"budgetNEQ,omitempty"`
	BudgetIn     []float64 `json:"budgetIn,omitempty"`
	BudgetNotIn  []float64 `json:"budgetNotIn,omitempty"`
	BudgetGT     *float64  `json:"budgetGT,omitempty"`
	BudgetGTE    *float64  `json:"budgetGTE,omitempty"`
	BudgetLT     *float64  `json:"budgetLT,omitempty"`
	BudgetLTE    *float64  `json:"budgetLTE,omitempty"`
	BudgetIsNil  bool      `json:"budgetIsNil,omitempty"`
	BudgetNotNil bool      `json:"budgetNotNil,omitempty"`

	// "parts_needed" field predicates.
	PartsNeeded             *string  `json:"partsNeeded,omitempty"`
	PartsNeededNEQ          *string  `json:"partsNeededNEQ,omitempty"`
	PartsNeededIn           []string `json:"partsNeededIn,omitempty"`
	PartsNeededNotIn        []string `json:"partsNeededNotIn,omitempty"`
	PartsNeededGT           *string  `json:"partsNeededGT,omitempty"`
	PartsNeededGTE          *string  `json:"partsNeededGTE,omitempty"`
	PartsNeededLT           *string  `json:"partsNeededLT,omitempty"`
	PartsNeededLTE          *string  `json:"partsNeededLTE,omitempty"`
	PartsNeededContains     *string  `json:"partsNeededContains,omitempty"`
	PartsNeededHasPrefix    *string  `json:"partsNeededHasPrefix,omitempty"`
	PartsNeededHasSuffix    *string  `json:"partsNeededHasSuffix,omitempty"`
	PartsNeededIsNil        bool     `json:"partsNeededIsNil,omitempty"`
	PartsNeededNotNil       bool     `json:"partsNeededNotNil,omitempty"`
	PartsNeededEqualFold    *string  `json:"partsNeededEqualFold,omitempty"`
	PartsNeededContainsFold *string  `json:"partsNeededContainsFold,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "parent" edge predicates.
	HasParent     *bool             `json:"hasParent,omitempty"`
	HasParentWith []*TaskWhereInput `json:"hasParentWith,omitempty"`

	// "subtasks" edge predicates.
	HasSubtasks     *bool             `json:"hasSubtasks,omitempty"`
	HasSubtasksWith []*TaskWhereInput `json:"hasSubtasksWith,omitempty"`

	// "mods" edge predicates.
	HasMods     *bool            `json:"hasMods,omitempty"`
	HasModsWith []*ModWhereInput `json:"hasModsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TaskWhereInput) AddPredicates(predicates ...predicate.Task) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TaskWhereInput filter on the TaskQuery builder.
func (i *TaskWhereInput) Filter(q *TaskQuery) (*TaskQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTaskWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTaskWhereInput is returned in case the TaskWhereInput is empty.
var ErrEmptyTaskWhereInput = errors.New("ent: empty predicate TaskWhereInput")

// P returns a predicate for filtering tasks.
// An error is returned if the input is empty or invalid.
func (i *TaskWhereInput) P() (predicate.Task, error) {
	var predicates []predicate.Task
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, task.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Task, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, task.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Task, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, task.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, task.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, task.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, task.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, task.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, task.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, task.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, task.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, task.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, task.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, task.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, task.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, task.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, task.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, task.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, task.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, task.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, task.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, task.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, task.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, task.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, task.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, task.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, task.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, task.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, task.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, task.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, task.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, task.StatusNotIn(i.StatusNotIn...))
	}
	if i.Title != nil {
		predicates = append(predicates, task.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, task.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, task.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, task.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, task.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, task.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, task.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, task.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, task.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, task.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, task.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, task.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, task.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, task.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, task.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, task.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, task.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, task.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, task.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, task.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, task.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, task.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, task.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, task.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, task.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, task.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, task.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, task.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Rank != nil {
		predicates = append(predicates, task.RankEQ(*i.Rank))
	}
	if i.RankNEQ != nil {
		predicates = append(predicates, task.RankNEQ(*i.RankNEQ))
	}
	if len(i.RankIn) > 0 {
		predicates = append(predicates, task.RankIn(i.RankIn...))
	}
	if len(i.RankNotIn) > 0 {
		predicates = append(predicates, task.RankNotIn(i.RankNotIn...))
	}
	if i.RankGT != nil {
		predicates = append(predicates, task.RankGT(*i.RankGT))
	}
	if i.RankGTE != nil {
		predicates = append(predicates, task.RankGTE(*i.RankGTE))
	}
	if i.RankLT != nil {
		predicates = append(predicates, task.RankLT(*i.RankLT))
	}
	if i.RankLTE != nil {
		predicates = append(predicates, task.RankLTE(*i.RankLTE))
	}
	if i.Estimate != nil {
		predicates = append(predicates, task.EstimateEQ(*i.Estimate))
	}
	if i.EstimateNEQ != nil {
		predicates = append(predicates, task.EstimateNEQ(*i.EstimateNEQ))
	}
	if len(i.EstimateIn) > 0 {
		predicates = append(predicates, task.EstimateIn(i.EstimateIn...))
	}
	if len(i.EstimateNotIn) > 0 {
		predicates = append(predicates, task.EstimateNotIn(i.EstimateNotIn...))
	}
	if i.EstimateGT != nil {
		predicates = append(predicates, task.EstimateGT(*i.EstimateGT))
	}
	if i.EstimateGTE != nil {
		predicates = append(predicates, task.EstimateGTE(*i.EstimateGTE))
	}
	if i.EstimateLT != nil {
		predicates = append(predicates, task.EstimateLT(*i.EstimateLT))
	}
	if i.EstimateLTE != nil {
		predicates = append(predicates, task.EstimateLTE(*i.EstimateLTE))
	}
	if i.EstimateIsNil {
		predicates = append(predicates, task.EstimateIsNil())
	}
	if i.EstimateNotNil {
		predicates = append(predicates, task.EstimateNotNil())
	}
	if i.Priority != nil {
		predicates = append(predicates, task.PriorityEQ(*i.Priority))
	}
	if i.PriorityNEQ != nil {
		predicates = append(predicates, task.PriorityNEQ(*i.PriorityNEQ))
	}
	if len(i.PriorityIn) > 0 {
		predicates = append(predicates, task.PriorityIn(i.PriorityIn...))
	}
	if len(i.PriorityNotIn) > 0 {
		predicates = append(predicates, task.PriorityNotIn(i.PriorityNotIn...))
	}
	if i.PriorityIsNil {
		predicates = append(predicates, task.PriorityIsNil())
	}
	if i.PriorityNotNil {
		predicates = append(predicates, task.PriorityNotNil())
	}
	if i.Effort != nil {
		predicates = append(predicates, task.EffortEQ(*i.Effort))
	}
	if i.EffortNEQ != nil {
		predicates = append(predicates, task.EffortNEQ(*i.EffortNEQ))
	}
	if len(i.EffortIn) > 0 {
		predicates = append(predicates, task.EffortIn(i.EffortIn...))
	}
	if len(i.EffortNotIn) > 0 {
		predicates = append(predicates, task.EffortNotIn(i.EffortNotIn...))
	}
	if i.EffortIsNil {
		predicates = append(predicates, task.EffortIsNil())
	}
	if i.EffortNotNil {
		predicates = append(predicates, task.EffortNotNil())
	}
	if i.Difficulty != nil {
		predicates = append(predicates, task.DifficultyEQ(*i.Difficulty))
	}
	if i.DifficultyNEQ != nil {
		predicates = append(predicates, task.DifficultyNEQ(*i.DifficultyNEQ))
	}
	if len(i.DifficultyIn) > 0 {
		predicates = append(predicates, task.DifficultyIn(i.DifficultyIn...))
	}
	if len(i.DifficultyNotIn) > 0 {
		predicates = append(predicates, task.DifficultyNotIn(i.DifficultyNotIn...))
	}
	if i.DifficultyIsNil {
		predicates = append(predicates, task.DifficultyIsNil())
	}
	if i.DifficultyNotNil {
		predicates = append(predicates, task.DifficultyNotNil())
	}
	if i.Category != nil {
		predicates = append(predicates, task.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, task.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, task.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, task.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryIsNil {
		predicates = append(predicates, task.CategoryIsNil())
	}
	if i.CategoryNotNil {
		predicates = append(predicates, task.CategoryNotNil())
	}
	if i.Budget != nil {
		predicates = append(predicates, task.BudgetEQ(*i.Budget))
	}
	if i.BudgetNEQ != nil {
		predicates = append(predicates, task.BudgetNEQ(*i.BudgetNEQ))
	}
	if len(i.BudgetIn) > 0 {
		predicates = append(predicates, task.BudgetIn(i.BudgetIn...))
	}
	if len(i.BudgetNotIn) > 0 {
		predicates = append(predicates, task.BudgetNotIn(i.BudgetNotIn...))
	}
	if i.BudgetGT != nil {
		predicates = append(predicates, task.BudgetGT(*i.BudgetGT))
	}
	if i.BudgetGTE != nil {
		predicates = append(predicates, task.BudgetGTE(*i.BudgetGTE))
	}
	if i.BudgetLT != nil {
		predicates = append(predicates, task.BudgetLT(*i.BudgetLT))
	}
	if i.BudgetLTE != nil {
		predicates = append(predicates, task.BudgetLTE(*i.BudgetLTE))
	}
	if i.BudgetIsNil {
		predicates = append(predicates, task.BudgetIsNil())
	}
	if i.BudgetNotNil {
		predicates = append(predicates, task.BudgetNotNil())
	}
	if i.PartsNeeded != nil {
		predicates = append(predicates, task.PartsNeededEQ(*i.PartsNeeded))
	}
	if i.PartsNeededNEQ != nil {
		predicates = append(predicates, task.PartsNeededNEQ(*i.PartsNeededNEQ))
	}
	if len(i.PartsNeededIn) > 0 {
		predicates = append(predicates, task.PartsNeededIn(i.PartsNeededIn...))
	}
	if len(i.PartsNeededNotIn) > 0 {
		predicates = append(predicates, task.PartsNeededNotIn(i.PartsNeededNotIn...))
	}
	if i.PartsNeededGT != nil {
		predicates = append(predicates, task.PartsNeededGT(*i.PartsNeededGT))
	}
	if i.PartsNeededGTE != nil {
		predicates = append(predicates, task.PartsNeededGTE(*i.PartsNeededGTE))
	}
	if i.PartsNeededLT != nil {
		predicates = append(predicates, task.PartsNeededLT(*i.PartsNeededLT))
	}
	if i.PartsNeededLTE != nil {
		predicates = append(predicates, task.PartsNeededLTE(*i.PartsNeededLTE))
	}
	if i.PartsNeededContains != nil {
		predicates = append(predicates, task.PartsNeededContains(*i.PartsNeededContains))
	}
	if i.PartsNeededHasPrefix != nil {
		predicates = append(predicates, task.PartsNeededHasPrefix(*i.PartsNeededHasPrefix))
	}
	if i.PartsNeededHasSuffix != nil {
		predicates = append(predicates, task.PartsNeededHasSuffix(*i.PartsNeededHasSuffix))
	}
	if i.PartsNeededIsNil {
		predicates = append(predicates, task.PartsNeededIsNil())
	}
	if i.PartsNeededNotNil {
		predicates = append(predicates, task.PartsNeededNotNil())
	}
	if i.PartsNeededEqualFold != nil {
		predicates = append(predicates, task.PartsNeededEqualFold(*i.PartsNeededEqualFold))
	}
	if i.PartsNeededContainsFold != nil {
		predicates = append(predicates, task.PartsNeededContainsFold(*i.PartsNeededContainsFold))
	}

	if i.HasCar != nil {
		p := task.HasCar()
		if !*i.HasCar {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasCarWith(with...))
	}
	if i.HasParent != nil {
		p := task.HasParent()
		if !*i.HasParent {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasParentWith))
		for _, w := range i.HasParentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasParentWith(with...))
	}
	if i.HasSubtasks != nil {
		p := task.HasSubtasks()
		if !*i.HasSubtasks {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubtasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasSubtasksWith))
		for _, w := range i.HasSubtasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubtasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasSubtasksWith(with...))
	}
	if i.HasMods != nil {
		p := task.HasMods()
		if !*i.HasMods {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasModsWith) > 0 {
		with := make([]predicate.Mod, 0, len(i.HasModsWith))
		for _, w := range i.HasModsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasModsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasModsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTaskWhereInput
	case 1:
		return predicates[0], nil
	default:
		return task.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "stripe_customer_id" field predicates.
	StripeCustomerID             *string  `json:"stripeCustomerID,omitempty"`
	StripeCustomerIDNEQ          *string  `json:"stripeCustomerIDNEQ,omitempty"`
	StripeCustomerIDIn           []string `json:"stripeCustomerIDIn,omitempty"`
	StripeCustomerIDNotIn        []string `json:"stripeCustomerIDNotIn,omitempty"`
	StripeCustomerIDGT           *string  `json:"stripeCustomerIDGT,omitempty"`
	StripeCustomerIDGTE          *string  `json:"stripeCustomerIDGTE,omitempty"`
	StripeCustomerIDLT           *string  `json:"stripeCustomerIDLT,omitempty"`
	StripeCustomerIDLTE          *string  `json:"stripeCustomerIDLTE,omitempty"`
	StripeCustomerIDContains     *string  `json:"stripeCustomerIDContains,omitempty"`
	StripeCustomerIDHasPrefix    *string  `json:"stripeCustomerIDHasPrefix,omitempty"`
	StripeCustomerIDHasSuffix    *string  `json:"stripeCustomerIDHasSuffix,omitempty"`
	StripeCustomerIDIsNil        bool     `json:"stripeCustomerIDIsNil,omitempty"`
	StripeCustomerIDNotNil       bool     `json:"stripeCustomerIDNotNil,omitempty"`
	StripeCustomerIDEqualFold    *string  `json:"stripeCustomerIDEqualFold,omitempty"`
	StripeCustomerIDContainsFold *string  `json:"stripeCustomerIDContainsFold,omitempty"`

	// "stripe_account_id" field predicates.
	StripeAccountID             *string  `json:"stripeAccountID,omitempty"`
	StripeAccountIDNEQ          *string  `json:"stripeAccountIDNEQ,omitempty"`
	StripeAccountIDIn           []string `json:"stripeAccountIDIn,omitempty"`
	StripeAccountIDNotIn        []string `json:"stripeAccountIDNotIn,omitempty"`
	StripeAccountIDGT           *string  `json:"stripeAccountIDGT,omitempty"`
	StripeAccountIDGTE          *string  `json:"stripeAccountIDGTE,omitempty"`
	StripeAccountIDLT           *string  `json:"stripeAccountIDLT,omitempty"`
	StripeAccountIDLTE          *string  `json:"stripeAccountIDLTE,omitempty"`
	StripeAccountIDContains     *string  `json:"stripeAccountIDContains,omitempty"`
	StripeAccountIDHasPrefix    *string  `json:"stripeAccountIDHasPrefix,omitempty"`
	StripeAccountIDHasSuffix    *string  `json:"stripeAccountIDHasSuffix,omitempty"`
	StripeAccountIDIsNil        bool     `json:"stripeAccountIDIsNil,omitempty"`
	StripeAccountIDNotNil       bool     `json:"stripeAccountIDNotNil,omitempty"`
	StripeAccountIDEqualFold    *string  `json:"stripeAccountIDEqualFold,omitempty"`
	StripeAccountIDContainsFold *string  `json:"stripeAccountIDContainsFold,omitempty"`

	// "affiliate_6mo_code" field predicates.
	Affiliate6moCode             *string  `json:"affiliate6moCode,omitempty"`
	Affiliate6moCodeNEQ          *string  `json:"affiliate6moCodeNEQ,omitempty"`
	Affiliate6moCodeIn           []string `json:"affiliate6moCodeIn,omitempty"`
	Affiliate6moCodeNotIn        []string `json:"affiliate6moCodeNotIn,omitempty"`
	Affiliate6moCodeGT           *string  `json:"affiliate6moCodeGT,omitempty"`
	Affiliate6moCodeGTE          *string  `json:"affiliate6moCodeGTE,omitempty"`
	Affiliate6moCodeLT           *string  `json:"affiliate6moCodeLT,omitempty"`
	Affiliate6moCodeLTE          *string  `json:"affiliate6moCodeLTE,omitempty"`
	Affiliate6moCodeContains     *string  `json:"affiliate6moCodeContains,omitempty"`
	Affiliate6moCodeHasPrefix    *string  `json:"affiliate6moCodeHasPrefix,omitempty"`
	Affiliate6moCodeHasSuffix    *string  `json:"affiliate6moCodeHasSuffix,omitempty"`
	Affiliate6moCodeIsNil        bool     `json:"affiliate6moCodeIsNil,omitempty"`
	Affiliate6moCodeNotNil       bool     `json:"affiliate6moCodeNotNil,omitempty"`
	Affiliate6moCodeEqualFold    *string  `json:"affiliate6moCodeEqualFold,omitempty"`
	Affiliate6moCodeContainsFold *string  `json:"affiliate6moCodeContainsFold,omitempty"`

	// "affiliate_12mo_code" field predicates.
	Affiliate12moCode             *string  `json:"affiliate12moCode,omitempty"`
	Affiliate12moCodeNEQ          *string  `json:"affiliate12moCodeNEQ,omitempty"`
	Affiliate12moCodeIn           []string `json:"affiliate12moCodeIn,omitempty"`
	Affiliate12moCodeNotIn        []string `json:"affiliate12moCodeNotIn,omitempty"`
	Affiliate12moCodeGT           *string  `json:"affiliate12moCodeGT,omitempty"`
	Affiliate12moCodeGTE          *string  `json:"affiliate12moCodeGTE,omitempty"`
	Affiliate12moCodeLT           *string  `json:"affiliate12moCodeLT,omitempty"`
	Affiliate12moCodeLTE          *string  `json:"affiliate12moCodeLTE,omitempty"`
	Affiliate12moCodeContains     *string  `json:"affiliate12moCodeContains,omitempty"`
	Affiliate12moCodeHasPrefix    *string  `json:"affiliate12moCodeHasPrefix,omitempty"`
	Affiliate12moCodeHasSuffix    *string  `json:"affiliate12moCodeHasSuffix,omitempty"`
	Affiliate12moCodeIsNil        bool     `json:"affiliate12moCodeIsNil,omitempty"`
	Affiliate12moCodeNotNil       bool     `json:"affiliate12moCodeNotNil,omitempty"`
	Affiliate12moCodeEqualFold    *string  `json:"affiliate12moCodeEqualFold,omitempty"`
	Affiliate12moCodeContainsFold *string  `json:"affiliate12moCodeContainsFold,omitempty"`

	// "cars" edge predicates.
	HasCars     *bool            `json:"hasCars,omitempty"`
	HasCarsWith []*CarWhereInput `json:"hasCarsWith,omitempty"`

	// "profile" edge predicates.
	HasProfile     *bool                `json:"hasProfile,omitempty"`
	HasProfileWith []*ProfileWhereInput `json:"hasProfileWith,omitempty"`

	// "settings" edge predicates.
	HasSettings     *bool                     `json:"hasSettings,omitempty"`
	HasSettingsWith []*UserSettingsWhereInput `json:"hasSettingsWith,omitempty"`

	// "subscriptions" edge predicates.
	HasSubscriptions     *bool                         `json:"hasSubscriptions,omitempty"`
	HasSubscriptionsWith []*SubscriptionPlanWhereInput `json:"hasSubscriptionsWith,omitempty"`

	// "checkout_sessions" edge predicates.
	HasCheckoutSessions     *bool                        `json:"hasCheckoutSessions,omitempty"`
	HasCheckoutSessionsWith []*CheckoutSessionWhereInput `json:"hasCheckoutSessionsWith,omitempty"`

	// "media" edge predicates.
	HasMedia     *bool              `json:"hasMedia,omitempty"`
	HasMediaWith []*MediaWhereInput `json:"hasMediaWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, user.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, user.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, user.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, user.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, user.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, user.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, user.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, user.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, user.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, user.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, user.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, user.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, user.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, user.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, user.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, user.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.StripeCustomerID != nil {
		predicates = append(predicates, user.StripeCustomerIDEQ(*i.StripeCustomerID))
	}
	if i.StripeCustomerIDNEQ != nil {
		predicates = append(predicates, user.StripeCustomerIDNEQ(*i.StripeCustomerIDNEQ))
	}
	if len(i.StripeCustomerIDIn) > 0 {
		predicates = append(predicates, user.StripeCustomerIDIn(i.StripeCustomerIDIn...))
	}
	if len(i.StripeCustomerIDNotIn) > 0 {
		predicates = append(predicates, user.StripeCustomerIDNotIn(i.StripeCustomerIDNotIn...))
	}
	if i.StripeCustomerIDGT != nil {
		predicates = append(predicates, user.StripeCustomerIDGT(*i.StripeCustomerIDGT))
	}
	if i.StripeCustomerIDGTE != nil {
		predicates = append(predicates, user.StripeCustomerIDGTE(*i.StripeCustomerIDGTE))
	}
	if i.StripeCustomerIDLT != nil {
		predicates = append(predicates, user.StripeCustomerIDLT(*i.StripeCustomerIDLT))
	}
	if i.StripeCustomerIDLTE != nil {
		predicates = append(predicates, user.StripeCustomerIDLTE(*i.StripeCustomerIDLTE))
	}
	if i.StripeCustomerIDContains != nil {
		predicates = append(predicates, user.StripeCustomerIDContains(*i.StripeCustomerIDContains))
	}
	if i.StripeCustomerIDHasPrefix != nil {
		predicates = append(predicates, user.StripeCustomerIDHasPrefix(*i.StripeCustomerIDHasPrefix))
	}
	if i.StripeCustomerIDHasSuffix != nil {
		predicates = append(predicates, user.StripeCustomerIDHasSuffix(*i.StripeCustomerIDHasSuffix))
	}
	if i.StripeCustomerIDIsNil {
		predicates = append(predicates, user.StripeCustomerIDIsNil())
	}
	if i.StripeCustomerIDNotNil {
		predicates = append(predicates, user.StripeCustomerIDNotNil())
	}
	if i.StripeCustomerIDEqualFold != nil {
		predicates = append(predicates, user.StripeCustomerIDEqualFold(*i.StripeCustomerIDEqualFold))
	}
	if i.StripeCustomerIDContainsFold != nil {
		predicates = append(predicates, user.StripeCustomerIDContainsFold(*i.StripeCustomerIDContainsFold))
	}
	if i.StripeAccountID != nil {
		predicates = append(predicates, user.StripeAccountIDEQ(*i.StripeAccountID))
	}
	if i.StripeAccountIDNEQ != nil {
		predicates = append(predicates, user.StripeAccountIDNEQ(*i.StripeAccountIDNEQ))
	}
	if len(i.StripeAccountIDIn) > 0 {
		predicates = append(predicates, user.StripeAccountIDIn(i.StripeAccountIDIn...))
	}
	if len(i.StripeAccountIDNotIn) > 0 {
		predicates = append(predicates, user.StripeAccountIDNotIn(i.StripeAccountIDNotIn...))
	}
	if i.StripeAccountIDGT != nil {
		predicates = append(predicates, user.StripeAccountIDGT(*i.StripeAccountIDGT))
	}
	if i.StripeAccountIDGTE != nil {
		predicates = append(predicates, user.StripeAccountIDGTE(*i.StripeAccountIDGTE))
	}
	if i.StripeAccountIDLT != nil {
		predicates = append(predicates, user.StripeAccountIDLT(*i.StripeAccountIDLT))
	}
	if i.StripeAccountIDLTE != nil {
		predicates = append(predicates, user.StripeAccountIDLTE(*i.StripeAccountIDLTE))
	}
	if i.StripeAccountIDContains != nil {
		predicates = append(predicates, user.StripeAccountIDContains(*i.StripeAccountIDContains))
	}
	if i.StripeAccountIDHasPrefix != nil {
		predicates = append(predicates, user.StripeAccountIDHasPrefix(*i.StripeAccountIDHasPrefix))
	}
	if i.StripeAccountIDHasSuffix != nil {
		predicates = append(predicates, user.StripeAccountIDHasSuffix(*i.StripeAccountIDHasSuffix))
	}
	if i.StripeAccountIDIsNil {
		predicates = append(predicates, user.StripeAccountIDIsNil())
	}
	if i.StripeAccountIDNotNil {
		predicates = append(predicates, user.StripeAccountIDNotNil())
	}
	if i.StripeAccountIDEqualFold != nil {
		predicates = append(predicates, user.StripeAccountIDEqualFold(*i.StripeAccountIDEqualFold))
	}
	if i.StripeAccountIDContainsFold != nil {
		predicates = append(predicates, user.StripeAccountIDContainsFold(*i.StripeAccountIDContainsFold))
	}
	if i.Affiliate6moCode != nil {
		predicates = append(predicates, user.Affiliate6moCodeEQ(*i.Affiliate6moCode))
	}
	if i.Affiliate6moCodeNEQ != nil {
		predicates = append(predicates, user.Affiliate6moCodeNEQ(*i.Affiliate6moCodeNEQ))
	}
	if len(i.Affiliate6moCodeIn) > 0 {
		predicates = append(predicates, user.Affiliate6moCodeIn(i.Affiliate6moCodeIn...))
	}
	if len(i.Affiliate6moCodeNotIn) > 0 {
		predicates = append(predicates, user.Affiliate6moCodeNotIn(i.Affiliate6moCodeNotIn...))
	}
	if i.Affiliate6moCodeGT != nil {
		predicates = append(predicates, user.Affiliate6moCodeGT(*i.Affiliate6moCodeGT))
	}
	if i.Affiliate6moCodeGTE != nil {
		predicates = append(predicates, user.Affiliate6moCodeGTE(*i.Affiliate6moCodeGTE))
	}
	if i.Affiliate6moCodeLT != nil {
		predicates = append(predicates, user.Affiliate6moCodeLT(*i.Affiliate6moCodeLT))
	}
	if i.Affiliate6moCodeLTE != nil {
		predicates = append(predicates, user.Affiliate6moCodeLTE(*i.Affiliate6moCodeLTE))
	}
	if i.Affiliate6moCodeContains != nil {
		predicates = append(predicates, user.Affiliate6moCodeContains(*i.Affiliate6moCodeContains))
	}
	if i.Affiliate6moCodeHasPrefix != nil {
		predicates = append(predicates, user.Affiliate6moCodeHasPrefix(*i.Affiliate6moCodeHasPrefix))
	}
	if i.Affiliate6moCodeHasSuffix != nil {
		predicates = append(predicates, user.Affiliate6moCodeHasSuffix(*i.Affiliate6moCodeHasSuffix))
	}
	if i.Affiliate6moCodeIsNil {
		predicates = append(predicates, user.Affiliate6moCodeIsNil())
	}
	if i.Affiliate6moCodeNotNil {
		predicates = append(predicates, user.Affiliate6moCodeNotNil())
	}
	if i.Affiliate6moCodeEqualFold != nil {
		predicates = append(predicates, user.Affiliate6moCodeEqualFold(*i.Affiliate6moCodeEqualFold))
	}
	if i.Affiliate6moCodeContainsFold != nil {
		predicates = append(predicates, user.Affiliate6moCodeContainsFold(*i.Affiliate6moCodeContainsFold))
	}
	if i.Affiliate12moCode != nil {
		predicates = append(predicates, user.Affiliate12moCodeEQ(*i.Affiliate12moCode))
	}
	if i.Affiliate12moCodeNEQ != nil {
		predicates = append(predicates, user.Affiliate12moCodeNEQ(*i.Affiliate12moCodeNEQ))
	}
	if len(i.Affiliate12moCodeIn) > 0 {
		predicates = append(predicates, user.Affiliate12moCodeIn(i.Affiliate12moCodeIn...))
	}
	if len(i.Affiliate12moCodeNotIn) > 0 {
		predicates = append(predicates, user.Affiliate12moCodeNotIn(i.Affiliate12moCodeNotIn...))
	}
	if i.Affiliate12moCodeGT != nil {
		predicates = append(predicates, user.Affiliate12moCodeGT(*i.Affiliate12moCodeGT))
	}
	if i.Affiliate12moCodeGTE != nil {
		predicates = append(predicates, user.Affiliate12moCodeGTE(*i.Affiliate12moCodeGTE))
	}
	if i.Affiliate12moCodeLT != nil {
		predicates = append(predicates, user.Affiliate12moCodeLT(*i.Affiliate12moCodeLT))
	}
	if i.Affiliate12moCodeLTE != nil {
		predicates = append(predicates, user.Affiliate12moCodeLTE(*i.Affiliate12moCodeLTE))
	}
	if i.Affiliate12moCodeContains != nil {
		predicates = append(predicates, user.Affiliate12moCodeContains(*i.Affiliate12moCodeContains))
	}
	if i.Affiliate12moCodeHasPrefix != nil {
		predicates = append(predicates, user.Affiliate12moCodeHasPrefix(*i.Affiliate12moCodeHasPrefix))
	}
	if i.Affiliate12moCodeHasSuffix != nil {
		predicates = append(predicates, user.Affiliate12moCodeHasSuffix(*i.Affiliate12moCodeHasSuffix))
	}
	if i.Affiliate12moCodeIsNil {
		predicates = append(predicates, user.Affiliate12moCodeIsNil())
	}
	if i.Affiliate12moCodeNotNil {
		predicates = append(predicates, user.Affiliate12moCodeNotNil())
	}
	if i.Affiliate12moCodeEqualFold != nil {
		predicates = append(predicates, user.Affiliate12moCodeEqualFold(*i.Affiliate12moCodeEqualFold))
	}
	if i.Affiliate12moCodeContainsFold != nil {
		predicates = append(predicates, user.Affiliate12moCodeContainsFold(*i.Affiliate12moCodeContainsFold))
	}

	if i.HasCars != nil {
		p := user.HasCars()
		if !*i.HasCars {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarsWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarsWith))
		for _, w := range i.HasCarsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCarsWith(with...))
	}
	if i.HasProfile != nil {
		p := user.HasProfile()
		if !*i.HasProfile {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProfileWith) > 0 {
		with := make([]predicate.Profile, 0, len(i.HasProfileWith))
		for _, w := range i.HasProfileWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProfileWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasProfileWith(with...))
	}
	if i.HasSettings != nil {
		p := user.HasSettings()
		if !*i.HasSettings {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSettingsWith) > 0 {
		with := make([]predicate.UserSettings, 0, len(i.HasSettingsWith))
		for _, w := range i.HasSettingsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSettingsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSettingsWith(with...))
	}
	if i.HasSubscriptions != nil {
		p := user.HasSubscriptions()
		if !*i.HasSubscriptions {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubscriptionsWith) > 0 {
		with := make([]predicate.Subscription, 0, len(i.HasSubscriptionsWith))
		for _, w := range i.HasSubscriptionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubscriptionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSubscriptionsWith(with...))
	}
	if i.HasCheckoutSessions != nil {
		p := user.HasCheckoutSessions()
		if !*i.HasCheckoutSessions {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCheckoutSessionsWith) > 0 {
		with := make([]predicate.CheckoutSession, 0, len(i.HasCheckoutSessionsWith))
		for _, w := range i.HasCheckoutSessionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCheckoutSessionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCheckoutSessionsWith(with...))
	}
	if i.HasMedia != nil {
		p := user.HasMedia()
		if !*i.HasMedia {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMediaWith) > 0 {
		with := make([]predicate.Media, 0, len(i.HasMediaWith))
		for _, w := range i.HasMediaWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMediaWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasMediaWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// UserSettingsWhereInput represents a where input for filtering UserSettings queries.
type UserSettingsWhereInput struct {
	Predicates []predicate.UserSettings  `json:"-"`
	Not        *UserSettingsWhereInput   `json:"not,omitempty"`
	Or         []*UserSettingsWhereInput `json:"or,omitempty"`
	And        []*UserSettingsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "currency_code" field predicates.
	CurrencyCode             *string  `json:"currencyCode,omitempty"`
	CurrencyCodeNEQ          *string  `json:"currencyCodeNEQ,omitempty"`
	CurrencyCodeIn           []string `json:"currencyCodeIn,omitempty"`
	CurrencyCodeNotIn        []string `json:"currencyCodeNotIn,omitempty"`
	CurrencyCodeGT           *string  `json:"currencyCodeGT,omitempty"`
	CurrencyCodeGTE          *string  `json:"currencyCodeGTE,omitempty"`
	CurrencyCodeLT           *string  `json:"currencyCodeLT,omitempty"`
	CurrencyCodeLTE          *string  `json:"currencyCodeLTE,omitempty"`
	CurrencyCodeContains     *string  `json:"currencyCodeContains,omitempty"`
	CurrencyCodeHasPrefix    *string  `json:"currencyCodeHasPrefix,omitempty"`
	CurrencyCodeHasSuffix    *string  `json:"currencyCodeHasSuffix,omitempty"`
	CurrencyCodeIsNil        bool     `json:"currencyCodeIsNil,omitempty"`
	CurrencyCodeNotNil       bool     `json:"currencyCodeNotNil,omitempty"`
	CurrencyCodeEqualFold    *string  `json:"currencyCodeEqualFold,omitempty"`
	CurrencyCodeContainsFold *string  `json:"currencyCodeContainsFold,omitempty"`

	// "fuel_volume_unit" field predicates.
	FuelVolumeUnit       *usersettings.FuelVolumeUnit  `json:"fuelVolumeUnit,omitempty"`
	FuelVolumeUnitNEQ    *usersettings.FuelVolumeUnit  `json:"fuelVolumeUnitNEQ,omitempty"`
	FuelVolumeUnitIn     []usersettings.FuelVolumeUnit `json:"fuelVolumeUnitIn,omitempty"`
	FuelVolumeUnitNotIn  []usersettings.FuelVolumeUnit `json:"fuelVolumeUnitNotIn,omitempty"`
	FuelVolumeUnitIsNil  bool                          `json:"fuelVolumeUnitIsNil,omitempty"`
	FuelVolumeUnitNotNil bool                          `json:"fuelVolumeUnitNotNil,omitempty"`

	// "distance_unit" field predicates.
	DistanceUnit       *usersettings.DistanceUnit  `json:"distanceUnit,omitempty"`
	DistanceUnitNEQ    *usersettings.DistanceUnit  `json:"distanceUnitNEQ,omitempty"`
	DistanceUnitIn     []usersettings.DistanceUnit `json:"distanceUnitIn,omitempty"`
	DistanceUnitNotIn  []usersettings.DistanceUnit `json:"distanceUnitNotIn,omitempty"`
	DistanceUnitIsNil  bool                        `json:"distanceUnitIsNil,omitempty"`
	DistanceUnitNotNil bool                        `json:"distanceUnitNotNil,omitempty"`

	// "fuel_consumption_unit" field predicates.
	FuelConsumptionUnit       *usersettings.FuelConsumptionUnit  `json:"fuelConsumptionUnit,omitempty"`
	FuelConsumptionUnitNEQ    *usersettings.FuelConsumptionUnit  `json:"fuelConsumptionUnitNEQ,omitempty"`
	FuelConsumptionUnitIn     []usersettings.FuelConsumptionUnit `json:"fuelConsumptionUnitIn,omitempty"`
	FuelConsumptionUnitNotIn  []usersettings.FuelConsumptionUnit `json:"fuelConsumptionUnitNotIn,omitempty"`
	FuelConsumptionUnitIsNil  bool                               `json:"fuelConsumptionUnitIsNil,omitempty"`
	FuelConsumptionUnitNotNil bool                               `json:"fuelConsumptionUnitNotNil,omitempty"`

	// "temperature_unit" field predicates.
	TemperatureUnit       *usersettings.TemperatureUnit  `json:"temperatureUnit,omitempty"`
	TemperatureUnitNEQ    *usersettings.TemperatureUnit  `json:"temperatureUnitNEQ,omitempty"`
	TemperatureUnitIn     []usersettings.TemperatureUnit `json:"temperatureUnitIn,omitempty"`
	TemperatureUnitNotIn  []usersettings.TemperatureUnit `json:"temperatureUnitNotIn,omitempty"`
	TemperatureUnitIsNil  bool                           `json:"temperatureUnitIsNil,omitempty"`
	TemperatureUnitNotNil bool                           `json:"temperatureUnitNotNil,omitempty"`

	// "power_unit" field predicates.
	PowerUnit       *usersettings.PowerUnit  `json:"powerUnit,omitempty"`
	PowerUnitNEQ    *usersettings.PowerUnit  `json:"powerUnitNEQ,omitempty"`
	PowerUnitIn     []usersettings.PowerUnit `json:"powerUnitIn,omitempty"`
	PowerUnitNotIn  []usersettings.PowerUnit `json:"powerUnitNotIn,omitempty"`
	PowerUnitIsNil  bool                     `json:"powerUnitIsNil,omitempty"`
	PowerUnitNotNil bool                     `json:"powerUnitNotNil,omitempty"`

	// "torque_unit" field predicates.
	TorqueUnit       *usersettings.TorqueUnit  `json:"torqueUnit,omitempty"`
	TorqueUnitNEQ    *usersettings.TorqueUnit  `json:"torqueUnitNEQ,omitempty"`
	TorqueUnitIn     []usersettings.TorqueUnit `json:"torqueUnitIn,omitempty"`
	TorqueUnitNotIn  []usersettings.TorqueUnit `json:"torqueUnitNotIn,omitempty"`
	TorqueUnitIsNil  bool                      `json:"torqueUnitIsNil,omitempty"`
	TorqueUnitNotNil bool                      `json:"torqueUnitNotNil,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserSettingsWhereInput) AddPredicates(predicates ...predicate.UserSettings) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserSettingsWhereInput filter on the UserSettingsQuery builder.
func (i *UserSettingsWhereInput) Filter(q *UserSettingsQuery) (*UserSettingsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserSettingsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserSettingsWhereInput is returned in case the UserSettingsWhereInput is empty.
var ErrEmptyUserSettingsWhereInput = errors.New("ent: empty predicate UserSettingsWhereInput")

// P returns a predicate for filtering usersettingsslice.
// An error is returned if the input is empty or invalid.
func (i *UserSettingsWhereInput) P() (predicate.UserSettings, error) {
	var predicates []predicate.UserSettings
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, usersettings.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserSettings, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, usersettings.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserSettings, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, usersettings.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, usersettings.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, usersettings.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, usersettings.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, usersettings.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, usersettings.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, usersettings.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, usersettings.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, usersettings.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, usersettings.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, usersettings.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, usersettings.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, usersettings.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, usersettings.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, usersettings.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, usersettings.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, usersettings.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, usersettings.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, usersettings.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, usersettings.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, usersettings.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, usersettings.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, usersettings.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, usersettings.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, usersettings.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.CurrencyCode != nil {
		predicates = append(predicates, usersettings.CurrencyCodeEQ(*i.CurrencyCode))
	}
	if i.CurrencyCodeNEQ != nil {
		predicates = append(predicates, usersettings.CurrencyCodeNEQ(*i.CurrencyCodeNEQ))
	}
	if len(i.CurrencyCodeIn) > 0 {
		predicates = append(predicates, usersettings.CurrencyCodeIn(i.CurrencyCodeIn...))
	}
	if len(i.CurrencyCodeNotIn) > 0 {
		predicates = append(predicates, usersettings.CurrencyCodeNotIn(i.CurrencyCodeNotIn...))
	}
	if i.CurrencyCodeGT != nil {
		predicates = append(predicates, usersettings.CurrencyCodeGT(*i.CurrencyCodeGT))
	}
	if i.CurrencyCodeGTE != nil {
		predicates = append(predicates, usersettings.CurrencyCodeGTE(*i.CurrencyCodeGTE))
	}
	if i.CurrencyCodeLT != nil {
		predicates = append(predicates, usersettings.CurrencyCodeLT(*i.CurrencyCodeLT))
	}
	if i.CurrencyCodeLTE != nil {
		predicates = append(predicates, usersettings.CurrencyCodeLTE(*i.CurrencyCodeLTE))
	}
	if i.CurrencyCodeContains != nil {
		predicates = append(predicates, usersettings.CurrencyCodeContains(*i.CurrencyCodeContains))
	}
	if i.CurrencyCodeHasPrefix != nil {
		predicates = append(predicates, usersettings.CurrencyCodeHasPrefix(*i.CurrencyCodeHasPrefix))
	}
	if i.CurrencyCodeHasSuffix != nil {
		predicates = append(predicates, usersettings.CurrencyCodeHasSuffix(*i.CurrencyCodeHasSuffix))
	}
	if i.CurrencyCodeIsNil {
		predicates = append(predicates, usersettings.CurrencyCodeIsNil())
	}
	if i.CurrencyCodeNotNil {
		predicates = append(predicates, usersettings.CurrencyCodeNotNil())
	}
	if i.CurrencyCodeEqualFold != nil {
		predicates = append(predicates, usersettings.CurrencyCodeEqualFold(*i.CurrencyCodeEqualFold))
	}
	if i.CurrencyCodeContainsFold != nil {
		predicates = append(predicates, usersettings.CurrencyCodeContainsFold(*i.CurrencyCodeContainsFold))
	}
	if i.FuelVolumeUnit != nil {
		predicates = append(predicates, usersettings.FuelVolumeUnitEQ(*i.FuelVolumeUnit))
	}
	if i.FuelVolumeUnitNEQ != nil {
		predicates = append(predicates, usersettings.FuelVolumeUnitNEQ(*i.FuelVolumeUnitNEQ))
	}
	if len(i.FuelVolumeUnitIn) > 0 {
		predicates = append(predicates, usersettings.FuelVolumeUnitIn(i.FuelVolumeUnitIn...))
	}
	if len(i.FuelVolumeUnitNotIn) > 0 {
		predicates = append(predicates, usersettings.FuelVolumeUnitNotIn(i.FuelVolumeUnitNotIn...))
	}
	if i.FuelVolumeUnitIsNil {
		predicates = append(predicates, usersettings.FuelVolumeUnitIsNil())
	}
	if i.FuelVolumeUnitNotNil {
		predicates = append(predicates, usersettings.FuelVolumeUnitNotNil())
	}
	if i.DistanceUnit != nil {
		predicates = append(predicates, usersettings.DistanceUnitEQ(*i.DistanceUnit))
	}
	if i.DistanceUnitNEQ != nil {
		predicates = append(predicates, usersettings.DistanceUnitNEQ(*i.DistanceUnitNEQ))
	}
	if len(i.DistanceUnitIn) > 0 {
		predicates = append(predicates, usersettings.DistanceUnitIn(i.DistanceUnitIn...))
	}
	if len(i.DistanceUnitNotIn) > 0 {
		predicates = append(predicates, usersettings.DistanceUnitNotIn(i.DistanceUnitNotIn...))
	}
	if i.DistanceUnitIsNil {
		predicates = append(predicates, usersettings.DistanceUnitIsNil())
	}
	if i.DistanceUnitNotNil {
		predicates = append(predicates, usersettings.DistanceUnitNotNil())
	}
	if i.FuelConsumptionUnit != nil {
		predicates = append(predicates, usersettings.FuelConsumptionUnitEQ(*i.FuelConsumptionUnit))
	}
	if i.FuelConsumptionUnitNEQ != nil {
		predicates = append(predicates, usersettings.FuelConsumptionUnitNEQ(*i.FuelConsumptionUnitNEQ))
	}
	if len(i.FuelConsumptionUnitIn) > 0 {
		predicates = append(predicates, usersettings.FuelConsumptionUnitIn(i.FuelConsumptionUnitIn...))
	}
	if len(i.FuelConsumptionUnitNotIn) > 0 {
		predicates = append(predicates, usersettings.FuelConsumptionUnitNotIn(i.FuelConsumptionUnitNotIn...))
	}
	if i.FuelConsumptionUnitIsNil {
		predicates = append(predicates, usersettings.FuelConsumptionUnitIsNil())
	}
	if i.FuelConsumptionUnitNotNil {
		predicates = append(predicates, usersettings.FuelConsumptionUnitNotNil())
	}
	if i.TemperatureUnit != nil {
		predicates = append(predicates, usersettings.TemperatureUnitEQ(*i.TemperatureUnit))
	}
	if i.TemperatureUnitNEQ != nil {
		predicates = append(predicates, usersettings.TemperatureUnitNEQ(*i.TemperatureUnitNEQ))
	}
	if len(i.TemperatureUnitIn) > 0 {
		predicates = append(predicates, usersettings.TemperatureUnitIn(i.TemperatureUnitIn...))
	}
	if len(i.TemperatureUnitNotIn) > 0 {
		predicates = append(predicates, usersettings.TemperatureUnitNotIn(i.TemperatureUnitNotIn...))
	}
	if i.TemperatureUnitIsNil {
		predicates = append(predicates, usersettings.TemperatureUnitIsNil())
	}
	if i.TemperatureUnitNotNil {
		predicates = append(predicates, usersettings.TemperatureUnitNotNil())
	}
	if i.PowerUnit != nil {
		predicates = append(predicates, usersettings.PowerUnitEQ(*i.PowerUnit))
	}
	if i.PowerUnitNEQ != nil {
		predicates = append(predicates, usersettings.PowerUnitNEQ(*i.PowerUnitNEQ))
	}
	if len(i.PowerUnitIn) > 0 {
		predicates = append(predicates, usersettings.PowerUnitIn(i.PowerUnitIn...))
	}
	if len(i.PowerUnitNotIn) > 0 {
		predicates = append(predicates, usersettings.PowerUnitNotIn(i.PowerUnitNotIn...))
	}
	if i.PowerUnitIsNil {
		predicates = append(predicates, usersettings.PowerUnitIsNil())
	}
	if i.PowerUnitNotNil {
		predicates = append(predicates, usersettings.PowerUnitNotNil())
	}
	if i.TorqueUnit != nil {
		predicates = append(predicates, usersettings.TorqueUnitEQ(*i.TorqueUnit))
	}
	if i.TorqueUnitNEQ != nil {
		predicates = append(predicates, usersettings.TorqueUnitNEQ(*i.TorqueUnitNEQ))
	}
	if len(i.TorqueUnitIn) > 0 {
		predicates = append(predicates, usersettings.TorqueUnitIn(i.TorqueUnitIn...))
	}
	if len(i.TorqueUnitNotIn) > 0 {
		predicates = append(predicates, usersettings.TorqueUnitNotIn(i.TorqueUnitNotIn...))
	}
	if i.TorqueUnitIsNil {
		predicates = append(predicates, usersettings.TorqueUnitIsNil())
	}
	if i.TorqueUnitNotNil {
		predicates = append(predicates, usersettings.TorqueUnitNotNil())
	}

	if i.HasUser != nil {
		p := usersettings.HasUser()
		if !*i.HasUser {
			p = usersettings.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, usersettings.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserSettingsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return usersettings.And(predicates...), nil
	}
}

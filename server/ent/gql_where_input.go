// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/Dan6erbond/revline/ent/car"
	"github.com/Dan6erbond/revline/ent/document"
	"github.com/Dan6erbond/revline/ent/dragresult"
	"github.com/Dan6erbond/revline/ent/dragsession"
	"github.com/Dan6erbond/revline/ent/fuelup"
	"github.com/Dan6erbond/revline/ent/media"
	"github.com/Dan6erbond/revline/ent/odometerreading"
	"github.com/Dan6erbond/revline/ent/predicate"
	"github.com/Dan6erbond/revline/ent/profile"
	"github.com/Dan6erbond/revline/ent/serviceitem"
	"github.com/Dan6erbond/revline/ent/servicelog"
	"github.com/Dan6erbond/revline/ent/serviceschedule"
	"github.com/Dan6erbond/revline/ent/user"
	"github.com/google/uuid"
)

// CarWhereInput represents a where input for filtering Car queries.
type CarWhereInput struct {
	Predicates []predicate.Car  `json:"-"`
	Not        *CarWhereInput   `json:"not,omitempty"`
	Or         []*CarWhereInput `json:"or,omitempty"`
	And        []*CarWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "make" field predicates.
	Make             *string  `json:"make,omitempty"`
	MakeNEQ          *string  `json:"makeNEQ,omitempty"`
	MakeIn           []string `json:"makeIn,omitempty"`
	MakeNotIn        []string `json:"makeNotIn,omitempty"`
	MakeGT           *string  `json:"makeGT,omitempty"`
	MakeGTE          *string  `json:"makeGTE,omitempty"`
	MakeLT           *string  `json:"makeLT,omitempty"`
	MakeLTE          *string  `json:"makeLTE,omitempty"`
	MakeContains     *string  `json:"makeContains,omitempty"`
	MakeHasPrefix    *string  `json:"makeHasPrefix,omitempty"`
	MakeHasSuffix    *string  `json:"makeHasSuffix,omitempty"`
	MakeIsNil        bool     `json:"makeIsNil,omitempty"`
	MakeNotNil       bool     `json:"makeNotNil,omitempty"`
	MakeEqualFold    *string  `json:"makeEqualFold,omitempty"`
	MakeContainsFold *string  `json:"makeContainsFold,omitempty"`

	// "model" field predicates.
	Model             *string  `json:"model,omitempty"`
	ModelNEQ          *string  `json:"modelNEQ,omitempty"`
	ModelIn           []string `json:"modelIn,omitempty"`
	ModelNotIn        []string `json:"modelNotIn,omitempty"`
	ModelGT           *string  `json:"modelGT,omitempty"`
	ModelGTE          *string  `json:"modelGTE,omitempty"`
	ModelLT           *string  `json:"modelLT,omitempty"`
	ModelLTE          *string  `json:"modelLTE,omitempty"`
	ModelContains     *string  `json:"modelContains,omitempty"`
	ModelHasPrefix    *string  `json:"modelHasPrefix,omitempty"`
	ModelHasSuffix    *string  `json:"modelHasSuffix,omitempty"`
	ModelIsNil        bool     `json:"modelIsNil,omitempty"`
	ModelNotNil       bool     `json:"modelNotNil,omitempty"`
	ModelEqualFold    *string  `json:"modelEqualFold,omitempty"`
	ModelContainsFold *string  `json:"modelContainsFold,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeIsNil        bool     `json:"typeIsNil,omitempty"`
	TypeNotNil       bool     `json:"typeNotNil,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "year" field predicates.
	Year       *int  `json:"year,omitempty"`
	YearNEQ    *int  `json:"yearNEQ,omitempty"`
	YearIn     []int `json:"yearIn,omitempty"`
	YearNotIn  []int `json:"yearNotIn,omitempty"`
	YearGT     *int  `json:"yearGT,omitempty"`
	YearGTE    *int  `json:"yearGTE,omitempty"`
	YearLT     *int  `json:"yearLT,omitempty"`
	YearLTE    *int  `json:"yearLTE,omitempty"`
	YearIsNil  bool  `json:"yearIsNil,omitempty"`
	YearNotNil bool  `json:"yearNotNil,omitempty"`

	// "trim" field predicates.
	Trim             *string  `json:"trim,omitempty"`
	TrimNEQ          *string  `json:"trimNEQ,omitempty"`
	TrimIn           []string `json:"trimIn,omitempty"`
	TrimNotIn        []string `json:"trimNotIn,omitempty"`
	TrimGT           *string  `json:"trimGT,omitempty"`
	TrimGTE          *string  `json:"trimGTE,omitempty"`
	TrimLT           *string  `json:"trimLT,omitempty"`
	TrimLTE          *string  `json:"trimLTE,omitempty"`
	TrimContains     *string  `json:"trimContains,omitempty"`
	TrimHasPrefix    *string  `json:"trimHasPrefix,omitempty"`
	TrimHasSuffix    *string  `json:"trimHasSuffix,omitempty"`
	TrimIsNil        bool     `json:"trimIsNil,omitempty"`
	TrimNotNil       bool     `json:"trimNotNil,omitempty"`
	TrimEqualFold    *string  `json:"trimEqualFold,omitempty"`
	TrimContainsFold *string  `json:"trimContainsFold,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`

	// "drag_sessions" edge predicates.
	HasDragSessions     *bool                    `json:"hasDragSessions,omitempty"`
	HasDragSessionsWith []*DragSessionWhereInput `json:"hasDragSessionsWith,omitempty"`

	// "fuel_ups" edge predicates.
	HasFuelUps     *bool               `json:"hasFuelUps,omitempty"`
	HasFuelUpsWith []*FuelUpWhereInput `json:"hasFuelUpsWith,omitempty"`

	// "odometer_readings" edge predicates.
	HasOdometerReadings     *bool                        `json:"hasOdometerReadings,omitempty"`
	HasOdometerReadingsWith []*OdometerReadingWhereInput `json:"hasOdometerReadingsWith,omitempty"`

	// "service_items" edge predicates.
	HasServiceItems     *bool                    `json:"hasServiceItems,omitempty"`
	HasServiceItemsWith []*ServiceItemWhereInput `json:"hasServiceItemsWith,omitempty"`

	// "service_logs" edge predicates.
	HasServiceLogs     *bool                   `json:"hasServiceLogs,omitempty"`
	HasServiceLogsWith []*ServiceLogWhereInput `json:"hasServiceLogsWith,omitempty"`

	// "service_schedules" edge predicates.
	HasServiceSchedules     *bool                        `json:"hasServiceSchedules,omitempty"`
	HasServiceSchedulesWith []*ServiceScheduleWhereInput `json:"hasServiceSchedulesWith,omitempty"`

	// "media" edge predicates.
	HasMedia     *bool              `json:"hasMedia,omitempty"`
	HasMediaWith []*MediaWhereInput `json:"hasMediaWith,omitempty"`

	// "documents" edge predicates.
	HasDocuments     *bool                 `json:"hasDocuments,omitempty"`
	HasDocumentsWith []*DocumentWhereInput `json:"hasDocumentsWith,omitempty"`

	// "banner_image" edge predicates.
	HasBannerImage     *bool              `json:"hasBannerImage,omitempty"`
	HasBannerImageWith []*MediaWhereInput `json:"hasBannerImageWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarWhereInput) AddPredicates(predicates ...predicate.Car) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarWhereInput filter on the CarQuery builder.
func (i *CarWhereInput) Filter(q *CarQuery) (*CarQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarWhereInput is returned in case the CarWhereInput is empty.
var ErrEmptyCarWhereInput = errors.New("ent: empty predicate CarWhereInput")

// P returns a predicate for filtering cars.
// An error is returned if the input is empty or invalid.
func (i *CarWhereInput) P() (predicate.Car, error) {
	var predicates []predicate.Car
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, car.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Car, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, car.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Car, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, car.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, car.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, car.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, car.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, car.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, car.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, car.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, car.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, car.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, car.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, car.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, car.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, car.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, car.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, car.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, car.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, car.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, car.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, car.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, car.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, car.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, car.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, car.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, car.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, car.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, car.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, car.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, car.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, car.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, car.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, car.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, car.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, car.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, car.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, car.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, car.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, car.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, car.NameContainsFold(*i.NameContainsFold))
	}
	if i.Make != nil {
		predicates = append(predicates, car.MakeEQ(*i.Make))
	}
	if i.MakeNEQ != nil {
		predicates = append(predicates, car.MakeNEQ(*i.MakeNEQ))
	}
	if len(i.MakeIn) > 0 {
		predicates = append(predicates, car.MakeIn(i.MakeIn...))
	}
	if len(i.MakeNotIn) > 0 {
		predicates = append(predicates, car.MakeNotIn(i.MakeNotIn...))
	}
	if i.MakeGT != nil {
		predicates = append(predicates, car.MakeGT(*i.MakeGT))
	}
	if i.MakeGTE != nil {
		predicates = append(predicates, car.MakeGTE(*i.MakeGTE))
	}
	if i.MakeLT != nil {
		predicates = append(predicates, car.MakeLT(*i.MakeLT))
	}
	if i.MakeLTE != nil {
		predicates = append(predicates, car.MakeLTE(*i.MakeLTE))
	}
	if i.MakeContains != nil {
		predicates = append(predicates, car.MakeContains(*i.MakeContains))
	}
	if i.MakeHasPrefix != nil {
		predicates = append(predicates, car.MakeHasPrefix(*i.MakeHasPrefix))
	}
	if i.MakeHasSuffix != nil {
		predicates = append(predicates, car.MakeHasSuffix(*i.MakeHasSuffix))
	}
	if i.MakeIsNil {
		predicates = append(predicates, car.MakeIsNil())
	}
	if i.MakeNotNil {
		predicates = append(predicates, car.MakeNotNil())
	}
	if i.MakeEqualFold != nil {
		predicates = append(predicates, car.MakeEqualFold(*i.MakeEqualFold))
	}
	if i.MakeContainsFold != nil {
		predicates = append(predicates, car.MakeContainsFold(*i.MakeContainsFold))
	}
	if i.Model != nil {
		predicates = append(predicates, car.ModelEQ(*i.Model))
	}
	if i.ModelNEQ != nil {
		predicates = append(predicates, car.ModelNEQ(*i.ModelNEQ))
	}
	if len(i.ModelIn) > 0 {
		predicates = append(predicates, car.ModelIn(i.ModelIn...))
	}
	if len(i.ModelNotIn) > 0 {
		predicates = append(predicates, car.ModelNotIn(i.ModelNotIn...))
	}
	if i.ModelGT != nil {
		predicates = append(predicates, car.ModelGT(*i.ModelGT))
	}
	if i.ModelGTE != nil {
		predicates = append(predicates, car.ModelGTE(*i.ModelGTE))
	}
	if i.ModelLT != nil {
		predicates = append(predicates, car.ModelLT(*i.ModelLT))
	}
	if i.ModelLTE != nil {
		predicates = append(predicates, car.ModelLTE(*i.ModelLTE))
	}
	if i.ModelContains != nil {
		predicates = append(predicates, car.ModelContains(*i.ModelContains))
	}
	if i.ModelHasPrefix != nil {
		predicates = append(predicates, car.ModelHasPrefix(*i.ModelHasPrefix))
	}
	if i.ModelHasSuffix != nil {
		predicates = append(predicates, car.ModelHasSuffix(*i.ModelHasSuffix))
	}
	if i.ModelIsNil {
		predicates = append(predicates, car.ModelIsNil())
	}
	if i.ModelNotNil {
		predicates = append(predicates, car.ModelNotNil())
	}
	if i.ModelEqualFold != nil {
		predicates = append(predicates, car.ModelEqualFold(*i.ModelEqualFold))
	}
	if i.ModelContainsFold != nil {
		predicates = append(predicates, car.ModelContainsFold(*i.ModelContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, car.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, car.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, car.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, car.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, car.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, car.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, car.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, car.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, car.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, car.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, car.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeIsNil {
		predicates = append(predicates, car.TypeIsNil())
	}
	if i.TypeNotNil {
		predicates = append(predicates, car.TypeNotNil())
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, car.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, car.TypeContainsFold(*i.TypeContainsFold))
	}
	if i.Year != nil {
		predicates = append(predicates, car.YearEQ(*i.Year))
	}
	if i.YearNEQ != nil {
		predicates = append(predicates, car.YearNEQ(*i.YearNEQ))
	}
	if len(i.YearIn) > 0 {
		predicates = append(predicates, car.YearIn(i.YearIn...))
	}
	if len(i.YearNotIn) > 0 {
		predicates = append(predicates, car.YearNotIn(i.YearNotIn...))
	}
	if i.YearGT != nil {
		predicates = append(predicates, car.YearGT(*i.YearGT))
	}
	if i.YearGTE != nil {
		predicates = append(predicates, car.YearGTE(*i.YearGTE))
	}
	if i.YearLT != nil {
		predicates = append(predicates, car.YearLT(*i.YearLT))
	}
	if i.YearLTE != nil {
		predicates = append(predicates, car.YearLTE(*i.YearLTE))
	}
	if i.YearIsNil {
		predicates = append(predicates, car.YearIsNil())
	}
	if i.YearNotNil {
		predicates = append(predicates, car.YearNotNil())
	}
	if i.Trim != nil {
		predicates = append(predicates, car.TrimEQ(*i.Trim))
	}
	if i.TrimNEQ != nil {
		predicates = append(predicates, car.TrimNEQ(*i.TrimNEQ))
	}
	if len(i.TrimIn) > 0 {
		predicates = append(predicates, car.TrimIn(i.TrimIn...))
	}
	if len(i.TrimNotIn) > 0 {
		predicates = append(predicates, car.TrimNotIn(i.TrimNotIn...))
	}
	if i.TrimGT != nil {
		predicates = append(predicates, car.TrimGT(*i.TrimGT))
	}
	if i.TrimGTE != nil {
		predicates = append(predicates, car.TrimGTE(*i.TrimGTE))
	}
	if i.TrimLT != nil {
		predicates = append(predicates, car.TrimLT(*i.TrimLT))
	}
	if i.TrimLTE != nil {
		predicates = append(predicates, car.TrimLTE(*i.TrimLTE))
	}
	if i.TrimContains != nil {
		predicates = append(predicates, car.TrimContains(*i.TrimContains))
	}
	if i.TrimHasPrefix != nil {
		predicates = append(predicates, car.TrimHasPrefix(*i.TrimHasPrefix))
	}
	if i.TrimHasSuffix != nil {
		predicates = append(predicates, car.TrimHasSuffix(*i.TrimHasSuffix))
	}
	if i.TrimIsNil {
		predicates = append(predicates, car.TrimIsNil())
	}
	if i.TrimNotNil {
		predicates = append(predicates, car.TrimNotNil())
	}
	if i.TrimEqualFold != nil {
		predicates = append(predicates, car.TrimEqualFold(*i.TrimEqualFold))
	}
	if i.TrimContainsFold != nil {
		predicates = append(predicates, car.TrimContainsFold(*i.TrimContainsFold))
	}

	if i.HasOwner != nil {
		p := car.HasOwner()
		if !*i.HasOwner {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasOwnerWith(with...))
	}
	if i.HasDragSessions != nil {
		p := car.HasDragSessions()
		if !*i.HasDragSessions {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDragSessionsWith) > 0 {
		with := make([]predicate.DragSession, 0, len(i.HasDragSessionsWith))
		for _, w := range i.HasDragSessionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDragSessionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasDragSessionsWith(with...))
	}
	if i.HasFuelUps != nil {
		p := car.HasFuelUps()
		if !*i.HasFuelUps {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFuelUpsWith) > 0 {
		with := make([]predicate.FuelUp, 0, len(i.HasFuelUpsWith))
		for _, w := range i.HasFuelUpsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFuelUpsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasFuelUpsWith(with...))
	}
	if i.HasOdometerReadings != nil {
		p := car.HasOdometerReadings()
		if !*i.HasOdometerReadings {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOdometerReadingsWith) > 0 {
		with := make([]predicate.OdometerReading, 0, len(i.HasOdometerReadingsWith))
		for _, w := range i.HasOdometerReadingsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOdometerReadingsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasOdometerReadingsWith(with...))
	}
	if i.HasServiceItems != nil {
		p := car.HasServiceItems()
		if !*i.HasServiceItems {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServiceItemsWith) > 0 {
		with := make([]predicate.ServiceItem, 0, len(i.HasServiceItemsWith))
		for _, w := range i.HasServiceItemsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServiceItemsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasServiceItemsWith(with...))
	}
	if i.HasServiceLogs != nil {
		p := car.HasServiceLogs()
		if !*i.HasServiceLogs {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServiceLogsWith) > 0 {
		with := make([]predicate.ServiceLog, 0, len(i.HasServiceLogsWith))
		for _, w := range i.HasServiceLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServiceLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasServiceLogsWith(with...))
	}
	if i.HasServiceSchedules != nil {
		p := car.HasServiceSchedules()
		if !*i.HasServiceSchedules {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServiceSchedulesWith) > 0 {
		with := make([]predicate.ServiceSchedule, 0, len(i.HasServiceSchedulesWith))
		for _, w := range i.HasServiceSchedulesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServiceSchedulesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasServiceSchedulesWith(with...))
	}
	if i.HasMedia != nil {
		p := car.HasMedia()
		if !*i.HasMedia {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMediaWith) > 0 {
		with := make([]predicate.Media, 0, len(i.HasMediaWith))
		for _, w := range i.HasMediaWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMediaWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasMediaWith(with...))
	}
	if i.HasDocuments != nil {
		p := car.HasDocuments()
		if !*i.HasDocuments {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDocumentsWith) > 0 {
		with := make([]predicate.Document, 0, len(i.HasDocumentsWith))
		for _, w := range i.HasDocumentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDocumentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasDocumentsWith(with...))
	}
	if i.HasBannerImage != nil {
		p := car.HasBannerImage()
		if !*i.HasBannerImage {
			p = car.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBannerImageWith) > 0 {
		with := make([]predicate.Media, 0, len(i.HasBannerImageWith))
		for _, w := range i.HasBannerImageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBannerImageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, car.HasBannerImageWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarWhereInput
	case 1:
		return predicates[0], nil
	default:
		return car.And(predicates...), nil
	}
}

// DocumentWhereInput represents a where input for filtering Document queries.
type DocumentWhereInput struct {
	Predicates []predicate.Document  `json:"-"`
	Not        *DocumentWhereInput   `json:"not,omitempty"`
	Or         []*DocumentWhereInput `json:"or,omitempty"`
	And        []*DocumentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DocumentWhereInput) AddPredicates(predicates ...predicate.Document) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DocumentWhereInput filter on the DocumentQuery builder.
func (i *DocumentWhereInput) Filter(q *DocumentQuery) (*DocumentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDocumentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDocumentWhereInput is returned in case the DocumentWhereInput is empty.
var ErrEmptyDocumentWhereInput = errors.New("ent: empty predicate DocumentWhereInput")

// P returns a predicate for filtering documents.
// An error is returned if the input is empty or invalid.
func (i *DocumentWhereInput) P() (predicate.Document, error) {
	var predicates []predicate.Document
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, document.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Document, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, document.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Document, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, document.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, document.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, document.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, document.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, document.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, document.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, document.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, document.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, document.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, document.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, document.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, document.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, document.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, document.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, document.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, document.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, document.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, document.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, document.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, document.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, document.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, document.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, document.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, document.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, document.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, document.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, document.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, document.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, document.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, document.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, document.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, document.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, document.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, document.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, document.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, document.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, document.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, document.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasCar != nil {
		p := document.HasCar()
		if !*i.HasCar {
			p = document.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, document.HasCarWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDocumentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return document.And(predicates...), nil
	}
}

// DragResultWhereInput represents a where input for filtering DragResult queries.
type DragResultWhereInput struct {
	Predicates []predicate.DragResult  `json:"-"`
	Not        *DragResultWhereInput   `json:"not,omitempty"`
	Or         []*DragResultWhereInput `json:"or,omitempty"`
	And        []*DragResultWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "unit" field predicates.
	Unit      *dragresult.Unit  `json:"unit,omitempty"`
	UnitNEQ   *dragresult.Unit  `json:"unitNEQ,omitempty"`
	UnitIn    []dragresult.Unit `json:"unitIn,omitempty"`
	UnitNotIn []dragresult.Unit `json:"unitNotIn,omitempty"`

	// "value" field predicates.
	Value      *float64  `json:"value,omitempty"`
	ValueNEQ   *float64  `json:"valueNEQ,omitempty"`
	ValueIn    []float64 `json:"valueIn,omitempty"`
	ValueNotIn []float64 `json:"valueNotIn,omitempty"`
	ValueGT    *float64  `json:"valueGT,omitempty"`
	ValueGTE   *float64  `json:"valueGTE,omitempty"`
	ValueLT    *float64  `json:"valueLT,omitempty"`
	ValueLTE   *float64  `json:"valueLTE,omitempty"`

	// "result" field predicates.
	Result      *float64  `json:"result,omitempty"`
	ResultNEQ   *float64  `json:"resultNEQ,omitempty"`
	ResultIn    []float64 `json:"resultIn,omitempty"`
	ResultNotIn []float64 `json:"resultNotIn,omitempty"`
	ResultGT    *float64  `json:"resultGT,omitempty"`
	ResultGTE   *float64  `json:"resultGTE,omitempty"`
	ResultLT    *float64  `json:"resultLT,omitempty"`
	ResultLTE   *float64  `json:"resultLTE,omitempty"`

	// "session" edge predicates.
	HasSession     *bool                    `json:"hasSession,omitempty"`
	HasSessionWith []*DragSessionWhereInput `json:"hasSessionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DragResultWhereInput) AddPredicates(predicates ...predicate.DragResult) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DragResultWhereInput filter on the DragResultQuery builder.
func (i *DragResultWhereInput) Filter(q *DragResultQuery) (*DragResultQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDragResultWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDragResultWhereInput is returned in case the DragResultWhereInput is empty.
var ErrEmptyDragResultWhereInput = errors.New("ent: empty predicate DragResultWhereInput")

// P returns a predicate for filtering dragresults.
// An error is returned if the input is empty or invalid.
func (i *DragResultWhereInput) P() (predicate.DragResult, error) {
	var predicates []predicate.DragResult
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, dragresult.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DragResult, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, dragresult.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DragResult, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, dragresult.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, dragresult.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, dragresult.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, dragresult.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, dragresult.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, dragresult.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, dragresult.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, dragresult.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, dragresult.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, dragresult.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, dragresult.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, dragresult.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, dragresult.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, dragresult.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, dragresult.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, dragresult.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, dragresult.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, dragresult.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, dragresult.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, dragresult.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, dragresult.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, dragresult.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, dragresult.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, dragresult.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, dragresult.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Unit != nil {
		predicates = append(predicates, dragresult.UnitEQ(*i.Unit))
	}
	if i.UnitNEQ != nil {
		predicates = append(predicates, dragresult.UnitNEQ(*i.UnitNEQ))
	}
	if len(i.UnitIn) > 0 {
		predicates = append(predicates, dragresult.UnitIn(i.UnitIn...))
	}
	if len(i.UnitNotIn) > 0 {
		predicates = append(predicates, dragresult.UnitNotIn(i.UnitNotIn...))
	}
	if i.Value != nil {
		predicates = append(predicates, dragresult.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, dragresult.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, dragresult.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, dragresult.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, dragresult.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, dragresult.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, dragresult.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, dragresult.ValueLTE(*i.ValueLTE))
	}
	if i.Result != nil {
		predicates = append(predicates, dragresult.ResultEQ(*i.Result))
	}
	if i.ResultNEQ != nil {
		predicates = append(predicates, dragresult.ResultNEQ(*i.ResultNEQ))
	}
	if len(i.ResultIn) > 0 {
		predicates = append(predicates, dragresult.ResultIn(i.ResultIn...))
	}
	if len(i.ResultNotIn) > 0 {
		predicates = append(predicates, dragresult.ResultNotIn(i.ResultNotIn...))
	}
	if i.ResultGT != nil {
		predicates = append(predicates, dragresult.ResultGT(*i.ResultGT))
	}
	if i.ResultGTE != nil {
		predicates = append(predicates, dragresult.ResultGTE(*i.ResultGTE))
	}
	if i.ResultLT != nil {
		predicates = append(predicates, dragresult.ResultLT(*i.ResultLT))
	}
	if i.ResultLTE != nil {
		predicates = append(predicates, dragresult.ResultLTE(*i.ResultLTE))
	}

	if i.HasSession != nil {
		p := dragresult.HasSession()
		if !*i.HasSession {
			p = dragresult.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSessionWith) > 0 {
		with := make([]predicate.DragSession, 0, len(i.HasSessionWith))
		for _, w := range i.HasSessionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSessionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dragresult.HasSessionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDragResultWhereInput
	case 1:
		return predicates[0], nil
	default:
		return dragresult.And(predicates...), nil
	}
}

// DragSessionWhereInput represents a where input for filtering DragSession queries.
type DragSessionWhereInput struct {
	Predicates []predicate.DragSession  `json:"-"`
	Not        *DragSessionWhereInput   `json:"not,omitempty"`
	Or         []*DragSessionWhereInput `json:"or,omitempty"`
	And        []*DragSessionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesIsNil        bool     `json:"notesIsNil,omitempty"`
	NotesNotNil       bool     `json:"notesNotNil,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "results" edge predicates.
	HasResults     *bool                   `json:"hasResults,omitempty"`
	HasResultsWith []*DragResultWhereInput `json:"hasResultsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DragSessionWhereInput) AddPredicates(predicates ...predicate.DragSession) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DragSessionWhereInput filter on the DragSessionQuery builder.
func (i *DragSessionWhereInput) Filter(q *DragSessionQuery) (*DragSessionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDragSessionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDragSessionWhereInput is returned in case the DragSessionWhereInput is empty.
var ErrEmptyDragSessionWhereInput = errors.New("ent: empty predicate DragSessionWhereInput")

// P returns a predicate for filtering dragsessions.
// An error is returned if the input is empty or invalid.
func (i *DragSessionWhereInput) P() (predicate.DragSession, error) {
	var predicates []predicate.DragSession
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, dragsession.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DragSession, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, dragsession.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DragSession, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, dragsession.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, dragsession.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, dragsession.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, dragsession.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, dragsession.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, dragsession.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, dragsession.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, dragsession.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, dragsession.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, dragsession.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, dragsession.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, dragsession.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, dragsession.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, dragsession.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, dragsession.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, dragsession.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, dragsession.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, dragsession.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, dragsession.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, dragsession.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, dragsession.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, dragsession.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, dragsession.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, dragsession.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, dragsession.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, dragsession.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, dragsession.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, dragsession.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, dragsession.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, dragsession.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, dragsession.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, dragsession.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, dragsession.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, dragsession.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, dragsession.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, dragsession.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, dragsession.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, dragsession.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Notes != nil {
		predicates = append(predicates, dragsession.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, dragsession.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, dragsession.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, dragsession.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, dragsession.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, dragsession.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, dragsession.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, dragsession.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, dragsession.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, dragsession.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, dragsession.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesIsNil {
		predicates = append(predicates, dragsession.NotesIsNil())
	}
	if i.NotesNotNil {
		predicates = append(predicates, dragsession.NotesNotNil())
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, dragsession.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, dragsession.NotesContainsFold(*i.NotesContainsFold))
	}

	if i.HasCar != nil {
		p := dragsession.HasCar()
		if !*i.HasCar {
			p = dragsession.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dragsession.HasCarWith(with...))
	}
	if i.HasResults != nil {
		p := dragsession.HasResults()
		if !*i.HasResults {
			p = dragsession.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasResultsWith) > 0 {
		with := make([]predicate.DragResult, 0, len(i.HasResultsWith))
		for _, w := range i.HasResultsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasResultsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dragsession.HasResultsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDragSessionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return dragsession.And(predicates...), nil
	}
}

// FuelUpWhereInput represents a where input for filtering FuelUp queries.
type FuelUpWhereInput struct {
	Predicates []predicate.FuelUp  `json:"-"`
	Not        *FuelUpWhereInput   `json:"not,omitempty"`
	Or         []*FuelUpWhereInput `json:"or,omitempty"`
	And        []*FuelUpWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "occurred_at" field predicates.
	OccurredAt      *time.Time  `json:"occurredAt,omitempty"`
	OccurredAtNEQ   *time.Time  `json:"occurredAtNEQ,omitempty"`
	OccurredAtIn    []time.Time `json:"occurredAtIn,omitempty"`
	OccurredAtNotIn []time.Time `json:"occurredAtNotIn,omitempty"`
	OccurredAtGT    *time.Time  `json:"occurredAtGT,omitempty"`
	OccurredAtGTE   *time.Time  `json:"occurredAtGTE,omitempty"`
	OccurredAtLT    *time.Time  `json:"occurredAtLT,omitempty"`
	OccurredAtLTE   *time.Time  `json:"occurredAtLTE,omitempty"`

	// "station" field predicates.
	Station             *string  `json:"station,omitempty"`
	StationNEQ          *string  `json:"stationNEQ,omitempty"`
	StationIn           []string `json:"stationIn,omitempty"`
	StationNotIn        []string `json:"stationNotIn,omitempty"`
	StationGT           *string  `json:"stationGT,omitempty"`
	StationGTE          *string  `json:"stationGTE,omitempty"`
	StationLT           *string  `json:"stationLT,omitempty"`
	StationLTE          *string  `json:"stationLTE,omitempty"`
	StationContains     *string  `json:"stationContains,omitempty"`
	StationHasPrefix    *string  `json:"stationHasPrefix,omitempty"`
	StationHasSuffix    *string  `json:"stationHasSuffix,omitempty"`
	StationEqualFold    *string  `json:"stationEqualFold,omitempty"`
	StationContainsFold *string  `json:"stationContainsFold,omitempty"`

	// "amount_liters" field predicates.
	AmountLiters      *float64  `json:"amountLiters,omitempty"`
	AmountLitersNEQ   *float64  `json:"amountLitersNEQ,omitempty"`
	AmountLitersIn    []float64 `json:"amountLitersIn,omitempty"`
	AmountLitersNotIn []float64 `json:"amountLitersNotIn,omitempty"`
	AmountLitersGT    *float64  `json:"amountLitersGT,omitempty"`
	AmountLitersGTE   *float64  `json:"amountLitersGTE,omitempty"`
	AmountLitersLT    *float64  `json:"amountLitersLT,omitempty"`
	AmountLitersLTE   *float64  `json:"amountLitersLTE,omitempty"`

	// "cost" field predicates.
	Cost      *float64  `json:"cost,omitempty"`
	CostNEQ   *float64  `json:"costNEQ,omitempty"`
	CostIn    []float64 `json:"costIn,omitempty"`
	CostNotIn []float64 `json:"costNotIn,omitempty"`
	CostGT    *float64  `json:"costGT,omitempty"`
	CostGTE   *float64  `json:"costGTE,omitempty"`
	CostLT    *float64  `json:"costLT,omitempty"`
	CostLTE   *float64  `json:"costLTE,omitempty"`

	// "fuel_category" field predicates.
	FuelCategory      *fuelup.FuelCategory  `json:"fuelCategory,omitempty"`
	FuelCategoryNEQ   *fuelup.FuelCategory  `json:"fuelCategoryNEQ,omitempty"`
	FuelCategoryIn    []fuelup.FuelCategory `json:"fuelCategoryIn,omitempty"`
	FuelCategoryNotIn []fuelup.FuelCategory `json:"fuelCategoryNotIn,omitempty"`

	// "octane_rating" field predicates.
	OctaneRating       *fuelup.OctaneRating  `json:"octaneRating,omitempty"`
	OctaneRatingNEQ    *fuelup.OctaneRating  `json:"octaneRatingNEQ,omitempty"`
	OctaneRatingIn     []fuelup.OctaneRating `json:"octaneRatingIn,omitempty"`
	OctaneRatingNotIn  []fuelup.OctaneRating `json:"octaneRatingNotIn,omitempty"`
	OctaneRatingIsNil  bool                  `json:"octaneRatingIsNil,omitempty"`
	OctaneRatingNotNil bool                  `json:"octaneRatingNotNil,omitempty"`

	// "is_full_tank" field predicates.
	IsFullTank    *bool `json:"isFullTank,omitempty"`
	IsFullTankNEQ *bool `json:"isFullTankNEQ,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesIsNil        bool     `json:"notesIsNil,omitempty"`
	NotesNotNil       bool     `json:"notesNotNil,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "odometer_reading" edge predicates.
	HasOdometerReading     *bool                        `json:"hasOdometerReading,omitempty"`
	HasOdometerReadingWith []*OdometerReadingWhereInput `json:"hasOdometerReadingWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FuelUpWhereInput) AddPredicates(predicates ...predicate.FuelUp) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FuelUpWhereInput filter on the FuelUpQuery builder.
func (i *FuelUpWhereInput) Filter(q *FuelUpQuery) (*FuelUpQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFuelUpWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFuelUpWhereInput is returned in case the FuelUpWhereInput is empty.
var ErrEmptyFuelUpWhereInput = errors.New("ent: empty predicate FuelUpWhereInput")

// P returns a predicate for filtering fuelups.
// An error is returned if the input is empty or invalid.
func (i *FuelUpWhereInput) P() (predicate.FuelUp, error) {
	var predicates []predicate.FuelUp
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, fuelup.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.FuelUp, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, fuelup.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.FuelUp, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, fuelup.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, fuelup.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, fuelup.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, fuelup.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, fuelup.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, fuelup.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, fuelup.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, fuelup.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, fuelup.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, fuelup.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, fuelup.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, fuelup.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, fuelup.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, fuelup.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, fuelup.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, fuelup.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, fuelup.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, fuelup.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, fuelup.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, fuelup.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, fuelup.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, fuelup.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, fuelup.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, fuelup.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, fuelup.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.OccurredAt != nil {
		predicates = append(predicates, fuelup.OccurredAtEQ(*i.OccurredAt))
	}
	if i.OccurredAtNEQ != nil {
		predicates = append(predicates, fuelup.OccurredAtNEQ(*i.OccurredAtNEQ))
	}
	if len(i.OccurredAtIn) > 0 {
		predicates = append(predicates, fuelup.OccurredAtIn(i.OccurredAtIn...))
	}
	if len(i.OccurredAtNotIn) > 0 {
		predicates = append(predicates, fuelup.OccurredAtNotIn(i.OccurredAtNotIn...))
	}
	if i.OccurredAtGT != nil {
		predicates = append(predicates, fuelup.OccurredAtGT(*i.OccurredAtGT))
	}
	if i.OccurredAtGTE != nil {
		predicates = append(predicates, fuelup.OccurredAtGTE(*i.OccurredAtGTE))
	}
	if i.OccurredAtLT != nil {
		predicates = append(predicates, fuelup.OccurredAtLT(*i.OccurredAtLT))
	}
	if i.OccurredAtLTE != nil {
		predicates = append(predicates, fuelup.OccurredAtLTE(*i.OccurredAtLTE))
	}
	if i.Station != nil {
		predicates = append(predicates, fuelup.StationEQ(*i.Station))
	}
	if i.StationNEQ != nil {
		predicates = append(predicates, fuelup.StationNEQ(*i.StationNEQ))
	}
	if len(i.StationIn) > 0 {
		predicates = append(predicates, fuelup.StationIn(i.StationIn...))
	}
	if len(i.StationNotIn) > 0 {
		predicates = append(predicates, fuelup.StationNotIn(i.StationNotIn...))
	}
	if i.StationGT != nil {
		predicates = append(predicates, fuelup.StationGT(*i.StationGT))
	}
	if i.StationGTE != nil {
		predicates = append(predicates, fuelup.StationGTE(*i.StationGTE))
	}
	if i.StationLT != nil {
		predicates = append(predicates, fuelup.StationLT(*i.StationLT))
	}
	if i.StationLTE != nil {
		predicates = append(predicates, fuelup.StationLTE(*i.StationLTE))
	}
	if i.StationContains != nil {
		predicates = append(predicates, fuelup.StationContains(*i.StationContains))
	}
	if i.StationHasPrefix != nil {
		predicates = append(predicates, fuelup.StationHasPrefix(*i.StationHasPrefix))
	}
	if i.StationHasSuffix != nil {
		predicates = append(predicates, fuelup.StationHasSuffix(*i.StationHasSuffix))
	}
	if i.StationEqualFold != nil {
		predicates = append(predicates, fuelup.StationEqualFold(*i.StationEqualFold))
	}
	if i.StationContainsFold != nil {
		predicates = append(predicates, fuelup.StationContainsFold(*i.StationContainsFold))
	}
	if i.AmountLiters != nil {
		predicates = append(predicates, fuelup.AmountLitersEQ(*i.AmountLiters))
	}
	if i.AmountLitersNEQ != nil {
		predicates = append(predicates, fuelup.AmountLitersNEQ(*i.AmountLitersNEQ))
	}
	if len(i.AmountLitersIn) > 0 {
		predicates = append(predicates, fuelup.AmountLitersIn(i.AmountLitersIn...))
	}
	if len(i.AmountLitersNotIn) > 0 {
		predicates = append(predicates, fuelup.AmountLitersNotIn(i.AmountLitersNotIn...))
	}
	if i.AmountLitersGT != nil {
		predicates = append(predicates, fuelup.AmountLitersGT(*i.AmountLitersGT))
	}
	if i.AmountLitersGTE != nil {
		predicates = append(predicates, fuelup.AmountLitersGTE(*i.AmountLitersGTE))
	}
	if i.AmountLitersLT != nil {
		predicates = append(predicates, fuelup.AmountLitersLT(*i.AmountLitersLT))
	}
	if i.AmountLitersLTE != nil {
		predicates = append(predicates, fuelup.AmountLitersLTE(*i.AmountLitersLTE))
	}
	if i.Cost != nil {
		predicates = append(predicates, fuelup.CostEQ(*i.Cost))
	}
	if i.CostNEQ != nil {
		predicates = append(predicates, fuelup.CostNEQ(*i.CostNEQ))
	}
	if len(i.CostIn) > 0 {
		predicates = append(predicates, fuelup.CostIn(i.CostIn...))
	}
	if len(i.CostNotIn) > 0 {
		predicates = append(predicates, fuelup.CostNotIn(i.CostNotIn...))
	}
	if i.CostGT != nil {
		predicates = append(predicates, fuelup.CostGT(*i.CostGT))
	}
	if i.CostGTE != nil {
		predicates = append(predicates, fuelup.CostGTE(*i.CostGTE))
	}
	if i.CostLT != nil {
		predicates = append(predicates, fuelup.CostLT(*i.CostLT))
	}
	if i.CostLTE != nil {
		predicates = append(predicates, fuelup.CostLTE(*i.CostLTE))
	}
	if i.FuelCategory != nil {
		predicates = append(predicates, fuelup.FuelCategoryEQ(*i.FuelCategory))
	}
	if i.FuelCategoryNEQ != nil {
		predicates = append(predicates, fuelup.FuelCategoryNEQ(*i.FuelCategoryNEQ))
	}
	if len(i.FuelCategoryIn) > 0 {
		predicates = append(predicates, fuelup.FuelCategoryIn(i.FuelCategoryIn...))
	}
	if len(i.FuelCategoryNotIn) > 0 {
		predicates = append(predicates, fuelup.FuelCategoryNotIn(i.FuelCategoryNotIn...))
	}
	if i.OctaneRating != nil {
		predicates = append(predicates, fuelup.OctaneRatingEQ(*i.OctaneRating))
	}
	if i.OctaneRatingNEQ != nil {
		predicates = append(predicates, fuelup.OctaneRatingNEQ(*i.OctaneRatingNEQ))
	}
	if len(i.OctaneRatingIn) > 0 {
		predicates = append(predicates, fuelup.OctaneRatingIn(i.OctaneRatingIn...))
	}
	if len(i.OctaneRatingNotIn) > 0 {
		predicates = append(predicates, fuelup.OctaneRatingNotIn(i.OctaneRatingNotIn...))
	}
	if i.OctaneRatingIsNil {
		predicates = append(predicates, fuelup.OctaneRatingIsNil())
	}
	if i.OctaneRatingNotNil {
		predicates = append(predicates, fuelup.OctaneRatingNotNil())
	}
	if i.IsFullTank != nil {
		predicates = append(predicates, fuelup.IsFullTankEQ(*i.IsFullTank))
	}
	if i.IsFullTankNEQ != nil {
		predicates = append(predicates, fuelup.IsFullTankNEQ(*i.IsFullTankNEQ))
	}
	if i.Notes != nil {
		predicates = append(predicates, fuelup.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, fuelup.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, fuelup.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, fuelup.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, fuelup.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, fuelup.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, fuelup.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, fuelup.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, fuelup.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, fuelup.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, fuelup.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesIsNil {
		predicates = append(predicates, fuelup.NotesIsNil())
	}
	if i.NotesNotNil {
		predicates = append(predicates, fuelup.NotesNotNil())
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, fuelup.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, fuelup.NotesContainsFold(*i.NotesContainsFold))
	}

	if i.HasCar != nil {
		p := fuelup.HasCar()
		if !*i.HasCar {
			p = fuelup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, fuelup.HasCarWith(with...))
	}
	if i.HasOdometerReading != nil {
		p := fuelup.HasOdometerReading()
		if !*i.HasOdometerReading {
			p = fuelup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOdometerReadingWith) > 0 {
		with := make([]predicate.OdometerReading, 0, len(i.HasOdometerReadingWith))
		for _, w := range i.HasOdometerReadingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOdometerReadingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, fuelup.HasOdometerReadingWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFuelUpWhereInput
	case 1:
		return predicates[0], nil
	default:
		return fuelup.And(predicates...), nil
	}
}

// MediaWhereInput represents a where input for filtering Media queries.
type MediaWhereInput struct {
	Predicates []predicate.Media  `json:"-"`
	Not        *MediaWhereInput   `json:"not,omitempty"`
	Or         []*MediaWhereInput `json:"or,omitempty"`
	And        []*MediaWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MediaWhereInput) AddPredicates(predicates ...predicate.Media) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MediaWhereInput filter on the MediaQuery builder.
func (i *MediaWhereInput) Filter(q *MediaQuery) (*MediaQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMediaWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMediaWhereInput is returned in case the MediaWhereInput is empty.
var ErrEmptyMediaWhereInput = errors.New("ent: empty predicate MediaWhereInput")

// P returns a predicate for filtering mediaslice.
// An error is returned if the input is empty or invalid.
func (i *MediaWhereInput) P() (predicate.Media, error) {
	var predicates []predicate.Media
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, media.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Media, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, media.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Media, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, media.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, media.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, media.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, media.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, media.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, media.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, media.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, media.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, media.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, media.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, media.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, media.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, media.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, media.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, media.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, media.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, media.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, media.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, media.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, media.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, media.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, media.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, media.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, media.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, media.UpdateTimeLTE(*i.UpdateTimeLTE))
	}

	if i.HasCar != nil {
		p := media.HasCar()
		if !*i.HasCar {
			p = media.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, media.HasCarWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMediaWhereInput
	case 1:
		return predicates[0], nil
	default:
		return media.And(predicates...), nil
	}
}

// OdometerReadingWhereInput represents a where input for filtering OdometerReading queries.
type OdometerReadingWhereInput struct {
	Predicates []predicate.OdometerReading  `json:"-"`
	Not        *OdometerReadingWhereInput   `json:"not,omitempty"`
	Or         []*OdometerReadingWhereInput `json:"or,omitempty"`
	And        []*OdometerReadingWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "reading_km" field predicates.
	ReadingKm      *float64  `json:"readingKm,omitempty"`
	ReadingKmNEQ   *float64  `json:"readingKmNEQ,omitempty"`
	ReadingKmIn    []float64 `json:"readingKmIn,omitempty"`
	ReadingKmNotIn []float64 `json:"readingKmNotIn,omitempty"`
	ReadingKmGT    *float64  `json:"readingKmGT,omitempty"`
	ReadingKmGTE   *float64  `json:"readingKmGTE,omitempty"`
	ReadingKmLT    *float64  `json:"readingKmLT,omitempty"`
	ReadingKmLTE   *float64  `json:"readingKmLTE,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesIsNil        bool     `json:"notesIsNil,omitempty"`
	NotesNotNil       bool     `json:"notesNotNil,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "fuel_up" edge predicates.
	HasFuelUp     *bool               `json:"hasFuelUp,omitempty"`
	HasFuelUpWith []*FuelUpWhereInput `json:"hasFuelUpWith,omitempty"`

	// "service_log" edge predicates.
	HasServiceLog     *bool                   `json:"hasServiceLog,omitempty"`
	HasServiceLogWith []*ServiceLogWhereInput `json:"hasServiceLogWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OdometerReadingWhereInput) AddPredicates(predicates ...predicate.OdometerReading) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OdometerReadingWhereInput filter on the OdometerReadingQuery builder.
func (i *OdometerReadingWhereInput) Filter(q *OdometerReadingQuery) (*OdometerReadingQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOdometerReadingWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOdometerReadingWhereInput is returned in case the OdometerReadingWhereInput is empty.
var ErrEmptyOdometerReadingWhereInput = errors.New("ent: empty predicate OdometerReadingWhereInput")

// P returns a predicate for filtering odometerreadings.
// An error is returned if the input is empty or invalid.
func (i *OdometerReadingWhereInput) P() (predicate.OdometerReading, error) {
	var predicates []predicate.OdometerReading
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, odometerreading.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OdometerReading, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, odometerreading.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OdometerReading, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, odometerreading.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, odometerreading.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, odometerreading.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, odometerreading.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, odometerreading.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, odometerreading.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, odometerreading.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, odometerreading.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, odometerreading.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, odometerreading.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, odometerreading.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, odometerreading.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, odometerreading.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, odometerreading.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, odometerreading.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, odometerreading.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, odometerreading.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, odometerreading.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, odometerreading.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, odometerreading.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, odometerreading.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, odometerreading.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, odometerreading.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, odometerreading.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, odometerreading.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.ReadingKm != nil {
		predicates = append(predicates, odometerreading.ReadingKmEQ(*i.ReadingKm))
	}
	if i.ReadingKmNEQ != nil {
		predicates = append(predicates, odometerreading.ReadingKmNEQ(*i.ReadingKmNEQ))
	}
	if len(i.ReadingKmIn) > 0 {
		predicates = append(predicates, odometerreading.ReadingKmIn(i.ReadingKmIn...))
	}
	if len(i.ReadingKmNotIn) > 0 {
		predicates = append(predicates, odometerreading.ReadingKmNotIn(i.ReadingKmNotIn...))
	}
	if i.ReadingKmGT != nil {
		predicates = append(predicates, odometerreading.ReadingKmGT(*i.ReadingKmGT))
	}
	if i.ReadingKmGTE != nil {
		predicates = append(predicates, odometerreading.ReadingKmGTE(*i.ReadingKmGTE))
	}
	if i.ReadingKmLT != nil {
		predicates = append(predicates, odometerreading.ReadingKmLT(*i.ReadingKmLT))
	}
	if i.ReadingKmLTE != nil {
		predicates = append(predicates, odometerreading.ReadingKmLTE(*i.ReadingKmLTE))
	}
	if i.Notes != nil {
		predicates = append(predicates, odometerreading.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, odometerreading.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, odometerreading.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, odometerreading.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, odometerreading.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, odometerreading.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, odometerreading.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, odometerreading.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, odometerreading.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, odometerreading.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, odometerreading.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesIsNil {
		predicates = append(predicates, odometerreading.NotesIsNil())
	}
	if i.NotesNotNil {
		predicates = append(predicates, odometerreading.NotesNotNil())
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, odometerreading.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, odometerreading.NotesContainsFold(*i.NotesContainsFold))
	}

	if i.HasCar != nil {
		p := odometerreading.HasCar()
		if !*i.HasCar {
			p = odometerreading.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, odometerreading.HasCarWith(with...))
	}
	if i.HasFuelUp != nil {
		p := odometerreading.HasFuelUp()
		if !*i.HasFuelUp {
			p = odometerreading.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFuelUpWith) > 0 {
		with := make([]predicate.FuelUp, 0, len(i.HasFuelUpWith))
		for _, w := range i.HasFuelUpWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFuelUpWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, odometerreading.HasFuelUpWith(with...))
	}
	if i.HasServiceLog != nil {
		p := odometerreading.HasServiceLog()
		if !*i.HasServiceLog {
			p = odometerreading.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServiceLogWith) > 0 {
		with := make([]predicate.ServiceLog, 0, len(i.HasServiceLogWith))
		for _, w := range i.HasServiceLogWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServiceLogWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, odometerreading.HasServiceLogWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOdometerReadingWhereInput
	case 1:
		return predicates[0], nil
	default:
		return odometerreading.And(predicates...), nil
	}
}

// ProfileWhereInput represents a where input for filtering Profile queries.
type ProfileWhereInput struct {
	Predicates []predicate.Profile  `json:"-"`
	Not        *ProfileWhereInput   `json:"not,omitempty"`
	Or         []*ProfileWhereInput `json:"or,omitempty"`
	And        []*ProfileWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "username" field predicates.
	Username             *string  `json:"username,omitempty"`
	UsernameNEQ          *string  `json:"usernameNEQ,omitempty"`
	UsernameIn           []string `json:"usernameIn,omitempty"`
	UsernameNotIn        []string `json:"usernameNotIn,omitempty"`
	UsernameGT           *string  `json:"usernameGT,omitempty"`
	UsernameGTE          *string  `json:"usernameGTE,omitempty"`
	UsernameLT           *string  `json:"usernameLT,omitempty"`
	UsernameLTE          *string  `json:"usernameLTE,omitempty"`
	UsernameContains     *string  `json:"usernameContains,omitempty"`
	UsernameHasPrefix    *string  `json:"usernameHasPrefix,omitempty"`
	UsernameHasSuffix    *string  `json:"usernameHasSuffix,omitempty"`
	UsernameIsNil        bool     `json:"usernameIsNil,omitempty"`
	UsernameNotNil       bool     `json:"usernameNotNil,omitempty"`
	UsernameEqualFold    *string  `json:"usernameEqualFold,omitempty"`
	UsernameContainsFold *string  `json:"usernameContainsFold,omitempty"`

	// "first_name" field predicates.
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNEQ          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGT           *string  `json:"firstNameGT,omitempty"`
	FirstNameGTE          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLT           *string  `json:"firstNameLT,omitempty"`
	FirstNameLTE          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameIsNil        bool     `json:"firstNameIsNil,omitempty"`
	FirstNameNotNil       bool     `json:"firstNameNotNil,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`

	// "last_name" field predicates.
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNEQ          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGT           *string  `json:"lastNameGT,omitempty"`
	LastNameGTE          *string  `json:"lastNameGTE,omitempty"`
	LastNameLT           *string  `json:"lastNameLT,omitempty"`
	LastNameLTE          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        bool     `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       bool     `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`

	// "currency_code" field predicates.
	CurrencyCode             *string  `json:"currencyCode,omitempty"`
	CurrencyCodeNEQ          *string  `json:"currencyCodeNEQ,omitempty"`
	CurrencyCodeIn           []string `json:"currencyCodeIn,omitempty"`
	CurrencyCodeNotIn        []string `json:"currencyCodeNotIn,omitempty"`
	CurrencyCodeGT           *string  `json:"currencyCodeGT,omitempty"`
	CurrencyCodeGTE          *string  `json:"currencyCodeGTE,omitempty"`
	CurrencyCodeLT           *string  `json:"currencyCodeLT,omitempty"`
	CurrencyCodeLTE          *string  `json:"currencyCodeLTE,omitempty"`
	CurrencyCodeContains     *string  `json:"currencyCodeContains,omitempty"`
	CurrencyCodeHasPrefix    *string  `json:"currencyCodeHasPrefix,omitempty"`
	CurrencyCodeHasSuffix    *string  `json:"currencyCodeHasSuffix,omitempty"`
	CurrencyCodeIsNil        bool     `json:"currencyCodeIsNil,omitempty"`
	CurrencyCodeNotNil       bool     `json:"currencyCodeNotNil,omitempty"`
	CurrencyCodeEqualFold    *string  `json:"currencyCodeEqualFold,omitempty"`
	CurrencyCodeContainsFold *string  `json:"currencyCodeContainsFold,omitempty"`

	// "fuel_volume_unit" field predicates.
	FuelVolumeUnit       *profile.FuelVolumeUnit  `json:"fuelVolumeUnit,omitempty"`
	FuelVolumeUnitNEQ    *profile.FuelVolumeUnit  `json:"fuelVolumeUnitNEQ,omitempty"`
	FuelVolumeUnitIn     []profile.FuelVolumeUnit `json:"fuelVolumeUnitIn,omitempty"`
	FuelVolumeUnitNotIn  []profile.FuelVolumeUnit `json:"fuelVolumeUnitNotIn,omitempty"`
	FuelVolumeUnitIsNil  bool                     `json:"fuelVolumeUnitIsNil,omitempty"`
	FuelVolumeUnitNotNil bool                     `json:"fuelVolumeUnitNotNil,omitempty"`

	// "distance_unit" field predicates.
	DistanceUnit       *profile.DistanceUnit  `json:"distanceUnit,omitempty"`
	DistanceUnitNEQ    *profile.DistanceUnit  `json:"distanceUnitNEQ,omitempty"`
	DistanceUnitIn     []profile.DistanceUnit `json:"distanceUnitIn,omitempty"`
	DistanceUnitNotIn  []profile.DistanceUnit `json:"distanceUnitNotIn,omitempty"`
	DistanceUnitIsNil  bool                   `json:"distanceUnitIsNil,omitempty"`
	DistanceUnitNotNil bool                   `json:"distanceUnitNotNil,omitempty"`

	// "fuel_consumption_unit" field predicates.
	FuelConsumptionUnit       *profile.FuelConsumptionUnit  `json:"fuelConsumptionUnit,omitempty"`
	FuelConsumptionUnitNEQ    *profile.FuelConsumptionUnit  `json:"fuelConsumptionUnitNEQ,omitempty"`
	FuelConsumptionUnitIn     []profile.FuelConsumptionUnit `json:"fuelConsumptionUnitIn,omitempty"`
	FuelConsumptionUnitNotIn  []profile.FuelConsumptionUnit `json:"fuelConsumptionUnitNotIn,omitempty"`
	FuelConsumptionUnitIsNil  bool                          `json:"fuelConsumptionUnitIsNil,omitempty"`
	FuelConsumptionUnitNotNil bool                          `json:"fuelConsumptionUnitNotNil,omitempty"`

	// "temperature_unit" field predicates.
	TemperatureUnit       *profile.TemperatureUnit  `json:"temperatureUnit,omitempty"`
	TemperatureUnitNEQ    *profile.TemperatureUnit  `json:"temperatureUnitNEQ,omitempty"`
	TemperatureUnitIn     []profile.TemperatureUnit `json:"temperatureUnitIn,omitempty"`
	TemperatureUnitNotIn  []profile.TemperatureUnit `json:"temperatureUnitNotIn,omitempty"`
	TemperatureUnitIsNil  bool                      `json:"temperatureUnitIsNil,omitempty"`
	TemperatureUnitNotNil bool                      `json:"temperatureUnitNotNil,omitempty"`

	// "visibility" field predicates.
	Visibility      *profile.Visibility  `json:"visibility,omitempty"`
	VisibilityNEQ   *profile.Visibility  `json:"visibilityNEQ,omitempty"`
	VisibilityIn    []profile.Visibility `json:"visibilityIn,omitempty"`
	VisibilityNotIn []profile.Visibility `json:"visibilityNotIn,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProfileWhereInput) AddPredicates(predicates ...predicate.Profile) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProfileWhereInput filter on the ProfileQuery builder.
func (i *ProfileWhereInput) Filter(q *ProfileQuery) (*ProfileQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProfileWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProfileWhereInput is returned in case the ProfileWhereInput is empty.
var ErrEmptyProfileWhereInput = errors.New("ent: empty predicate ProfileWhereInput")

// P returns a predicate for filtering profiles.
// An error is returned if the input is empty or invalid.
func (i *ProfileWhereInput) P() (predicate.Profile, error) {
	var predicates []predicate.Profile
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, profile.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Profile, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, profile.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Profile, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, profile.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, profile.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, profile.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, profile.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, profile.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, profile.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, profile.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, profile.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, profile.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, profile.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, profile.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, profile.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, profile.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, profile.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, profile.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, profile.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, profile.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, profile.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, profile.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, profile.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, profile.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, profile.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, profile.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, profile.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, profile.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Username != nil {
		predicates = append(predicates, profile.UsernameEQ(*i.Username))
	}
	if i.UsernameNEQ != nil {
		predicates = append(predicates, profile.UsernameNEQ(*i.UsernameNEQ))
	}
	if len(i.UsernameIn) > 0 {
		predicates = append(predicates, profile.UsernameIn(i.UsernameIn...))
	}
	if len(i.UsernameNotIn) > 0 {
		predicates = append(predicates, profile.UsernameNotIn(i.UsernameNotIn...))
	}
	if i.UsernameGT != nil {
		predicates = append(predicates, profile.UsernameGT(*i.UsernameGT))
	}
	if i.UsernameGTE != nil {
		predicates = append(predicates, profile.UsernameGTE(*i.UsernameGTE))
	}
	if i.UsernameLT != nil {
		predicates = append(predicates, profile.UsernameLT(*i.UsernameLT))
	}
	if i.UsernameLTE != nil {
		predicates = append(predicates, profile.UsernameLTE(*i.UsernameLTE))
	}
	if i.UsernameContains != nil {
		predicates = append(predicates, profile.UsernameContains(*i.UsernameContains))
	}
	if i.UsernameHasPrefix != nil {
		predicates = append(predicates, profile.UsernameHasPrefix(*i.UsernameHasPrefix))
	}
	if i.UsernameHasSuffix != nil {
		predicates = append(predicates, profile.UsernameHasSuffix(*i.UsernameHasSuffix))
	}
	if i.UsernameIsNil {
		predicates = append(predicates, profile.UsernameIsNil())
	}
	if i.UsernameNotNil {
		predicates = append(predicates, profile.UsernameNotNil())
	}
	if i.UsernameEqualFold != nil {
		predicates = append(predicates, profile.UsernameEqualFold(*i.UsernameEqualFold))
	}
	if i.UsernameContainsFold != nil {
		predicates = append(predicates, profile.UsernameContainsFold(*i.UsernameContainsFold))
	}
	if i.FirstName != nil {
		predicates = append(predicates, profile.FirstNameEQ(*i.FirstName))
	}
	if i.FirstNameNEQ != nil {
		predicates = append(predicates, profile.FirstNameNEQ(*i.FirstNameNEQ))
	}
	if len(i.FirstNameIn) > 0 {
		predicates = append(predicates, profile.FirstNameIn(i.FirstNameIn...))
	}
	if len(i.FirstNameNotIn) > 0 {
		predicates = append(predicates, profile.FirstNameNotIn(i.FirstNameNotIn...))
	}
	if i.FirstNameGT != nil {
		predicates = append(predicates, profile.FirstNameGT(*i.FirstNameGT))
	}
	if i.FirstNameGTE != nil {
		predicates = append(predicates, profile.FirstNameGTE(*i.FirstNameGTE))
	}
	if i.FirstNameLT != nil {
		predicates = append(predicates, profile.FirstNameLT(*i.FirstNameLT))
	}
	if i.FirstNameLTE != nil {
		predicates = append(predicates, profile.FirstNameLTE(*i.FirstNameLTE))
	}
	if i.FirstNameContains != nil {
		predicates = append(predicates, profile.FirstNameContains(*i.FirstNameContains))
	}
	if i.FirstNameHasPrefix != nil {
		predicates = append(predicates, profile.FirstNameHasPrefix(*i.FirstNameHasPrefix))
	}
	if i.FirstNameHasSuffix != nil {
		predicates = append(predicates, profile.FirstNameHasSuffix(*i.FirstNameHasSuffix))
	}
	if i.FirstNameIsNil {
		predicates = append(predicates, profile.FirstNameIsNil())
	}
	if i.FirstNameNotNil {
		predicates = append(predicates, profile.FirstNameNotNil())
	}
	if i.FirstNameEqualFold != nil {
		predicates = append(predicates, profile.FirstNameEqualFold(*i.FirstNameEqualFold))
	}
	if i.FirstNameContainsFold != nil {
		predicates = append(predicates, profile.FirstNameContainsFold(*i.FirstNameContainsFold))
	}
	if i.LastName != nil {
		predicates = append(predicates, profile.LastNameEQ(*i.LastName))
	}
	if i.LastNameNEQ != nil {
		predicates = append(predicates, profile.LastNameNEQ(*i.LastNameNEQ))
	}
	if len(i.LastNameIn) > 0 {
		predicates = append(predicates, profile.LastNameIn(i.LastNameIn...))
	}
	if len(i.LastNameNotIn) > 0 {
		predicates = append(predicates, profile.LastNameNotIn(i.LastNameNotIn...))
	}
	if i.LastNameGT != nil {
		predicates = append(predicates, profile.LastNameGT(*i.LastNameGT))
	}
	if i.LastNameGTE != nil {
		predicates = append(predicates, profile.LastNameGTE(*i.LastNameGTE))
	}
	if i.LastNameLT != nil {
		predicates = append(predicates, profile.LastNameLT(*i.LastNameLT))
	}
	if i.LastNameLTE != nil {
		predicates = append(predicates, profile.LastNameLTE(*i.LastNameLTE))
	}
	if i.LastNameContains != nil {
		predicates = append(predicates, profile.LastNameContains(*i.LastNameContains))
	}
	if i.LastNameHasPrefix != nil {
		predicates = append(predicates, profile.LastNameHasPrefix(*i.LastNameHasPrefix))
	}
	if i.LastNameHasSuffix != nil {
		predicates = append(predicates, profile.LastNameHasSuffix(*i.LastNameHasSuffix))
	}
	if i.LastNameIsNil {
		predicates = append(predicates, profile.LastNameIsNil())
	}
	if i.LastNameNotNil {
		predicates = append(predicates, profile.LastNameNotNil())
	}
	if i.LastNameEqualFold != nil {
		predicates = append(predicates, profile.LastNameEqualFold(*i.LastNameEqualFold))
	}
	if i.LastNameContainsFold != nil {
		predicates = append(predicates, profile.LastNameContainsFold(*i.LastNameContainsFold))
	}
	if i.CurrencyCode != nil {
		predicates = append(predicates, profile.CurrencyCodeEQ(*i.CurrencyCode))
	}
	if i.CurrencyCodeNEQ != nil {
		predicates = append(predicates, profile.CurrencyCodeNEQ(*i.CurrencyCodeNEQ))
	}
	if len(i.CurrencyCodeIn) > 0 {
		predicates = append(predicates, profile.CurrencyCodeIn(i.CurrencyCodeIn...))
	}
	if len(i.CurrencyCodeNotIn) > 0 {
		predicates = append(predicates, profile.CurrencyCodeNotIn(i.CurrencyCodeNotIn...))
	}
	if i.CurrencyCodeGT != nil {
		predicates = append(predicates, profile.CurrencyCodeGT(*i.CurrencyCodeGT))
	}
	if i.CurrencyCodeGTE != nil {
		predicates = append(predicates, profile.CurrencyCodeGTE(*i.CurrencyCodeGTE))
	}
	if i.CurrencyCodeLT != nil {
		predicates = append(predicates, profile.CurrencyCodeLT(*i.CurrencyCodeLT))
	}
	if i.CurrencyCodeLTE != nil {
		predicates = append(predicates, profile.CurrencyCodeLTE(*i.CurrencyCodeLTE))
	}
	if i.CurrencyCodeContains != nil {
		predicates = append(predicates, profile.CurrencyCodeContains(*i.CurrencyCodeContains))
	}
	if i.CurrencyCodeHasPrefix != nil {
		predicates = append(predicates, profile.CurrencyCodeHasPrefix(*i.CurrencyCodeHasPrefix))
	}
	if i.CurrencyCodeHasSuffix != nil {
		predicates = append(predicates, profile.CurrencyCodeHasSuffix(*i.CurrencyCodeHasSuffix))
	}
	if i.CurrencyCodeIsNil {
		predicates = append(predicates, profile.CurrencyCodeIsNil())
	}
	if i.CurrencyCodeNotNil {
		predicates = append(predicates, profile.CurrencyCodeNotNil())
	}
	if i.CurrencyCodeEqualFold != nil {
		predicates = append(predicates, profile.CurrencyCodeEqualFold(*i.CurrencyCodeEqualFold))
	}
	if i.CurrencyCodeContainsFold != nil {
		predicates = append(predicates, profile.CurrencyCodeContainsFold(*i.CurrencyCodeContainsFold))
	}
	if i.FuelVolumeUnit != nil {
		predicates = append(predicates, profile.FuelVolumeUnitEQ(*i.FuelVolumeUnit))
	}
	if i.FuelVolumeUnitNEQ != nil {
		predicates = append(predicates, profile.FuelVolumeUnitNEQ(*i.FuelVolumeUnitNEQ))
	}
	if len(i.FuelVolumeUnitIn) > 0 {
		predicates = append(predicates, profile.FuelVolumeUnitIn(i.FuelVolumeUnitIn...))
	}
	if len(i.FuelVolumeUnitNotIn) > 0 {
		predicates = append(predicates, profile.FuelVolumeUnitNotIn(i.FuelVolumeUnitNotIn...))
	}
	if i.FuelVolumeUnitIsNil {
		predicates = append(predicates, profile.FuelVolumeUnitIsNil())
	}
	if i.FuelVolumeUnitNotNil {
		predicates = append(predicates, profile.FuelVolumeUnitNotNil())
	}
	if i.DistanceUnit != nil {
		predicates = append(predicates, profile.DistanceUnitEQ(*i.DistanceUnit))
	}
	if i.DistanceUnitNEQ != nil {
		predicates = append(predicates, profile.DistanceUnitNEQ(*i.DistanceUnitNEQ))
	}
	if len(i.DistanceUnitIn) > 0 {
		predicates = append(predicates, profile.DistanceUnitIn(i.DistanceUnitIn...))
	}
	if len(i.DistanceUnitNotIn) > 0 {
		predicates = append(predicates, profile.DistanceUnitNotIn(i.DistanceUnitNotIn...))
	}
	if i.DistanceUnitIsNil {
		predicates = append(predicates, profile.DistanceUnitIsNil())
	}
	if i.DistanceUnitNotNil {
		predicates = append(predicates, profile.DistanceUnitNotNil())
	}
	if i.FuelConsumptionUnit != nil {
		predicates = append(predicates, profile.FuelConsumptionUnitEQ(*i.FuelConsumptionUnit))
	}
	if i.FuelConsumptionUnitNEQ != nil {
		predicates = append(predicates, profile.FuelConsumptionUnitNEQ(*i.FuelConsumptionUnitNEQ))
	}
	if len(i.FuelConsumptionUnitIn) > 0 {
		predicates = append(predicates, profile.FuelConsumptionUnitIn(i.FuelConsumptionUnitIn...))
	}
	if len(i.FuelConsumptionUnitNotIn) > 0 {
		predicates = append(predicates, profile.FuelConsumptionUnitNotIn(i.FuelConsumptionUnitNotIn...))
	}
	if i.FuelConsumptionUnitIsNil {
		predicates = append(predicates, profile.FuelConsumptionUnitIsNil())
	}
	if i.FuelConsumptionUnitNotNil {
		predicates = append(predicates, profile.FuelConsumptionUnitNotNil())
	}
	if i.TemperatureUnit != nil {
		predicates = append(predicates, profile.TemperatureUnitEQ(*i.TemperatureUnit))
	}
	if i.TemperatureUnitNEQ != nil {
		predicates = append(predicates, profile.TemperatureUnitNEQ(*i.TemperatureUnitNEQ))
	}
	if len(i.TemperatureUnitIn) > 0 {
		predicates = append(predicates, profile.TemperatureUnitIn(i.TemperatureUnitIn...))
	}
	if len(i.TemperatureUnitNotIn) > 0 {
		predicates = append(predicates, profile.TemperatureUnitNotIn(i.TemperatureUnitNotIn...))
	}
	if i.TemperatureUnitIsNil {
		predicates = append(predicates, profile.TemperatureUnitIsNil())
	}
	if i.TemperatureUnitNotNil {
		predicates = append(predicates, profile.TemperatureUnitNotNil())
	}
	if i.Visibility != nil {
		predicates = append(predicates, profile.VisibilityEQ(*i.Visibility))
	}
	if i.VisibilityNEQ != nil {
		predicates = append(predicates, profile.VisibilityNEQ(*i.VisibilityNEQ))
	}
	if len(i.VisibilityIn) > 0 {
		predicates = append(predicates, profile.VisibilityIn(i.VisibilityIn...))
	}
	if len(i.VisibilityNotIn) > 0 {
		predicates = append(predicates, profile.VisibilityNotIn(i.VisibilityNotIn...))
	}

	if i.HasUser != nil {
		p := profile.HasUser()
		if !*i.HasUser {
			p = profile.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, profile.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProfileWhereInput
	case 1:
		return predicates[0], nil
	default:
		return profile.And(predicates...), nil
	}
}

// ServiceItemWhereInput represents a where input for filtering ServiceItem queries.
type ServiceItemWhereInput struct {
	Predicates []predicate.ServiceItem  `json:"-"`
	Not        *ServiceItemWhereInput   `json:"not,omitempty"`
	Or         []*ServiceItemWhereInput `json:"or,omitempty"`
	And        []*ServiceItemWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "estimated_minutes" field predicates.
	EstimatedMinutes       *int  `json:"estimatedMinutes,omitempty"`
	EstimatedMinutesNEQ    *int  `json:"estimatedMinutesNEQ,omitempty"`
	EstimatedMinutesIn     []int `json:"estimatedMinutesIn,omitempty"`
	EstimatedMinutesNotIn  []int `json:"estimatedMinutesNotIn,omitempty"`
	EstimatedMinutesGT     *int  `json:"estimatedMinutesGT,omitempty"`
	EstimatedMinutesGTE    *int  `json:"estimatedMinutesGTE,omitempty"`
	EstimatedMinutesLT     *int  `json:"estimatedMinutesLT,omitempty"`
	EstimatedMinutesLTE    *int  `json:"estimatedMinutesLTE,omitempty"`
	EstimatedMinutesIsNil  bool  `json:"estimatedMinutesIsNil,omitempty"`
	EstimatedMinutesNotNil bool  `json:"estimatedMinutesNotNil,omitempty"`

	// "default_interval_km" field predicates.
	DefaultIntervalKm       *float64  `json:"defaultIntervalKm,omitempty"`
	DefaultIntervalKmNEQ    *float64  `json:"defaultIntervalKmNEQ,omitempty"`
	DefaultIntervalKmIn     []float64 `json:"defaultIntervalKmIn,omitempty"`
	DefaultIntervalKmNotIn  []float64 `json:"defaultIntervalKmNotIn,omitempty"`
	DefaultIntervalKmGT     *float64  `json:"defaultIntervalKmGT,omitempty"`
	DefaultIntervalKmGTE    *float64  `json:"defaultIntervalKmGTE,omitempty"`
	DefaultIntervalKmLT     *float64  `json:"defaultIntervalKmLT,omitempty"`
	DefaultIntervalKmLTE    *float64  `json:"defaultIntervalKmLTE,omitempty"`
	DefaultIntervalKmIsNil  bool      `json:"defaultIntervalKmIsNil,omitempty"`
	DefaultIntervalKmNotNil bool      `json:"defaultIntervalKmNotNil,omitempty"`

	// "default_interval_months" field predicates.
	DefaultIntervalMonths       *int  `json:"defaultIntervalMonths,omitempty"`
	DefaultIntervalMonthsNEQ    *int  `json:"defaultIntervalMonthsNEQ,omitempty"`
	DefaultIntervalMonthsIn     []int `json:"defaultIntervalMonthsIn,omitempty"`
	DefaultIntervalMonthsNotIn  []int `json:"defaultIntervalMonthsNotIn,omitempty"`
	DefaultIntervalMonthsGT     *int  `json:"defaultIntervalMonthsGT,omitempty"`
	DefaultIntervalMonthsGTE    *int  `json:"defaultIntervalMonthsGTE,omitempty"`
	DefaultIntervalMonthsLT     *int  `json:"defaultIntervalMonthsLT,omitempty"`
	DefaultIntervalMonthsLTE    *int  `json:"defaultIntervalMonthsLTE,omitempty"`
	DefaultIntervalMonthsIsNil  bool  `json:"defaultIntervalMonthsIsNil,omitempty"`
	DefaultIntervalMonthsNotNil bool  `json:"defaultIntervalMonthsNotNil,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesIsNil        bool     `json:"notesIsNil,omitempty"`
	NotesNotNil       bool     `json:"notesNotNil,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "schedules" edge predicates.
	HasSchedules     *bool                        `json:"hasSchedules,omitempty"`
	HasSchedulesWith []*ServiceScheduleWhereInput `json:"hasSchedulesWith,omitempty"`

	// "logs" edge predicates.
	HasLogs     *bool                   `json:"hasLogs,omitempty"`
	HasLogsWith []*ServiceLogWhereInput `json:"hasLogsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServiceItemWhereInput) AddPredicates(predicates ...predicate.ServiceItem) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServiceItemWhereInput filter on the ServiceItemQuery builder.
func (i *ServiceItemWhereInput) Filter(q *ServiceItemQuery) (*ServiceItemQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServiceItemWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServiceItemWhereInput is returned in case the ServiceItemWhereInput is empty.
var ErrEmptyServiceItemWhereInput = errors.New("ent: empty predicate ServiceItemWhereInput")

// P returns a predicate for filtering serviceitems.
// An error is returned if the input is empty or invalid.
func (i *ServiceItemWhereInput) P() (predicate.ServiceItem, error) {
	var predicates []predicate.ServiceItem
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, serviceitem.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServiceItem, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, serviceitem.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServiceItem, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, serviceitem.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, serviceitem.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, serviceitem.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, serviceitem.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, serviceitem.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, serviceitem.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, serviceitem.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, serviceitem.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, serviceitem.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, serviceitem.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, serviceitem.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, serviceitem.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, serviceitem.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, serviceitem.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, serviceitem.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, serviceitem.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, serviceitem.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, serviceitem.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, serviceitem.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, serviceitem.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, serviceitem.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, serviceitem.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, serviceitem.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, serviceitem.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, serviceitem.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, serviceitem.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, serviceitem.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, serviceitem.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, serviceitem.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, serviceitem.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, serviceitem.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, serviceitem.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, serviceitem.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, serviceitem.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, serviceitem.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, serviceitem.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, serviceitem.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, serviceitem.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.EstimatedMinutes != nil {
		predicates = append(predicates, serviceitem.EstimatedMinutesEQ(*i.EstimatedMinutes))
	}
	if i.EstimatedMinutesNEQ != nil {
		predicates = append(predicates, serviceitem.EstimatedMinutesNEQ(*i.EstimatedMinutesNEQ))
	}
	if len(i.EstimatedMinutesIn) > 0 {
		predicates = append(predicates, serviceitem.EstimatedMinutesIn(i.EstimatedMinutesIn...))
	}
	if len(i.EstimatedMinutesNotIn) > 0 {
		predicates = append(predicates, serviceitem.EstimatedMinutesNotIn(i.EstimatedMinutesNotIn...))
	}
	if i.EstimatedMinutesGT != nil {
		predicates = append(predicates, serviceitem.EstimatedMinutesGT(*i.EstimatedMinutesGT))
	}
	if i.EstimatedMinutesGTE != nil {
		predicates = append(predicates, serviceitem.EstimatedMinutesGTE(*i.EstimatedMinutesGTE))
	}
	if i.EstimatedMinutesLT != nil {
		predicates = append(predicates, serviceitem.EstimatedMinutesLT(*i.EstimatedMinutesLT))
	}
	if i.EstimatedMinutesLTE != nil {
		predicates = append(predicates, serviceitem.EstimatedMinutesLTE(*i.EstimatedMinutesLTE))
	}
	if i.EstimatedMinutesIsNil {
		predicates = append(predicates, serviceitem.EstimatedMinutesIsNil())
	}
	if i.EstimatedMinutesNotNil {
		predicates = append(predicates, serviceitem.EstimatedMinutesNotNil())
	}
	if i.DefaultIntervalKm != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalKmEQ(*i.DefaultIntervalKm))
	}
	if i.DefaultIntervalKmNEQ != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalKmNEQ(*i.DefaultIntervalKmNEQ))
	}
	if len(i.DefaultIntervalKmIn) > 0 {
		predicates = append(predicates, serviceitem.DefaultIntervalKmIn(i.DefaultIntervalKmIn...))
	}
	if len(i.DefaultIntervalKmNotIn) > 0 {
		predicates = append(predicates, serviceitem.DefaultIntervalKmNotIn(i.DefaultIntervalKmNotIn...))
	}
	if i.DefaultIntervalKmGT != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalKmGT(*i.DefaultIntervalKmGT))
	}
	if i.DefaultIntervalKmGTE != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalKmGTE(*i.DefaultIntervalKmGTE))
	}
	if i.DefaultIntervalKmLT != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalKmLT(*i.DefaultIntervalKmLT))
	}
	if i.DefaultIntervalKmLTE != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalKmLTE(*i.DefaultIntervalKmLTE))
	}
	if i.DefaultIntervalKmIsNil {
		predicates = append(predicates, serviceitem.DefaultIntervalKmIsNil())
	}
	if i.DefaultIntervalKmNotNil {
		predicates = append(predicates, serviceitem.DefaultIntervalKmNotNil())
	}
	if i.DefaultIntervalMonths != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsEQ(*i.DefaultIntervalMonths))
	}
	if i.DefaultIntervalMonthsNEQ != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsNEQ(*i.DefaultIntervalMonthsNEQ))
	}
	if len(i.DefaultIntervalMonthsIn) > 0 {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsIn(i.DefaultIntervalMonthsIn...))
	}
	if len(i.DefaultIntervalMonthsNotIn) > 0 {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsNotIn(i.DefaultIntervalMonthsNotIn...))
	}
	if i.DefaultIntervalMonthsGT != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsGT(*i.DefaultIntervalMonthsGT))
	}
	if i.DefaultIntervalMonthsGTE != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsGTE(*i.DefaultIntervalMonthsGTE))
	}
	if i.DefaultIntervalMonthsLT != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsLT(*i.DefaultIntervalMonthsLT))
	}
	if i.DefaultIntervalMonthsLTE != nil {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsLTE(*i.DefaultIntervalMonthsLTE))
	}
	if i.DefaultIntervalMonthsIsNil {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsIsNil())
	}
	if i.DefaultIntervalMonthsNotNil {
		predicates = append(predicates, serviceitem.DefaultIntervalMonthsNotNil())
	}
	if i.Notes != nil {
		predicates = append(predicates, serviceitem.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, serviceitem.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, serviceitem.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, serviceitem.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, serviceitem.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, serviceitem.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, serviceitem.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, serviceitem.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, serviceitem.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, serviceitem.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, serviceitem.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesIsNil {
		predicates = append(predicates, serviceitem.NotesIsNil())
	}
	if i.NotesNotNil {
		predicates = append(predicates, serviceitem.NotesNotNil())
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, serviceitem.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, serviceitem.NotesContainsFold(*i.NotesContainsFold))
	}

	if i.HasCar != nil {
		p := serviceitem.HasCar()
		if !*i.HasCar {
			p = serviceitem.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serviceitem.HasCarWith(with...))
	}
	if i.HasSchedules != nil {
		p := serviceitem.HasSchedules()
		if !*i.HasSchedules {
			p = serviceitem.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSchedulesWith) > 0 {
		with := make([]predicate.ServiceSchedule, 0, len(i.HasSchedulesWith))
		for _, w := range i.HasSchedulesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSchedulesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serviceitem.HasSchedulesWith(with...))
	}
	if i.HasLogs != nil {
		p := serviceitem.HasLogs()
		if !*i.HasLogs {
			p = serviceitem.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLogsWith) > 0 {
		with := make([]predicate.ServiceLog, 0, len(i.HasLogsWith))
		for _, w := range i.HasLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serviceitem.HasLogsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServiceItemWhereInput
	case 1:
		return predicates[0], nil
	default:
		return serviceitem.And(predicates...), nil
	}
}

// ServiceLogWhereInput represents a where input for filtering ServiceLog queries.
type ServiceLogWhereInput struct {
	Predicates []predicate.ServiceLog  `json:"-"`
	Not        *ServiceLogWhereInput   `json:"not,omitempty"`
	Or         []*ServiceLogWhereInput `json:"or,omitempty"`
	And        []*ServiceLogWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "date_performed" field predicates.
	DatePerformed      *time.Time  `json:"datePerformed,omitempty"`
	DatePerformedNEQ   *time.Time  `json:"datePerformedNEQ,omitempty"`
	DatePerformedIn    []time.Time `json:"datePerformedIn,omitempty"`
	DatePerformedNotIn []time.Time `json:"datePerformedNotIn,omitempty"`
	DatePerformedGT    *time.Time  `json:"datePerformedGT,omitempty"`
	DatePerformedGTE   *time.Time  `json:"datePerformedGTE,omitempty"`
	DatePerformedLT    *time.Time  `json:"datePerformedLT,omitempty"`
	DatePerformedLTE   *time.Time  `json:"datePerformedLTE,omitempty"`

	// "performed_by" field predicates.
	PerformedBy             *string  `json:"performedBy,omitempty"`
	PerformedByNEQ          *string  `json:"performedByNEQ,omitempty"`
	PerformedByIn           []string `json:"performedByIn,omitempty"`
	PerformedByNotIn        []string `json:"performedByNotIn,omitempty"`
	PerformedByGT           *string  `json:"performedByGT,omitempty"`
	PerformedByGTE          *string  `json:"performedByGTE,omitempty"`
	PerformedByLT           *string  `json:"performedByLT,omitempty"`
	PerformedByLTE          *string  `json:"performedByLTE,omitempty"`
	PerformedByContains     *string  `json:"performedByContains,omitempty"`
	PerformedByHasPrefix    *string  `json:"performedByHasPrefix,omitempty"`
	PerformedByHasSuffix    *string  `json:"performedByHasSuffix,omitempty"`
	PerformedByIsNil        bool     `json:"performedByIsNil,omitempty"`
	PerformedByNotNil       bool     `json:"performedByNotNil,omitempty"`
	PerformedByEqualFold    *string  `json:"performedByEqualFold,omitempty"`
	PerformedByContainsFold *string  `json:"performedByContainsFold,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesIsNil        bool     `json:"notesIsNil,omitempty"`
	NotesNotNil       bool     `json:"notesNotNil,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "items" edge predicates.
	HasItems     *bool                    `json:"hasItems,omitempty"`
	HasItemsWith []*ServiceItemWhereInput `json:"hasItemsWith,omitempty"`

	// "schedule" edge predicates.
	HasSchedule     *bool                        `json:"hasSchedule,omitempty"`
	HasScheduleWith []*ServiceScheduleWhereInput `json:"hasScheduleWith,omitempty"`

	// "odometer_reading" edge predicates.
	HasOdometerReading     *bool                        `json:"hasOdometerReading,omitempty"`
	HasOdometerReadingWith []*OdometerReadingWhereInput `json:"hasOdometerReadingWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServiceLogWhereInput) AddPredicates(predicates ...predicate.ServiceLog) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServiceLogWhereInput filter on the ServiceLogQuery builder.
func (i *ServiceLogWhereInput) Filter(q *ServiceLogQuery) (*ServiceLogQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServiceLogWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServiceLogWhereInput is returned in case the ServiceLogWhereInput is empty.
var ErrEmptyServiceLogWhereInput = errors.New("ent: empty predicate ServiceLogWhereInput")

// P returns a predicate for filtering servicelogs.
// An error is returned if the input is empty or invalid.
func (i *ServiceLogWhereInput) P() (predicate.ServiceLog, error) {
	var predicates []predicate.ServiceLog
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, servicelog.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServiceLog, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, servicelog.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServiceLog, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, servicelog.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, servicelog.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, servicelog.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, servicelog.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, servicelog.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, servicelog.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, servicelog.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, servicelog.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, servicelog.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, servicelog.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, servicelog.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, servicelog.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, servicelog.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, servicelog.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, servicelog.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, servicelog.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, servicelog.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, servicelog.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, servicelog.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, servicelog.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, servicelog.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, servicelog.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, servicelog.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, servicelog.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, servicelog.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.DatePerformed != nil {
		predicates = append(predicates, servicelog.DatePerformedEQ(*i.DatePerformed))
	}
	if i.DatePerformedNEQ != nil {
		predicates = append(predicates, servicelog.DatePerformedNEQ(*i.DatePerformedNEQ))
	}
	if len(i.DatePerformedIn) > 0 {
		predicates = append(predicates, servicelog.DatePerformedIn(i.DatePerformedIn...))
	}
	if len(i.DatePerformedNotIn) > 0 {
		predicates = append(predicates, servicelog.DatePerformedNotIn(i.DatePerformedNotIn...))
	}
	if i.DatePerformedGT != nil {
		predicates = append(predicates, servicelog.DatePerformedGT(*i.DatePerformedGT))
	}
	if i.DatePerformedGTE != nil {
		predicates = append(predicates, servicelog.DatePerformedGTE(*i.DatePerformedGTE))
	}
	if i.DatePerformedLT != nil {
		predicates = append(predicates, servicelog.DatePerformedLT(*i.DatePerformedLT))
	}
	if i.DatePerformedLTE != nil {
		predicates = append(predicates, servicelog.DatePerformedLTE(*i.DatePerformedLTE))
	}
	if i.PerformedBy != nil {
		predicates = append(predicates, servicelog.PerformedByEQ(*i.PerformedBy))
	}
	if i.PerformedByNEQ != nil {
		predicates = append(predicates, servicelog.PerformedByNEQ(*i.PerformedByNEQ))
	}
	if len(i.PerformedByIn) > 0 {
		predicates = append(predicates, servicelog.PerformedByIn(i.PerformedByIn...))
	}
	if len(i.PerformedByNotIn) > 0 {
		predicates = append(predicates, servicelog.PerformedByNotIn(i.PerformedByNotIn...))
	}
	if i.PerformedByGT != nil {
		predicates = append(predicates, servicelog.PerformedByGT(*i.PerformedByGT))
	}
	if i.PerformedByGTE != nil {
		predicates = append(predicates, servicelog.PerformedByGTE(*i.PerformedByGTE))
	}
	if i.PerformedByLT != nil {
		predicates = append(predicates, servicelog.PerformedByLT(*i.PerformedByLT))
	}
	if i.PerformedByLTE != nil {
		predicates = append(predicates, servicelog.PerformedByLTE(*i.PerformedByLTE))
	}
	if i.PerformedByContains != nil {
		predicates = append(predicates, servicelog.PerformedByContains(*i.PerformedByContains))
	}
	if i.PerformedByHasPrefix != nil {
		predicates = append(predicates, servicelog.PerformedByHasPrefix(*i.PerformedByHasPrefix))
	}
	if i.PerformedByHasSuffix != nil {
		predicates = append(predicates, servicelog.PerformedByHasSuffix(*i.PerformedByHasSuffix))
	}
	if i.PerformedByIsNil {
		predicates = append(predicates, servicelog.PerformedByIsNil())
	}
	if i.PerformedByNotNil {
		predicates = append(predicates, servicelog.PerformedByNotNil())
	}
	if i.PerformedByEqualFold != nil {
		predicates = append(predicates, servicelog.PerformedByEqualFold(*i.PerformedByEqualFold))
	}
	if i.PerformedByContainsFold != nil {
		predicates = append(predicates, servicelog.PerformedByContainsFold(*i.PerformedByContainsFold))
	}
	if i.Notes != nil {
		predicates = append(predicates, servicelog.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, servicelog.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, servicelog.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, servicelog.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, servicelog.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, servicelog.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, servicelog.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, servicelog.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, servicelog.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, servicelog.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, servicelog.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesIsNil {
		predicates = append(predicates, servicelog.NotesIsNil())
	}
	if i.NotesNotNil {
		predicates = append(predicates, servicelog.NotesNotNil())
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, servicelog.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, servicelog.NotesContainsFold(*i.NotesContainsFold))
	}

	if i.HasCar != nil {
		p := servicelog.HasCar()
		if !*i.HasCar {
			p = servicelog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servicelog.HasCarWith(with...))
	}
	if i.HasItems != nil {
		p := servicelog.HasItems()
		if !*i.HasItems {
			p = servicelog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemsWith) > 0 {
		with := make([]predicate.ServiceItem, 0, len(i.HasItemsWith))
		for _, w := range i.HasItemsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasItemsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servicelog.HasItemsWith(with...))
	}
	if i.HasSchedule != nil {
		p := servicelog.HasSchedule()
		if !*i.HasSchedule {
			p = servicelog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasScheduleWith) > 0 {
		with := make([]predicate.ServiceSchedule, 0, len(i.HasScheduleWith))
		for _, w := range i.HasScheduleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasScheduleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servicelog.HasScheduleWith(with...))
	}
	if i.HasOdometerReading != nil {
		p := servicelog.HasOdometerReading()
		if !*i.HasOdometerReading {
			p = servicelog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOdometerReadingWith) > 0 {
		with := make([]predicate.OdometerReading, 0, len(i.HasOdometerReadingWith))
		for _, w := range i.HasOdometerReadingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOdometerReadingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, servicelog.HasOdometerReadingWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServiceLogWhereInput
	case 1:
		return predicates[0], nil
	default:
		return servicelog.And(predicates...), nil
	}
}

// ServiceScheduleWhereInput represents a where input for filtering ServiceSchedule queries.
type ServiceScheduleWhereInput struct {
	Predicates []predicate.ServiceSchedule  `json:"-"`
	Not        *ServiceScheduleWhereInput   `json:"not,omitempty"`
	Or         []*ServiceScheduleWhereInput `json:"or,omitempty"`
	And        []*ServiceScheduleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "repeat_every_km" field predicates.
	RepeatEveryKm       *float64  `json:"repeatEveryKm,omitempty"`
	RepeatEveryKmNEQ    *float64  `json:"repeatEveryKmNEQ,omitempty"`
	RepeatEveryKmIn     []float64 `json:"repeatEveryKmIn,omitempty"`
	RepeatEveryKmNotIn  []float64 `json:"repeatEveryKmNotIn,omitempty"`
	RepeatEveryKmGT     *float64  `json:"repeatEveryKmGT,omitempty"`
	RepeatEveryKmGTE    *float64  `json:"repeatEveryKmGTE,omitempty"`
	RepeatEveryKmLT     *float64  `json:"repeatEveryKmLT,omitempty"`
	RepeatEveryKmLTE    *float64  `json:"repeatEveryKmLTE,omitempty"`
	RepeatEveryKmIsNil  bool      `json:"repeatEveryKmIsNil,omitempty"`
	RepeatEveryKmNotNil bool      `json:"repeatEveryKmNotNil,omitempty"`

	// "starts_at_km" field predicates.
	StartsAtKm       *float64  `json:"startsAtKm,omitempty"`
	StartsAtKmNEQ    *float64  `json:"startsAtKmNEQ,omitempty"`
	StartsAtKmIn     []float64 `json:"startsAtKmIn,omitempty"`
	StartsAtKmNotIn  []float64 `json:"startsAtKmNotIn,omitempty"`
	StartsAtKmGT     *float64  `json:"startsAtKmGT,omitempty"`
	StartsAtKmGTE    *float64  `json:"startsAtKmGTE,omitempty"`
	StartsAtKmLT     *float64  `json:"startsAtKmLT,omitempty"`
	StartsAtKmLTE    *float64  `json:"startsAtKmLTE,omitempty"`
	StartsAtKmIsNil  bool      `json:"startsAtKmIsNil,omitempty"`
	StartsAtKmNotNil bool      `json:"startsAtKmNotNil,omitempty"`

	// "repeat_every_months" field predicates.
	RepeatEveryMonths       *int  `json:"repeatEveryMonths,omitempty"`
	RepeatEveryMonthsNEQ    *int  `json:"repeatEveryMonthsNEQ,omitempty"`
	RepeatEveryMonthsIn     []int `json:"repeatEveryMonthsIn,omitempty"`
	RepeatEveryMonthsNotIn  []int `json:"repeatEveryMonthsNotIn,omitempty"`
	RepeatEveryMonthsGT     *int  `json:"repeatEveryMonthsGT,omitempty"`
	RepeatEveryMonthsGTE    *int  `json:"repeatEveryMonthsGTE,omitempty"`
	RepeatEveryMonthsLT     *int  `json:"repeatEveryMonthsLT,omitempty"`
	RepeatEveryMonthsLTE    *int  `json:"repeatEveryMonthsLTE,omitempty"`
	RepeatEveryMonthsIsNil  bool  `json:"repeatEveryMonthsIsNil,omitempty"`
	RepeatEveryMonthsNotNil bool  `json:"repeatEveryMonthsNotNil,omitempty"`

	// "starts_at_months" field predicates.
	StartsAtMonths       *int  `json:"startsAtMonths,omitempty"`
	StartsAtMonthsNEQ    *int  `json:"startsAtMonthsNEQ,omitempty"`
	StartsAtMonthsIn     []int `json:"startsAtMonthsIn,omitempty"`
	StartsAtMonthsNotIn  []int `json:"startsAtMonthsNotIn,omitempty"`
	StartsAtMonthsGT     *int  `json:"startsAtMonthsGT,omitempty"`
	StartsAtMonthsGTE    *int  `json:"startsAtMonthsGTE,omitempty"`
	StartsAtMonthsLT     *int  `json:"startsAtMonthsLT,omitempty"`
	StartsAtMonthsLTE    *int  `json:"startsAtMonthsLTE,omitempty"`
	StartsAtMonthsIsNil  bool  `json:"startsAtMonthsIsNil,omitempty"`
	StartsAtMonthsNotNil bool  `json:"startsAtMonthsNotNil,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesIsNil        bool     `json:"notesIsNil,omitempty"`
	NotesNotNil       bool     `json:"notesNotNil,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "archived" field predicates.
	Archived    *bool `json:"archived,omitempty"`
	ArchivedNEQ *bool `json:"archivedNEQ,omitempty"`

	// "car" edge predicates.
	HasCar     *bool            `json:"hasCar,omitempty"`
	HasCarWith []*CarWhereInput `json:"hasCarWith,omitempty"`

	// "items" edge predicates.
	HasItems     *bool                    `json:"hasItems,omitempty"`
	HasItemsWith []*ServiceItemWhereInput `json:"hasItemsWith,omitempty"`

	// "logs" edge predicates.
	HasLogs     *bool                   `json:"hasLogs,omitempty"`
	HasLogsWith []*ServiceLogWhereInput `json:"hasLogsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ServiceScheduleWhereInput) AddPredicates(predicates ...predicate.ServiceSchedule) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ServiceScheduleWhereInput filter on the ServiceScheduleQuery builder.
func (i *ServiceScheduleWhereInput) Filter(q *ServiceScheduleQuery) (*ServiceScheduleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyServiceScheduleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyServiceScheduleWhereInput is returned in case the ServiceScheduleWhereInput is empty.
var ErrEmptyServiceScheduleWhereInput = errors.New("ent: empty predicate ServiceScheduleWhereInput")

// P returns a predicate for filtering serviceschedules.
// An error is returned if the input is empty or invalid.
func (i *ServiceScheduleWhereInput) P() (predicate.ServiceSchedule, error) {
	var predicates []predicate.ServiceSchedule
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, serviceschedule.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ServiceSchedule, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, serviceschedule.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ServiceSchedule, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, serviceschedule.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, serviceschedule.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, serviceschedule.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, serviceschedule.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, serviceschedule.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, serviceschedule.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, serviceschedule.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, serviceschedule.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, serviceschedule.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, serviceschedule.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, serviceschedule.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, serviceschedule.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, serviceschedule.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, serviceschedule.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, serviceschedule.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, serviceschedule.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, serviceschedule.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, serviceschedule.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, serviceschedule.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, serviceschedule.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, serviceschedule.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, serviceschedule.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, serviceschedule.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, serviceschedule.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, serviceschedule.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, serviceschedule.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, serviceschedule.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, serviceschedule.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, serviceschedule.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, serviceschedule.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, serviceschedule.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, serviceschedule.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, serviceschedule.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, serviceschedule.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, serviceschedule.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, serviceschedule.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, serviceschedule.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, serviceschedule.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.RepeatEveryKm != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryKmEQ(*i.RepeatEveryKm))
	}
	if i.RepeatEveryKmNEQ != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryKmNEQ(*i.RepeatEveryKmNEQ))
	}
	if len(i.RepeatEveryKmIn) > 0 {
		predicates = append(predicates, serviceschedule.RepeatEveryKmIn(i.RepeatEveryKmIn...))
	}
	if len(i.RepeatEveryKmNotIn) > 0 {
		predicates = append(predicates, serviceschedule.RepeatEveryKmNotIn(i.RepeatEveryKmNotIn...))
	}
	if i.RepeatEveryKmGT != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryKmGT(*i.RepeatEveryKmGT))
	}
	if i.RepeatEveryKmGTE != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryKmGTE(*i.RepeatEveryKmGTE))
	}
	if i.RepeatEveryKmLT != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryKmLT(*i.RepeatEveryKmLT))
	}
	if i.RepeatEveryKmLTE != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryKmLTE(*i.RepeatEveryKmLTE))
	}
	if i.RepeatEveryKmIsNil {
		predicates = append(predicates, serviceschedule.RepeatEveryKmIsNil())
	}
	if i.RepeatEveryKmNotNil {
		predicates = append(predicates, serviceschedule.RepeatEveryKmNotNil())
	}
	if i.StartsAtKm != nil {
		predicates = append(predicates, serviceschedule.StartsAtKmEQ(*i.StartsAtKm))
	}
	if i.StartsAtKmNEQ != nil {
		predicates = append(predicates, serviceschedule.StartsAtKmNEQ(*i.StartsAtKmNEQ))
	}
	if len(i.StartsAtKmIn) > 0 {
		predicates = append(predicates, serviceschedule.StartsAtKmIn(i.StartsAtKmIn...))
	}
	if len(i.StartsAtKmNotIn) > 0 {
		predicates = append(predicates, serviceschedule.StartsAtKmNotIn(i.StartsAtKmNotIn...))
	}
	if i.StartsAtKmGT != nil {
		predicates = append(predicates, serviceschedule.StartsAtKmGT(*i.StartsAtKmGT))
	}
	if i.StartsAtKmGTE != nil {
		predicates = append(predicates, serviceschedule.StartsAtKmGTE(*i.StartsAtKmGTE))
	}
	if i.StartsAtKmLT != nil {
		predicates = append(predicates, serviceschedule.StartsAtKmLT(*i.StartsAtKmLT))
	}
	if i.StartsAtKmLTE != nil {
		predicates = append(predicates, serviceschedule.StartsAtKmLTE(*i.StartsAtKmLTE))
	}
	if i.StartsAtKmIsNil {
		predicates = append(predicates, serviceschedule.StartsAtKmIsNil())
	}
	if i.StartsAtKmNotNil {
		predicates = append(predicates, serviceschedule.StartsAtKmNotNil())
	}
	if i.RepeatEveryMonths != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsEQ(*i.RepeatEveryMonths))
	}
	if i.RepeatEveryMonthsNEQ != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsNEQ(*i.RepeatEveryMonthsNEQ))
	}
	if len(i.RepeatEveryMonthsIn) > 0 {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsIn(i.RepeatEveryMonthsIn...))
	}
	if len(i.RepeatEveryMonthsNotIn) > 0 {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsNotIn(i.RepeatEveryMonthsNotIn...))
	}
	if i.RepeatEveryMonthsGT != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsGT(*i.RepeatEveryMonthsGT))
	}
	if i.RepeatEveryMonthsGTE != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsGTE(*i.RepeatEveryMonthsGTE))
	}
	if i.RepeatEveryMonthsLT != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsLT(*i.RepeatEveryMonthsLT))
	}
	if i.RepeatEveryMonthsLTE != nil {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsLTE(*i.RepeatEveryMonthsLTE))
	}
	if i.RepeatEveryMonthsIsNil {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsIsNil())
	}
	if i.RepeatEveryMonthsNotNil {
		predicates = append(predicates, serviceschedule.RepeatEveryMonthsNotNil())
	}
	if i.StartsAtMonths != nil {
		predicates = append(predicates, serviceschedule.StartsAtMonthsEQ(*i.StartsAtMonths))
	}
	if i.StartsAtMonthsNEQ != nil {
		predicates = append(predicates, serviceschedule.StartsAtMonthsNEQ(*i.StartsAtMonthsNEQ))
	}
	if len(i.StartsAtMonthsIn) > 0 {
		predicates = append(predicates, serviceschedule.StartsAtMonthsIn(i.StartsAtMonthsIn...))
	}
	if len(i.StartsAtMonthsNotIn) > 0 {
		predicates = append(predicates, serviceschedule.StartsAtMonthsNotIn(i.StartsAtMonthsNotIn...))
	}
	if i.StartsAtMonthsGT != nil {
		predicates = append(predicates, serviceschedule.StartsAtMonthsGT(*i.StartsAtMonthsGT))
	}
	if i.StartsAtMonthsGTE != nil {
		predicates = append(predicates, serviceschedule.StartsAtMonthsGTE(*i.StartsAtMonthsGTE))
	}
	if i.StartsAtMonthsLT != nil {
		predicates = append(predicates, serviceschedule.StartsAtMonthsLT(*i.StartsAtMonthsLT))
	}
	if i.StartsAtMonthsLTE != nil {
		predicates = append(predicates, serviceschedule.StartsAtMonthsLTE(*i.StartsAtMonthsLTE))
	}
	if i.StartsAtMonthsIsNil {
		predicates = append(predicates, serviceschedule.StartsAtMonthsIsNil())
	}
	if i.StartsAtMonthsNotNil {
		predicates = append(predicates, serviceschedule.StartsAtMonthsNotNil())
	}
	if i.Notes != nil {
		predicates = append(predicates, serviceschedule.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, serviceschedule.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, serviceschedule.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, serviceschedule.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, serviceschedule.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, serviceschedule.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, serviceschedule.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, serviceschedule.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, serviceschedule.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, serviceschedule.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, serviceschedule.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesIsNil {
		predicates = append(predicates, serviceschedule.NotesIsNil())
	}
	if i.NotesNotNil {
		predicates = append(predicates, serviceschedule.NotesNotNil())
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, serviceschedule.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, serviceschedule.NotesContainsFold(*i.NotesContainsFold))
	}
	if i.Archived != nil {
		predicates = append(predicates, serviceschedule.ArchivedEQ(*i.Archived))
	}
	if i.ArchivedNEQ != nil {
		predicates = append(predicates, serviceschedule.ArchivedNEQ(*i.ArchivedNEQ))
	}

	if i.HasCar != nil {
		p := serviceschedule.HasCar()
		if !*i.HasCar {
			p = serviceschedule.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarWith))
		for _, w := range i.HasCarWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serviceschedule.HasCarWith(with...))
	}
	if i.HasItems != nil {
		p := serviceschedule.HasItems()
		if !*i.HasItems {
			p = serviceschedule.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemsWith) > 0 {
		with := make([]predicate.ServiceItem, 0, len(i.HasItemsWith))
		for _, w := range i.HasItemsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasItemsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serviceschedule.HasItemsWith(with...))
	}
	if i.HasLogs != nil {
		p := serviceschedule.HasLogs()
		if !*i.HasLogs {
			p = serviceschedule.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLogsWith) > 0 {
		with := make([]predicate.ServiceLog, 0, len(i.HasLogsWith))
		for _, w := range i.HasLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, serviceschedule.HasLogsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyServiceScheduleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return serviceschedule.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "create_time" field predicates.
	CreateTime      *time.Time  `json:"createTime,omitempty"`
	CreateTimeNEQ   *time.Time  `json:"createTimeNEQ,omitempty"`
	CreateTimeIn    []time.Time `json:"createTimeIn,omitempty"`
	CreateTimeNotIn []time.Time `json:"createTimeNotIn,omitempty"`
	CreateTimeGT    *time.Time  `json:"createTimeGT,omitempty"`
	CreateTimeGTE   *time.Time  `json:"createTimeGTE,omitempty"`
	CreateTimeLT    *time.Time  `json:"createTimeLT,omitempty"`
	CreateTimeLTE   *time.Time  `json:"createTimeLTE,omitempty"`

	// "update_time" field predicates.
	UpdateTime      *time.Time  `json:"updateTime,omitempty"`
	UpdateTimeNEQ   *time.Time  `json:"updateTimeNEQ,omitempty"`
	UpdateTimeIn    []time.Time `json:"updateTimeIn,omitempty"`
	UpdateTimeNotIn []time.Time `json:"updateTimeNotIn,omitempty"`
	UpdateTimeGT    *time.Time  `json:"updateTimeGT,omitempty"`
	UpdateTimeGTE   *time.Time  `json:"updateTimeGTE,omitempty"`
	UpdateTimeLT    *time.Time  `json:"updateTimeLT,omitempty"`
	UpdateTimeLTE   *time.Time  `json:"updateTimeLTE,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "cars" edge predicates.
	HasCars     *bool            `json:"hasCars,omitempty"`
	HasCarsWith []*CarWhereInput `json:"hasCarsWith,omitempty"`

	// "profile" edge predicates.
	HasProfile     *bool                `json:"hasProfile,omitempty"`
	HasProfileWith []*ProfileWhereInput `json:"hasProfileWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.CreateTime != nil {
		predicates = append(predicates, user.CreateTimeEQ(*i.CreateTime))
	}
	if i.CreateTimeNEQ != nil {
		predicates = append(predicates, user.CreateTimeNEQ(*i.CreateTimeNEQ))
	}
	if len(i.CreateTimeIn) > 0 {
		predicates = append(predicates, user.CreateTimeIn(i.CreateTimeIn...))
	}
	if len(i.CreateTimeNotIn) > 0 {
		predicates = append(predicates, user.CreateTimeNotIn(i.CreateTimeNotIn...))
	}
	if i.CreateTimeGT != nil {
		predicates = append(predicates, user.CreateTimeGT(*i.CreateTimeGT))
	}
	if i.CreateTimeGTE != nil {
		predicates = append(predicates, user.CreateTimeGTE(*i.CreateTimeGTE))
	}
	if i.CreateTimeLT != nil {
		predicates = append(predicates, user.CreateTimeLT(*i.CreateTimeLT))
	}
	if i.CreateTimeLTE != nil {
		predicates = append(predicates, user.CreateTimeLTE(*i.CreateTimeLTE))
	}
	if i.UpdateTime != nil {
		predicates = append(predicates, user.UpdateTimeEQ(*i.UpdateTime))
	}
	if i.UpdateTimeNEQ != nil {
		predicates = append(predicates, user.UpdateTimeNEQ(*i.UpdateTimeNEQ))
	}
	if len(i.UpdateTimeIn) > 0 {
		predicates = append(predicates, user.UpdateTimeIn(i.UpdateTimeIn...))
	}
	if len(i.UpdateTimeNotIn) > 0 {
		predicates = append(predicates, user.UpdateTimeNotIn(i.UpdateTimeNotIn...))
	}
	if i.UpdateTimeGT != nil {
		predicates = append(predicates, user.UpdateTimeGT(*i.UpdateTimeGT))
	}
	if i.UpdateTimeGTE != nil {
		predicates = append(predicates, user.UpdateTimeGTE(*i.UpdateTimeGTE))
	}
	if i.UpdateTimeLT != nil {
		predicates = append(predicates, user.UpdateTimeLT(*i.UpdateTimeLT))
	}
	if i.UpdateTimeLTE != nil {
		predicates = append(predicates, user.UpdateTimeLTE(*i.UpdateTimeLTE))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}

	if i.HasCars != nil {
		p := user.HasCars()
		if !*i.HasCars {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarsWith) > 0 {
		with := make([]predicate.Car, 0, len(i.HasCarsWith))
		for _, w := range i.HasCarsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCarsWith(with...))
	}
	if i.HasProfile != nil {
		p := user.HasProfile()
		if !*i.HasProfile {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProfileWith) > 0 {
		with := make([]predicate.Profile, 0, len(i.HasProfileWith))
		for _, w := range i.HasProfileWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProfileWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasProfileWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

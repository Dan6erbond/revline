// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/Dan6erbond/revline/ent/car"
	"github.com/Dan6erbond/revline/ent/checkoutsession"
	"github.com/Dan6erbond/revline/ent/predicate"
	"github.com/Dan6erbond/revline/ent/profile"
	"github.com/Dan6erbond/revline/ent/subscription"
	"github.com/Dan6erbond/revline/ent/user"
	"github.com/Dan6erbond/revline/ent/usersettings"
	"github.com/google/uuid"
)

// UserUpdate is the builder for updating User entities.
type UserUpdate struct {
	config
	hooks    []Hook
	mutation *UserMutation
}

// Where appends a list predicates to the UserUpdate builder.
func (uu *UserUpdate) Where(ps ...predicate.User) *UserUpdate {
	uu.mutation.Where(ps...)
	return uu
}

// SetUpdateTime sets the "update_time" field.
func (uu *UserUpdate) SetUpdateTime(t time.Time) *UserUpdate {
	uu.mutation.SetUpdateTime(t)
	return uu
}

// SetEmail sets the "email" field.
func (uu *UserUpdate) SetEmail(s string) *UserUpdate {
	uu.mutation.SetEmail(s)
	return uu
}

// SetNillableEmail sets the "email" field if the given value is not nil.
func (uu *UserUpdate) SetNillableEmail(s *string) *UserUpdate {
	if s != nil {
		uu.SetEmail(*s)
	}
	return uu
}

// SetStripeCustomerID sets the "stripe_customer_id" field.
func (uu *UserUpdate) SetStripeCustomerID(s string) *UserUpdate {
	uu.mutation.SetStripeCustomerID(s)
	return uu
}

// SetNillableStripeCustomerID sets the "stripe_customer_id" field if the given value is not nil.
func (uu *UserUpdate) SetNillableStripeCustomerID(s *string) *UserUpdate {
	if s != nil {
		uu.SetStripeCustomerID(*s)
	}
	return uu
}

// ClearStripeCustomerID clears the value of the "stripe_customer_id" field.
func (uu *UserUpdate) ClearStripeCustomerID() *UserUpdate {
	uu.mutation.ClearStripeCustomerID()
	return uu
}

// SetStripeAccountID sets the "stripe_account_id" field.
func (uu *UserUpdate) SetStripeAccountID(s string) *UserUpdate {
	uu.mutation.SetStripeAccountID(s)
	return uu
}

// SetNillableStripeAccountID sets the "stripe_account_id" field if the given value is not nil.
func (uu *UserUpdate) SetNillableStripeAccountID(s *string) *UserUpdate {
	if s != nil {
		uu.SetStripeAccountID(*s)
	}
	return uu
}

// ClearStripeAccountID clears the value of the "stripe_account_id" field.
func (uu *UserUpdate) ClearStripeAccountID() *UserUpdate {
	uu.mutation.ClearStripeAccountID()
	return uu
}

// SetStripeAccountCapabilities sets the "stripe_account_capabilities" field.
func (uu *UserUpdate) SetStripeAccountCapabilities(m map[string]string) *UserUpdate {
	uu.mutation.SetStripeAccountCapabilities(m)
	return uu
}

// ClearStripeAccountCapabilities clears the value of the "stripe_account_capabilities" field.
func (uu *UserUpdate) ClearStripeAccountCapabilities() *UserUpdate {
	uu.mutation.ClearStripeAccountCapabilities()
	return uu
}

// SetAffiliate6moCode sets the "affiliate_6mo_code" field.
func (uu *UserUpdate) SetAffiliate6moCode(s string) *UserUpdate {
	uu.mutation.SetAffiliate6moCode(s)
	return uu
}

// SetNillableAffiliate6moCode sets the "affiliate_6mo_code" field if the given value is not nil.
func (uu *UserUpdate) SetNillableAffiliate6moCode(s *string) *UserUpdate {
	if s != nil {
		uu.SetAffiliate6moCode(*s)
	}
	return uu
}

// ClearAffiliate6moCode clears the value of the "affiliate_6mo_code" field.
func (uu *UserUpdate) ClearAffiliate6moCode() *UserUpdate {
	uu.mutation.ClearAffiliate6moCode()
	return uu
}

// SetAffiliate12moCode sets the "affiliate_12mo_code" field.
func (uu *UserUpdate) SetAffiliate12moCode(s string) *UserUpdate {
	uu.mutation.SetAffiliate12moCode(s)
	return uu
}

// SetNillableAffiliate12moCode sets the "affiliate_12mo_code" field if the given value is not nil.
func (uu *UserUpdate) SetNillableAffiliate12moCode(s *string) *UserUpdate {
	if s != nil {
		uu.SetAffiliate12moCode(*s)
	}
	return uu
}

// ClearAffiliate12moCode clears the value of the "affiliate_12mo_code" field.
func (uu *UserUpdate) ClearAffiliate12moCode() *UserUpdate {
	uu.mutation.ClearAffiliate12moCode()
	return uu
}

// AddCarIDs adds the "cars" edge to the Car entity by IDs.
func (uu *UserUpdate) AddCarIDs(ids ...uuid.UUID) *UserUpdate {
	uu.mutation.AddCarIDs(ids...)
	return uu
}

// AddCars adds the "cars" edges to the Car entity.
func (uu *UserUpdate) AddCars(c ...*Car) *UserUpdate {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uu.AddCarIDs(ids...)
}

// SetProfileID sets the "profile" edge to the Profile entity by ID.
func (uu *UserUpdate) SetProfileID(id uuid.UUID) *UserUpdate {
	uu.mutation.SetProfileID(id)
	return uu
}

// SetNillableProfileID sets the "profile" edge to the Profile entity by ID if the given value is not nil.
func (uu *UserUpdate) SetNillableProfileID(id *uuid.UUID) *UserUpdate {
	if id != nil {
		uu = uu.SetProfileID(*id)
	}
	return uu
}

// SetProfile sets the "profile" edge to the Profile entity.
func (uu *UserUpdate) SetProfile(p *Profile) *UserUpdate {
	return uu.SetProfileID(p.ID)
}

// SetSettingsID sets the "settings" edge to the UserSettings entity by ID.
func (uu *UserUpdate) SetSettingsID(id uuid.UUID) *UserUpdate {
	uu.mutation.SetSettingsID(id)
	return uu
}

// SetNillableSettingsID sets the "settings" edge to the UserSettings entity by ID if the given value is not nil.
func (uu *UserUpdate) SetNillableSettingsID(id *uuid.UUID) *UserUpdate {
	if id != nil {
		uu = uu.SetSettingsID(*id)
	}
	return uu
}

// SetSettings sets the "settings" edge to the UserSettings entity.
func (uu *UserUpdate) SetSettings(u *UserSettings) *UserUpdate {
	return uu.SetSettingsID(u.ID)
}

// AddSubscriptionIDs adds the "subscriptions" edge to the Subscription entity by IDs.
func (uu *UserUpdate) AddSubscriptionIDs(ids ...uuid.UUID) *UserUpdate {
	uu.mutation.AddSubscriptionIDs(ids...)
	return uu
}

// AddSubscriptions adds the "subscriptions" edges to the Subscription entity.
func (uu *UserUpdate) AddSubscriptions(s ...*Subscription) *UserUpdate {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return uu.AddSubscriptionIDs(ids...)
}

// AddCheckoutSessionIDs adds the "checkout_sessions" edge to the CheckoutSession entity by IDs.
func (uu *UserUpdate) AddCheckoutSessionIDs(ids ...uuid.UUID) *UserUpdate {
	uu.mutation.AddCheckoutSessionIDs(ids...)
	return uu
}

// AddCheckoutSessions adds the "checkout_sessions" edges to the CheckoutSession entity.
func (uu *UserUpdate) AddCheckoutSessions(c ...*CheckoutSession) *UserUpdate {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uu.AddCheckoutSessionIDs(ids...)
}

// Mutation returns the UserMutation object of the builder.
func (uu *UserUpdate) Mutation() *UserMutation {
	return uu.mutation
}

// ClearCars clears all "cars" edges to the Car entity.
func (uu *UserUpdate) ClearCars() *UserUpdate {
	uu.mutation.ClearCars()
	return uu
}

// RemoveCarIDs removes the "cars" edge to Car entities by IDs.
func (uu *UserUpdate) RemoveCarIDs(ids ...uuid.UUID) *UserUpdate {
	uu.mutation.RemoveCarIDs(ids...)
	return uu
}

// RemoveCars removes "cars" edges to Car entities.
func (uu *UserUpdate) RemoveCars(c ...*Car) *UserUpdate {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uu.RemoveCarIDs(ids...)
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (uu *UserUpdate) ClearProfile() *UserUpdate {
	uu.mutation.ClearProfile()
	return uu
}

// ClearSettings clears the "settings" edge to the UserSettings entity.
func (uu *UserUpdate) ClearSettings() *UserUpdate {
	uu.mutation.ClearSettings()
	return uu
}

// ClearSubscriptions clears all "subscriptions" edges to the Subscription entity.
func (uu *UserUpdate) ClearSubscriptions() *UserUpdate {
	uu.mutation.ClearSubscriptions()
	return uu
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to Subscription entities by IDs.
func (uu *UserUpdate) RemoveSubscriptionIDs(ids ...uuid.UUID) *UserUpdate {
	uu.mutation.RemoveSubscriptionIDs(ids...)
	return uu
}

// RemoveSubscriptions removes "subscriptions" edges to Subscription entities.
func (uu *UserUpdate) RemoveSubscriptions(s ...*Subscription) *UserUpdate {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return uu.RemoveSubscriptionIDs(ids...)
}

// ClearCheckoutSessions clears all "checkout_sessions" edges to the CheckoutSession entity.
func (uu *UserUpdate) ClearCheckoutSessions() *UserUpdate {
	uu.mutation.ClearCheckoutSessions()
	return uu
}

// RemoveCheckoutSessionIDs removes the "checkout_sessions" edge to CheckoutSession entities by IDs.
func (uu *UserUpdate) RemoveCheckoutSessionIDs(ids ...uuid.UUID) *UserUpdate {
	uu.mutation.RemoveCheckoutSessionIDs(ids...)
	return uu
}

// RemoveCheckoutSessions removes "checkout_sessions" edges to CheckoutSession entities.
func (uu *UserUpdate) RemoveCheckoutSessions(c ...*CheckoutSession) *UserUpdate {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uu.RemoveCheckoutSessionIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (uu *UserUpdate) Save(ctx context.Context) (int, error) {
	uu.defaults()
	return withHooks(ctx, uu.sqlSave, uu.mutation, uu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (uu *UserUpdate) SaveX(ctx context.Context) int {
	affected, err := uu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (uu *UserUpdate) Exec(ctx context.Context) error {
	_, err := uu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (uu *UserUpdate) ExecX(ctx context.Context) {
	if err := uu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (uu *UserUpdate) defaults() {
	if _, ok := uu.mutation.UpdateTime(); !ok {
		v := user.UpdateDefaultUpdateTime()
		uu.mutation.SetUpdateTime(v)
	}
}

func (uu *UserUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := sqlgraph.NewUpdateSpec(user.Table, user.Columns, sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID))
	if ps := uu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := uu.mutation.UpdateTime(); ok {
		_spec.SetField(user.FieldUpdateTime, field.TypeTime, value)
	}
	if value, ok := uu.mutation.Email(); ok {
		_spec.SetField(user.FieldEmail, field.TypeString, value)
	}
	if value, ok := uu.mutation.StripeCustomerID(); ok {
		_spec.SetField(user.FieldStripeCustomerID, field.TypeString, value)
	}
	if uu.mutation.StripeCustomerIDCleared() {
		_spec.ClearField(user.FieldStripeCustomerID, field.TypeString)
	}
	if value, ok := uu.mutation.StripeAccountID(); ok {
		_spec.SetField(user.FieldStripeAccountID, field.TypeString, value)
	}
	if uu.mutation.StripeAccountIDCleared() {
		_spec.ClearField(user.FieldStripeAccountID, field.TypeString)
	}
	if value, ok := uu.mutation.StripeAccountCapabilities(); ok {
		_spec.SetField(user.FieldStripeAccountCapabilities, field.TypeJSON, value)
	}
	if uu.mutation.StripeAccountCapabilitiesCleared() {
		_spec.ClearField(user.FieldStripeAccountCapabilities, field.TypeJSON)
	}
	if value, ok := uu.mutation.Affiliate6moCode(); ok {
		_spec.SetField(user.FieldAffiliate6moCode, field.TypeString, value)
	}
	if uu.mutation.Affiliate6moCodeCleared() {
		_spec.ClearField(user.FieldAffiliate6moCode, field.TypeString)
	}
	if value, ok := uu.mutation.Affiliate12moCode(); ok {
		_spec.SetField(user.FieldAffiliate12moCode, field.TypeString, value)
	}
	if uu.mutation.Affiliate12moCodeCleared() {
		_spec.ClearField(user.FieldAffiliate12moCode, field.TypeString)
	}
	if uu.mutation.CarsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CarsTable,
			Columns: []string{user.CarsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(car.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedCarsIDs(); len(nodes) > 0 && !uu.mutation.CarsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CarsTable,
			Columns: []string{user.CarsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(car.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.CarsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CarsTable,
			Columns: []string{user.CarsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(car.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.ProfileCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   user.ProfileTable,
			Columns: []string{user.ProfileColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(profile.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.ProfileIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   user.ProfileTable,
			Columns: []string{user.ProfileColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(profile.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.SettingsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   user.SettingsTable,
			Columns: []string{user.SettingsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(usersettings.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.SettingsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   user.SettingsTable,
			Columns: []string{user.SettingsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(usersettings.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.SubscriptionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SubscriptionsTable,
			Columns: []string{user.SubscriptionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(subscription.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedSubscriptionsIDs(); len(nodes) > 0 && !uu.mutation.SubscriptionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SubscriptionsTable,
			Columns: []string{user.SubscriptionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(subscription.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.SubscriptionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SubscriptionsTable,
			Columns: []string{user.SubscriptionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(subscription.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.CheckoutSessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CheckoutSessionsTable,
			Columns: []string{user.CheckoutSessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(checkoutsession.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedCheckoutSessionsIDs(); len(nodes) > 0 && !uu.mutation.CheckoutSessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CheckoutSessionsTable,
			Columns: []string{user.CheckoutSessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(checkoutsession.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.CheckoutSessionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CheckoutSessionsTable,
			Columns: []string{user.CheckoutSessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(checkoutsession.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, uu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{user.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	uu.mutation.done = true
	return n, nil
}

// UserUpdateOne is the builder for updating a single User entity.
type UserUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *UserMutation
}

// SetUpdateTime sets the "update_time" field.
func (uuo *UserUpdateOne) SetUpdateTime(t time.Time) *UserUpdateOne {
	uuo.mutation.SetUpdateTime(t)
	return uuo
}

// SetEmail sets the "email" field.
func (uuo *UserUpdateOne) SetEmail(s string) *UserUpdateOne {
	uuo.mutation.SetEmail(s)
	return uuo
}

// SetNillableEmail sets the "email" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableEmail(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetEmail(*s)
	}
	return uuo
}

// SetStripeCustomerID sets the "stripe_customer_id" field.
func (uuo *UserUpdateOne) SetStripeCustomerID(s string) *UserUpdateOne {
	uuo.mutation.SetStripeCustomerID(s)
	return uuo
}

// SetNillableStripeCustomerID sets the "stripe_customer_id" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableStripeCustomerID(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetStripeCustomerID(*s)
	}
	return uuo
}

// ClearStripeCustomerID clears the value of the "stripe_customer_id" field.
func (uuo *UserUpdateOne) ClearStripeCustomerID() *UserUpdateOne {
	uuo.mutation.ClearStripeCustomerID()
	return uuo
}

// SetStripeAccountID sets the "stripe_account_id" field.
func (uuo *UserUpdateOne) SetStripeAccountID(s string) *UserUpdateOne {
	uuo.mutation.SetStripeAccountID(s)
	return uuo
}

// SetNillableStripeAccountID sets the "stripe_account_id" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableStripeAccountID(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetStripeAccountID(*s)
	}
	return uuo
}

// ClearStripeAccountID clears the value of the "stripe_account_id" field.
func (uuo *UserUpdateOne) ClearStripeAccountID() *UserUpdateOne {
	uuo.mutation.ClearStripeAccountID()
	return uuo
}

// SetStripeAccountCapabilities sets the "stripe_account_capabilities" field.
func (uuo *UserUpdateOne) SetStripeAccountCapabilities(m map[string]string) *UserUpdateOne {
	uuo.mutation.SetStripeAccountCapabilities(m)
	return uuo
}

// ClearStripeAccountCapabilities clears the value of the "stripe_account_capabilities" field.
func (uuo *UserUpdateOne) ClearStripeAccountCapabilities() *UserUpdateOne {
	uuo.mutation.ClearStripeAccountCapabilities()
	return uuo
}

// SetAffiliate6moCode sets the "affiliate_6mo_code" field.
func (uuo *UserUpdateOne) SetAffiliate6moCode(s string) *UserUpdateOne {
	uuo.mutation.SetAffiliate6moCode(s)
	return uuo
}

// SetNillableAffiliate6moCode sets the "affiliate_6mo_code" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableAffiliate6moCode(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetAffiliate6moCode(*s)
	}
	return uuo
}

// ClearAffiliate6moCode clears the value of the "affiliate_6mo_code" field.
func (uuo *UserUpdateOne) ClearAffiliate6moCode() *UserUpdateOne {
	uuo.mutation.ClearAffiliate6moCode()
	return uuo
}

// SetAffiliate12moCode sets the "affiliate_12mo_code" field.
func (uuo *UserUpdateOne) SetAffiliate12moCode(s string) *UserUpdateOne {
	uuo.mutation.SetAffiliate12moCode(s)
	return uuo
}

// SetNillableAffiliate12moCode sets the "affiliate_12mo_code" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableAffiliate12moCode(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetAffiliate12moCode(*s)
	}
	return uuo
}

// ClearAffiliate12moCode clears the value of the "affiliate_12mo_code" field.
func (uuo *UserUpdateOne) ClearAffiliate12moCode() *UserUpdateOne {
	uuo.mutation.ClearAffiliate12moCode()
	return uuo
}

// AddCarIDs adds the "cars" edge to the Car entity by IDs.
func (uuo *UserUpdateOne) AddCarIDs(ids ...uuid.UUID) *UserUpdateOne {
	uuo.mutation.AddCarIDs(ids...)
	return uuo
}

// AddCars adds the "cars" edges to the Car entity.
func (uuo *UserUpdateOne) AddCars(c ...*Car) *UserUpdateOne {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uuo.AddCarIDs(ids...)
}

// SetProfileID sets the "profile" edge to the Profile entity by ID.
func (uuo *UserUpdateOne) SetProfileID(id uuid.UUID) *UserUpdateOne {
	uuo.mutation.SetProfileID(id)
	return uuo
}

// SetNillableProfileID sets the "profile" edge to the Profile entity by ID if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableProfileID(id *uuid.UUID) *UserUpdateOne {
	if id != nil {
		uuo = uuo.SetProfileID(*id)
	}
	return uuo
}

// SetProfile sets the "profile" edge to the Profile entity.
func (uuo *UserUpdateOne) SetProfile(p *Profile) *UserUpdateOne {
	return uuo.SetProfileID(p.ID)
}

// SetSettingsID sets the "settings" edge to the UserSettings entity by ID.
func (uuo *UserUpdateOne) SetSettingsID(id uuid.UUID) *UserUpdateOne {
	uuo.mutation.SetSettingsID(id)
	return uuo
}

// SetNillableSettingsID sets the "settings" edge to the UserSettings entity by ID if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableSettingsID(id *uuid.UUID) *UserUpdateOne {
	if id != nil {
		uuo = uuo.SetSettingsID(*id)
	}
	return uuo
}

// SetSettings sets the "settings" edge to the UserSettings entity.
func (uuo *UserUpdateOne) SetSettings(u *UserSettings) *UserUpdateOne {
	return uuo.SetSettingsID(u.ID)
}

// AddSubscriptionIDs adds the "subscriptions" edge to the Subscription entity by IDs.
func (uuo *UserUpdateOne) AddSubscriptionIDs(ids ...uuid.UUID) *UserUpdateOne {
	uuo.mutation.AddSubscriptionIDs(ids...)
	return uuo
}

// AddSubscriptions adds the "subscriptions" edges to the Subscription entity.
func (uuo *UserUpdateOne) AddSubscriptions(s ...*Subscription) *UserUpdateOne {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return uuo.AddSubscriptionIDs(ids...)
}

// AddCheckoutSessionIDs adds the "checkout_sessions" edge to the CheckoutSession entity by IDs.
func (uuo *UserUpdateOne) AddCheckoutSessionIDs(ids ...uuid.UUID) *UserUpdateOne {
	uuo.mutation.AddCheckoutSessionIDs(ids...)
	return uuo
}

// AddCheckoutSessions adds the "checkout_sessions" edges to the CheckoutSession entity.
func (uuo *UserUpdateOne) AddCheckoutSessions(c ...*CheckoutSession) *UserUpdateOne {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uuo.AddCheckoutSessionIDs(ids...)
}

// Mutation returns the UserMutation object of the builder.
func (uuo *UserUpdateOne) Mutation() *UserMutation {
	return uuo.mutation
}

// ClearCars clears all "cars" edges to the Car entity.
func (uuo *UserUpdateOne) ClearCars() *UserUpdateOne {
	uuo.mutation.ClearCars()
	return uuo
}

// RemoveCarIDs removes the "cars" edge to Car entities by IDs.
func (uuo *UserUpdateOne) RemoveCarIDs(ids ...uuid.UUID) *UserUpdateOne {
	uuo.mutation.RemoveCarIDs(ids...)
	return uuo
}

// RemoveCars removes "cars" edges to Car entities.
func (uuo *UserUpdateOne) RemoveCars(c ...*Car) *UserUpdateOne {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uuo.RemoveCarIDs(ids...)
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (uuo *UserUpdateOne) ClearProfile() *UserUpdateOne {
	uuo.mutation.ClearProfile()
	return uuo
}

// ClearSettings clears the "settings" edge to the UserSettings entity.
func (uuo *UserUpdateOne) ClearSettings() *UserUpdateOne {
	uuo.mutation.ClearSettings()
	return uuo
}

// ClearSubscriptions clears all "subscriptions" edges to the Subscription entity.
func (uuo *UserUpdateOne) ClearSubscriptions() *UserUpdateOne {
	uuo.mutation.ClearSubscriptions()
	return uuo
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to Subscription entities by IDs.
func (uuo *UserUpdateOne) RemoveSubscriptionIDs(ids ...uuid.UUID) *UserUpdateOne {
	uuo.mutation.RemoveSubscriptionIDs(ids...)
	return uuo
}

// RemoveSubscriptions removes "subscriptions" edges to Subscription entities.
func (uuo *UserUpdateOne) RemoveSubscriptions(s ...*Subscription) *UserUpdateOne {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return uuo.RemoveSubscriptionIDs(ids...)
}

// ClearCheckoutSessions clears all "checkout_sessions" edges to the CheckoutSession entity.
func (uuo *UserUpdateOne) ClearCheckoutSessions() *UserUpdateOne {
	uuo.mutation.ClearCheckoutSessions()
	return uuo
}

// RemoveCheckoutSessionIDs removes the "checkout_sessions" edge to CheckoutSession entities by IDs.
func (uuo *UserUpdateOne) RemoveCheckoutSessionIDs(ids ...uuid.UUID) *UserUpdateOne {
	uuo.mutation.RemoveCheckoutSessionIDs(ids...)
	return uuo
}

// RemoveCheckoutSessions removes "checkout_sessions" edges to CheckoutSession entities.
func (uuo *UserUpdateOne) RemoveCheckoutSessions(c ...*CheckoutSession) *UserUpdateOne {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uuo.RemoveCheckoutSessionIDs(ids...)
}

// Where appends a list predicates to the UserUpdate builder.
func (uuo *UserUpdateOne) Where(ps ...predicate.User) *UserUpdateOne {
	uuo.mutation.Where(ps...)
	return uuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (uuo *UserUpdateOne) Select(field string, fields ...string) *UserUpdateOne {
	uuo.fields = append([]string{field}, fields...)
	return uuo
}

// Save executes the query and returns the updated User entity.
func (uuo *UserUpdateOne) Save(ctx context.Context) (*User, error) {
	uuo.defaults()
	return withHooks(ctx, uuo.sqlSave, uuo.mutation, uuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (uuo *UserUpdateOne) SaveX(ctx context.Context) *User {
	node, err := uuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (uuo *UserUpdateOne) Exec(ctx context.Context) error {
	_, err := uuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (uuo *UserUpdateOne) ExecX(ctx context.Context) {
	if err := uuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (uuo *UserUpdateOne) defaults() {
	if _, ok := uuo.mutation.UpdateTime(); !ok {
		v := user.UpdateDefaultUpdateTime()
		uuo.mutation.SetUpdateTime(v)
	}
}

func (uuo *UserUpdateOne) sqlSave(ctx context.Context) (_node *User, err error) {
	_spec := sqlgraph.NewUpdateSpec(user.Table, user.Columns, sqlgraph.NewFieldSpec(user.FieldID, field.TypeUUID))
	id, ok := uuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "User.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := uuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, user.FieldID)
		for _, f := range fields {
			if !user.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != user.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := uuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := uuo.mutation.UpdateTime(); ok {
		_spec.SetField(user.FieldUpdateTime, field.TypeTime, value)
	}
	if value, ok := uuo.mutation.Email(); ok {
		_spec.SetField(user.FieldEmail, field.TypeString, value)
	}
	if value, ok := uuo.mutation.StripeCustomerID(); ok {
		_spec.SetField(user.FieldStripeCustomerID, field.TypeString, value)
	}
	if uuo.mutation.StripeCustomerIDCleared() {
		_spec.ClearField(user.FieldStripeCustomerID, field.TypeString)
	}
	if value, ok := uuo.mutation.StripeAccountID(); ok {
		_spec.SetField(user.FieldStripeAccountID, field.TypeString, value)
	}
	if uuo.mutation.StripeAccountIDCleared() {
		_spec.ClearField(user.FieldStripeAccountID, field.TypeString)
	}
	if value, ok := uuo.mutation.StripeAccountCapabilities(); ok {
		_spec.SetField(user.FieldStripeAccountCapabilities, field.TypeJSON, value)
	}
	if uuo.mutation.StripeAccountCapabilitiesCleared() {
		_spec.ClearField(user.FieldStripeAccountCapabilities, field.TypeJSON)
	}
	if value, ok := uuo.mutation.Affiliate6moCode(); ok {
		_spec.SetField(user.FieldAffiliate6moCode, field.TypeString, value)
	}
	if uuo.mutation.Affiliate6moCodeCleared() {
		_spec.ClearField(user.FieldAffiliate6moCode, field.TypeString)
	}
	if value, ok := uuo.mutation.Affiliate12moCode(); ok {
		_spec.SetField(user.FieldAffiliate12moCode, field.TypeString, value)
	}
	if uuo.mutation.Affiliate12moCodeCleared() {
		_spec.ClearField(user.FieldAffiliate12moCode, field.TypeString)
	}
	if uuo.mutation.CarsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CarsTable,
			Columns: []string{user.CarsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(car.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedCarsIDs(); len(nodes) > 0 && !uuo.mutation.CarsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CarsTable,
			Columns: []string{user.CarsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(car.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.CarsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CarsTable,
			Columns: []string{user.CarsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(car.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.ProfileCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   user.ProfileTable,
			Columns: []string{user.ProfileColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(profile.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.ProfileIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   user.ProfileTable,
			Columns: []string{user.ProfileColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(profile.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.SettingsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   user.SettingsTable,
			Columns: []string{user.SettingsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(usersettings.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.SettingsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: false,
			Table:   user.SettingsTable,
			Columns: []string{user.SettingsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(usersettings.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.SubscriptionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SubscriptionsTable,
			Columns: []string{user.SubscriptionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(subscription.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedSubscriptionsIDs(); len(nodes) > 0 && !uuo.mutation.SubscriptionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SubscriptionsTable,
			Columns: []string{user.SubscriptionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(subscription.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.SubscriptionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SubscriptionsTable,
			Columns: []string{user.SubscriptionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(subscription.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.CheckoutSessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CheckoutSessionsTable,
			Columns: []string{user.CheckoutSessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(checkoutsession.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedCheckoutSessionsIDs(); len(nodes) > 0 && !uuo.mutation.CheckoutSessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CheckoutSessionsTable,
			Columns: []string{user.CheckoutSessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(checkoutsession.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.CheckoutSessionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CheckoutSessionsTable,
			Columns: []string{user.CheckoutSessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(checkoutsession.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &User{config: uuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, uuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{user.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	uuo.mutation.done = true
	return _node, nil
}

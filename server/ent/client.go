// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/Dan6erbond/revline/ent/migrate"
	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/Dan6erbond/revline/ent/album"
	"github.com/Dan6erbond/revline/ent/car"
	"github.com/Dan6erbond/revline/ent/checkoutsession"
	"github.com/Dan6erbond/revline/ent/document"
	"github.com/Dan6erbond/revline/ent/dragresult"
	"github.com/Dan6erbond/revline/ent/dragsession"
	"github.com/Dan6erbond/revline/ent/dynoresult"
	"github.com/Dan6erbond/revline/ent/dynosession"
	"github.com/Dan6erbond/revline/ent/expense"
	"github.com/Dan6erbond/revline/ent/fuelup"
	"github.com/Dan6erbond/revline/ent/media"
	"github.com/Dan6erbond/revline/ent/odometerreading"
	"github.com/Dan6erbond/revline/ent/profile"
	"github.com/Dan6erbond/revline/ent/serviceitem"
	"github.com/Dan6erbond/revline/ent/servicelog"
	"github.com/Dan6erbond/revline/ent/serviceschedule"
	"github.com/Dan6erbond/revline/ent/subscription"
	"github.com/Dan6erbond/revline/ent/task"
	"github.com/Dan6erbond/revline/ent/user"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Album is the client for interacting with the Album builders.
	Album *AlbumClient
	// Car is the client for interacting with the Car builders.
	Car *CarClient
	// CheckoutSession is the client for interacting with the CheckoutSession builders.
	CheckoutSession *CheckoutSessionClient
	// Document is the client for interacting with the Document builders.
	Document *DocumentClient
	// DragResult is the client for interacting with the DragResult builders.
	DragResult *DragResultClient
	// DragSession is the client for interacting with the DragSession builders.
	DragSession *DragSessionClient
	// DynoResult is the client for interacting with the DynoResult builders.
	DynoResult *DynoResultClient
	// DynoSession is the client for interacting with the DynoSession builders.
	DynoSession *DynoSessionClient
	// Expense is the client for interacting with the Expense builders.
	Expense *ExpenseClient
	// FuelUp is the client for interacting with the FuelUp builders.
	FuelUp *FuelUpClient
	// Media is the client for interacting with the Media builders.
	Media *MediaClient
	// OdometerReading is the client for interacting with the OdometerReading builders.
	OdometerReading *OdometerReadingClient
	// Profile is the client for interacting with the Profile builders.
	Profile *ProfileClient
	// ServiceItem is the client for interacting with the ServiceItem builders.
	ServiceItem *ServiceItemClient
	// ServiceLog is the client for interacting with the ServiceLog builders.
	ServiceLog *ServiceLogClient
	// ServiceSchedule is the client for interacting with the ServiceSchedule builders.
	ServiceSchedule *ServiceScheduleClient
	// Subscription is the client for interacting with the Subscription builders.
	Subscription *SubscriptionClient
	// Task is the client for interacting with the Task builders.
	Task *TaskClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Album = NewAlbumClient(c.config)
	c.Car = NewCarClient(c.config)
	c.CheckoutSession = NewCheckoutSessionClient(c.config)
	c.Document = NewDocumentClient(c.config)
	c.DragResult = NewDragResultClient(c.config)
	c.DragSession = NewDragSessionClient(c.config)
	c.DynoResult = NewDynoResultClient(c.config)
	c.DynoSession = NewDynoSessionClient(c.config)
	c.Expense = NewExpenseClient(c.config)
	c.FuelUp = NewFuelUpClient(c.config)
	c.Media = NewMediaClient(c.config)
	c.OdometerReading = NewOdometerReadingClient(c.config)
	c.Profile = NewProfileClient(c.config)
	c.ServiceItem = NewServiceItemClient(c.config)
	c.ServiceLog = NewServiceLogClient(c.config)
	c.ServiceSchedule = NewServiceScheduleClient(c.config)
	c.Subscription = NewSubscriptionClient(c.config)
	c.Task = NewTaskClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		Album:           NewAlbumClient(cfg),
		Car:             NewCarClient(cfg),
		CheckoutSession: NewCheckoutSessionClient(cfg),
		Document:        NewDocumentClient(cfg),
		DragResult:      NewDragResultClient(cfg),
		DragSession:     NewDragSessionClient(cfg),
		DynoResult:      NewDynoResultClient(cfg),
		DynoSession:     NewDynoSessionClient(cfg),
		Expense:         NewExpenseClient(cfg),
		FuelUp:          NewFuelUpClient(cfg),
		Media:           NewMediaClient(cfg),
		OdometerReading: NewOdometerReadingClient(cfg),
		Profile:         NewProfileClient(cfg),
		ServiceItem:     NewServiceItemClient(cfg),
		ServiceLog:      NewServiceLogClient(cfg),
		ServiceSchedule: NewServiceScheduleClient(cfg),
		Subscription:    NewSubscriptionClient(cfg),
		Task:            NewTaskClient(cfg),
		User:            NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		Album:           NewAlbumClient(cfg),
		Car:             NewCarClient(cfg),
		CheckoutSession: NewCheckoutSessionClient(cfg),
		Document:        NewDocumentClient(cfg),
		DragResult:      NewDragResultClient(cfg),
		DragSession:     NewDragSessionClient(cfg),
		DynoResult:      NewDynoResultClient(cfg),
		DynoSession:     NewDynoSessionClient(cfg),
		Expense:         NewExpenseClient(cfg),
		FuelUp:          NewFuelUpClient(cfg),
		Media:           NewMediaClient(cfg),
		OdometerReading: NewOdometerReadingClient(cfg),
		Profile:         NewProfileClient(cfg),
		ServiceItem:     NewServiceItemClient(cfg),
		ServiceLog:      NewServiceLogClient(cfg),
		ServiceSchedule: NewServiceScheduleClient(cfg),
		Subscription:    NewSubscriptionClient(cfg),
		Task:            NewTaskClient(cfg),
		User:            NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Album.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Album, c.Car, c.CheckoutSession, c.Document, c.DragResult, c.DragSession,
		c.DynoResult, c.DynoSession, c.Expense, c.FuelUp, c.Media, c.OdometerReading,
		c.Profile, c.ServiceItem, c.ServiceLog, c.ServiceSchedule, c.Subscription,
		c.Task, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Album, c.Car, c.CheckoutSession, c.Document, c.DragResult, c.DragSession,
		c.DynoResult, c.DynoSession, c.Expense, c.FuelUp, c.Media, c.OdometerReading,
		c.Profile, c.ServiceItem, c.ServiceLog, c.ServiceSchedule, c.Subscription,
		c.Task, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AlbumMutation:
		return c.Album.mutate(ctx, m)
	case *CarMutation:
		return c.Car.mutate(ctx, m)
	case *CheckoutSessionMutation:
		return c.CheckoutSession.mutate(ctx, m)
	case *DocumentMutation:
		return c.Document.mutate(ctx, m)
	case *DragResultMutation:
		return c.DragResult.mutate(ctx, m)
	case *DragSessionMutation:
		return c.DragSession.mutate(ctx, m)
	case *DynoResultMutation:
		return c.DynoResult.mutate(ctx, m)
	case *DynoSessionMutation:
		return c.DynoSession.mutate(ctx, m)
	case *ExpenseMutation:
		return c.Expense.mutate(ctx, m)
	case *FuelUpMutation:
		return c.FuelUp.mutate(ctx, m)
	case *MediaMutation:
		return c.Media.mutate(ctx, m)
	case *OdometerReadingMutation:
		return c.OdometerReading.mutate(ctx, m)
	case *ProfileMutation:
		return c.Profile.mutate(ctx, m)
	case *ServiceItemMutation:
		return c.ServiceItem.mutate(ctx, m)
	case *ServiceLogMutation:
		return c.ServiceLog.mutate(ctx, m)
	case *ServiceScheduleMutation:
		return c.ServiceSchedule.mutate(ctx, m)
	case *SubscriptionMutation:
		return c.Subscription.mutate(ctx, m)
	case *TaskMutation:
		return c.Task.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AlbumClient is a client for the Album schema.
type AlbumClient struct {
	config
}

// NewAlbumClient returns a client for the Album from the given config.
func NewAlbumClient(c config) *AlbumClient {
	return &AlbumClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `album.Hooks(f(g(h())))`.
func (c *AlbumClient) Use(hooks ...Hook) {
	c.hooks.Album = append(c.hooks.Album, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `album.Intercept(f(g(h())))`.
func (c *AlbumClient) Intercept(interceptors ...Interceptor) {
	c.inters.Album = append(c.inters.Album, interceptors...)
}

// Create returns a builder for creating a Album entity.
func (c *AlbumClient) Create() *AlbumCreate {
	mutation := newAlbumMutation(c.config, OpCreate)
	return &AlbumCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Album entities.
func (c *AlbumClient) CreateBulk(builders ...*AlbumCreate) *AlbumCreateBulk {
	return &AlbumCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AlbumClient) MapCreateBulk(slice any, setFunc func(*AlbumCreate, int)) *AlbumCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AlbumCreateBulk{err: fmt.Errorf("calling to AlbumClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AlbumCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AlbumCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Album.
func (c *AlbumClient) Update() *AlbumUpdate {
	mutation := newAlbumMutation(c.config, OpUpdate)
	return &AlbumUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AlbumClient) UpdateOne(a *Album) *AlbumUpdateOne {
	mutation := newAlbumMutation(c.config, OpUpdateOne, withAlbum(a))
	return &AlbumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AlbumClient) UpdateOneID(id uuid.UUID) *AlbumUpdateOne {
	mutation := newAlbumMutation(c.config, OpUpdateOne, withAlbumID(id))
	return &AlbumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Album.
func (c *AlbumClient) Delete() *AlbumDelete {
	mutation := newAlbumMutation(c.config, OpDelete)
	return &AlbumDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AlbumClient) DeleteOne(a *Album) *AlbumDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AlbumClient) DeleteOneID(id uuid.UUID) *AlbumDeleteOne {
	builder := c.Delete().Where(album.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AlbumDeleteOne{builder}
}

// Query returns a query builder for Album.
func (c *AlbumClient) Query() *AlbumQuery {
	return &AlbumQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAlbum},
		inters: c.Interceptors(),
	}
}

// Get returns a Album entity by its id.
func (c *AlbumClient) Get(ctx context.Context, id uuid.UUID) (*Album, error) {
	return c.Query().Where(album.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AlbumClient) GetX(ctx context.Context, id uuid.UUID) *Album {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCar queries the car edge of a Album.
func (c *AlbumClient) QueryCar(a *Album) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(album.Table, album.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, album.CarTable, album.CarColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedia queries the media edge of a Album.
func (c *AlbumClient) QueryMedia(a *Album) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(album.Table, album.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, album.MediaTable, album.MediaPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AlbumClient) Hooks() []Hook {
	return c.hooks.Album
}

// Interceptors returns the client interceptors.
func (c *AlbumClient) Interceptors() []Interceptor {
	return c.inters.Album
}

func (c *AlbumClient) mutate(ctx context.Context, m *AlbumMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AlbumCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AlbumUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AlbumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AlbumDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Album mutation op: %q", m.Op())
	}
}

// CarClient is a client for the Car schema.
type CarClient struct {
	config
}

// NewCarClient returns a client for the Car from the given config.
func NewCarClient(c config) *CarClient {
	return &CarClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `car.Hooks(f(g(h())))`.
func (c *CarClient) Use(hooks ...Hook) {
	c.hooks.Car = append(c.hooks.Car, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `car.Intercept(f(g(h())))`.
func (c *CarClient) Intercept(interceptors ...Interceptor) {
	c.inters.Car = append(c.inters.Car, interceptors...)
}

// Create returns a builder for creating a Car entity.
func (c *CarClient) Create() *CarCreate {
	mutation := newCarMutation(c.config, OpCreate)
	return &CarCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Car entities.
func (c *CarClient) CreateBulk(builders ...*CarCreate) *CarCreateBulk {
	return &CarCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CarClient) MapCreateBulk(slice any, setFunc func(*CarCreate, int)) *CarCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CarCreateBulk{err: fmt.Errorf("calling to CarClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CarCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CarCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Car.
func (c *CarClient) Update() *CarUpdate {
	mutation := newCarMutation(c.config, OpUpdate)
	return &CarUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CarClient) UpdateOne(ca *Car) *CarUpdateOne {
	mutation := newCarMutation(c.config, OpUpdateOne, withCar(ca))
	return &CarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CarClient) UpdateOneID(id uuid.UUID) *CarUpdateOne {
	mutation := newCarMutation(c.config, OpUpdateOne, withCarID(id))
	return &CarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Car.
func (c *CarClient) Delete() *CarDelete {
	mutation := newCarMutation(c.config, OpDelete)
	return &CarDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CarClient) DeleteOne(ca *Car) *CarDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CarClient) DeleteOneID(id uuid.UUID) *CarDeleteOne {
	builder := c.Delete().Where(car.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CarDeleteOne{builder}
}

// Query returns a query builder for Car.
func (c *CarClient) Query() *CarQuery {
	return &CarQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCar},
		inters: c.Interceptors(),
	}
}

// Get returns a Car entity by its id.
func (c *CarClient) Get(ctx context.Context, id uuid.UUID) (*Car, error) {
	return c.Query().Where(car.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CarClient) GetX(ctx context.Context, id uuid.UUID) *Car {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Car.
func (c *CarClient) QueryOwner(ca *Car) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, car.OwnerTable, car.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDragSessions queries the drag_sessions edge of a Car.
func (c *CarClient) QueryDragSessions(ca *Car) *DragSessionQuery {
	query := (&DragSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(dragsession.Table, dragsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, car.DragSessionsTable, car.DragSessionsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFuelUps queries the fuel_ups edge of a Car.
func (c *CarClient) QueryFuelUps(ca *Car) *FuelUpQuery {
	query := (&FuelUpClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(fuelup.Table, fuelup.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, car.FuelUpsTable, car.FuelUpsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOdometerReadings queries the odometer_readings edge of a Car.
func (c *CarClient) QueryOdometerReadings(ca *Car) *OdometerReadingQuery {
	query := (&OdometerReadingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(odometerreading.Table, odometerreading.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, car.OdometerReadingsTable, car.OdometerReadingsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceItems queries the service_items edge of a Car.
func (c *CarClient) QueryServiceItems(ca *Car) *ServiceItemQuery {
	query := (&ServiceItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(serviceitem.Table, serviceitem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, car.ServiceItemsTable, car.ServiceItemsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceLogs queries the service_logs edge of a Car.
func (c *CarClient) QueryServiceLogs(ca *Car) *ServiceLogQuery {
	query := (&ServiceLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(servicelog.Table, servicelog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, car.ServiceLogsTable, car.ServiceLogsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceSchedules queries the service_schedules edge of a Car.
func (c *CarClient) QueryServiceSchedules(ca *Car) *ServiceScheduleQuery {
	query := (&ServiceScheduleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(serviceschedule.Table, serviceschedule.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, car.ServiceSchedulesTable, car.ServiceSchedulesColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMedia queries the media edge of a Car.
func (c *CarClient) QueryMedia(ca *Car) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, car.MediaTable, car.MediaColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAlbums queries the albums edge of a Car.
func (c *CarClient) QueryAlbums(ca *Car) *AlbumQuery {
	query := (&AlbumClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(album.Table, album.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, car.AlbumsTable, car.AlbumsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDocuments queries the documents edge of a Car.
func (c *CarClient) QueryDocuments(ca *Car) *DocumentQuery {
	query := (&DocumentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(document.Table, document.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, car.DocumentsTable, car.DocumentsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDynoSessions queries the dyno_sessions edge of a Car.
func (c *CarClient) QueryDynoSessions(ca *Car) *DynoSessionQuery {
	query := (&DynoSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(dynosession.Table, dynosession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, car.DynoSessionsTable, car.DynoSessionsColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExpenses queries the expenses edge of a Car.
func (c *CarClient) QueryExpenses(ca *Car) *ExpenseQuery {
	query := (&ExpenseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(expense.Table, expense.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, car.ExpensesTable, car.ExpensesColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBannerImage queries the banner_image edge of a Car.
func (c *CarClient) QueryBannerImage(ca *Car) *MediaQuery {
	query := (&MediaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(media.Table, media.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, car.BannerImageTable, car.BannerImageColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Car.
func (c *CarClient) QueryTasks(ca *Car) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(car.Table, car.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, car.TasksTable, car.TasksColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CarClient) Hooks() []Hook {
	return c.hooks.Car
}

// Interceptors returns the client interceptors.
func (c *CarClient) Interceptors() []Interceptor {
	return c.inters.Car
}

func (c *CarClient) mutate(ctx context.Context, m *CarMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CarCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CarUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CarUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CarDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Car mutation op: %q", m.Op())
	}
}

// CheckoutSessionClient is a client for the CheckoutSession schema.
type CheckoutSessionClient struct {
	config
}

// NewCheckoutSessionClient returns a client for the CheckoutSession from the given config.
func NewCheckoutSessionClient(c config) *CheckoutSessionClient {
	return &CheckoutSessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `checkoutsession.Hooks(f(g(h())))`.
func (c *CheckoutSessionClient) Use(hooks ...Hook) {
	c.hooks.CheckoutSession = append(c.hooks.CheckoutSession, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `checkoutsession.Intercept(f(g(h())))`.
func (c *CheckoutSessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.CheckoutSession = append(c.inters.CheckoutSession, interceptors...)
}

// Create returns a builder for creating a CheckoutSession entity.
func (c *CheckoutSessionClient) Create() *CheckoutSessionCreate {
	mutation := newCheckoutSessionMutation(c.config, OpCreate)
	return &CheckoutSessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CheckoutSession entities.
func (c *CheckoutSessionClient) CreateBulk(builders ...*CheckoutSessionCreate) *CheckoutSessionCreateBulk {
	return &CheckoutSessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CheckoutSessionClient) MapCreateBulk(slice any, setFunc func(*CheckoutSessionCreate, int)) *CheckoutSessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CheckoutSessionCreateBulk{err: fmt.Errorf("calling to CheckoutSessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CheckoutSessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CheckoutSessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CheckoutSession.
func (c *CheckoutSessionClient) Update() *CheckoutSessionUpdate {
	mutation := newCheckoutSessionMutation(c.config, OpUpdate)
	return &CheckoutSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CheckoutSessionClient) UpdateOne(cs *CheckoutSession) *CheckoutSessionUpdateOne {
	mutation := newCheckoutSessionMutation(c.config, OpUpdateOne, withCheckoutSession(cs))
	return &CheckoutSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CheckoutSessionClient) UpdateOneID(id uuid.UUID) *CheckoutSessionUpdateOne {
	mutation := newCheckoutSessionMutation(c.config, OpUpdateOne, withCheckoutSessionID(id))
	return &CheckoutSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CheckoutSession.
func (c *CheckoutSessionClient) Delete() *CheckoutSessionDelete {
	mutation := newCheckoutSessionMutation(c.config, OpDelete)
	return &CheckoutSessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CheckoutSessionClient) DeleteOne(cs *CheckoutSession) *CheckoutSessionDeleteOne {
	return c.DeleteOneID(cs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CheckoutSessionClient) DeleteOneID(id uuid.UUID) *CheckoutSessionDeleteOne {
	builder := c.Delete().Where(checkoutsession.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CheckoutSessionDeleteOne{builder}
}

// Query returns a query builder for CheckoutSession.
func (c *CheckoutSessionClient) Query() *CheckoutSessionQuery {
	return &CheckoutSessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCheckoutSession},
		inters: c.Interceptors(),
	}
}

// Get returns a CheckoutSession entity by its id.
func (c *CheckoutSessionClient) Get(ctx context.Context, id uuid.UUID) (*CheckoutSession, error) {
	return c.Query().Where(checkoutsession.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CheckoutSessionClient) GetX(ctx context.Context, id uuid.UUID) *CheckoutSession {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a CheckoutSession.
func (c *CheckoutSessionClient) QueryUser(cs *CheckoutSession) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(checkoutsession.Table, checkoutsession.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, checkoutsession.UserTable, checkoutsession.UserColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscription queries the subscription edge of a CheckoutSession.
func (c *CheckoutSessionClient) QuerySubscription(cs *CheckoutSession) *SubscriptionQuery {
	query := (&SubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(checkoutsession.Table, checkoutsession.FieldID, id),
			sqlgraph.To(subscription.Table, subscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, checkoutsession.SubscriptionTable, checkoutsession.SubscriptionColumn),
		)
		fromV = sqlgraph.Neighbors(cs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CheckoutSessionClient) Hooks() []Hook {
	return c.hooks.CheckoutSession
}

// Interceptors returns the client interceptors.
func (c *CheckoutSessionClient) Interceptors() []Interceptor {
	return c.inters.CheckoutSession
}

func (c *CheckoutSessionClient) mutate(ctx context.Context, m *CheckoutSessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CheckoutSessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CheckoutSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CheckoutSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CheckoutSessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CheckoutSession mutation op: %q", m.Op())
	}
}

// DocumentClient is a client for the Document schema.
type DocumentClient struct {
	config
}

// NewDocumentClient returns a client for the Document from the given config.
func NewDocumentClient(c config) *DocumentClient {
	return &DocumentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `document.Hooks(f(g(h())))`.
func (c *DocumentClient) Use(hooks ...Hook) {
	c.hooks.Document = append(c.hooks.Document, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `document.Intercept(f(g(h())))`.
func (c *DocumentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Document = append(c.inters.Document, interceptors...)
}

// Create returns a builder for creating a Document entity.
func (c *DocumentClient) Create() *DocumentCreate {
	mutation := newDocumentMutation(c.config, OpCreate)
	return &DocumentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Document entities.
func (c *DocumentClient) CreateBulk(builders ...*DocumentCreate) *DocumentCreateBulk {
	return &DocumentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DocumentClient) MapCreateBulk(slice any, setFunc func(*DocumentCreate, int)) *DocumentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DocumentCreateBulk{err: fmt.Errorf("calling to DocumentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DocumentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DocumentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Document.
func (c *DocumentClient) Update() *DocumentUpdate {
	mutation := newDocumentMutation(c.config, OpUpdate)
	return &DocumentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DocumentClient) UpdateOne(d *Document) *DocumentUpdateOne {
	mutation := newDocumentMutation(c.config, OpUpdateOne, withDocument(d))
	return &DocumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DocumentClient) UpdateOneID(id uuid.UUID) *DocumentUpdateOne {
	mutation := newDocumentMutation(c.config, OpUpdateOne, withDocumentID(id))
	return &DocumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Document.
func (c *DocumentClient) Delete() *DocumentDelete {
	mutation := newDocumentMutation(c.config, OpDelete)
	return &DocumentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DocumentClient) DeleteOne(d *Document) *DocumentDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DocumentClient) DeleteOneID(id uuid.UUID) *DocumentDeleteOne {
	builder := c.Delete().Where(document.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DocumentDeleteOne{builder}
}

// Query returns a query builder for Document.
func (c *DocumentClient) Query() *DocumentQuery {
	return &DocumentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDocument},
		inters: c.Interceptors(),
	}
}

// Get returns a Document entity by its id.
func (c *DocumentClient) Get(ctx context.Context, id uuid.UUID) (*Document, error) {
	return c.Query().Where(document.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DocumentClient) GetX(ctx context.Context, id uuid.UUID) *Document {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCar queries the car edge of a Document.
func (c *DocumentClient) QueryCar(d *Document) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(document.Table, document.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, document.CarTable, document.CarColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DocumentClient) Hooks() []Hook {
	return c.hooks.Document
}

// Interceptors returns the client interceptors.
func (c *DocumentClient) Interceptors() []Interceptor {
	return c.inters.Document
}

func (c *DocumentClient) mutate(ctx context.Context, m *DocumentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DocumentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DocumentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DocumentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DocumentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Document mutation op: %q", m.Op())
	}
}

// DragResultClient is a client for the DragResult schema.
type DragResultClient struct {
	config
}

// NewDragResultClient returns a client for the DragResult from the given config.
func NewDragResultClient(c config) *DragResultClient {
	return &DragResultClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dragresult.Hooks(f(g(h())))`.
func (c *DragResultClient) Use(hooks ...Hook) {
	c.hooks.DragResult = append(c.hooks.DragResult, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dragresult.Intercept(f(g(h())))`.
func (c *DragResultClient) Intercept(interceptors ...Interceptor) {
	c.inters.DragResult = append(c.inters.DragResult, interceptors...)
}

// Create returns a builder for creating a DragResult entity.
func (c *DragResultClient) Create() *DragResultCreate {
	mutation := newDragResultMutation(c.config, OpCreate)
	return &DragResultCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DragResult entities.
func (c *DragResultClient) CreateBulk(builders ...*DragResultCreate) *DragResultCreateBulk {
	return &DragResultCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DragResultClient) MapCreateBulk(slice any, setFunc func(*DragResultCreate, int)) *DragResultCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DragResultCreateBulk{err: fmt.Errorf("calling to DragResultClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DragResultCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DragResultCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DragResult.
func (c *DragResultClient) Update() *DragResultUpdate {
	mutation := newDragResultMutation(c.config, OpUpdate)
	return &DragResultUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DragResultClient) UpdateOne(dr *DragResult) *DragResultUpdateOne {
	mutation := newDragResultMutation(c.config, OpUpdateOne, withDragResult(dr))
	return &DragResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DragResultClient) UpdateOneID(id uuid.UUID) *DragResultUpdateOne {
	mutation := newDragResultMutation(c.config, OpUpdateOne, withDragResultID(id))
	return &DragResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DragResult.
func (c *DragResultClient) Delete() *DragResultDelete {
	mutation := newDragResultMutation(c.config, OpDelete)
	return &DragResultDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DragResultClient) DeleteOne(dr *DragResult) *DragResultDeleteOne {
	return c.DeleteOneID(dr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DragResultClient) DeleteOneID(id uuid.UUID) *DragResultDeleteOne {
	builder := c.Delete().Where(dragresult.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DragResultDeleteOne{builder}
}

// Query returns a query builder for DragResult.
func (c *DragResultClient) Query() *DragResultQuery {
	return &DragResultQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDragResult},
		inters: c.Interceptors(),
	}
}

// Get returns a DragResult entity by its id.
func (c *DragResultClient) Get(ctx context.Context, id uuid.UUID) (*DragResult, error) {
	return c.Query().Where(dragresult.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DragResultClient) GetX(ctx context.Context, id uuid.UUID) *DragResult {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySession queries the session edge of a DragResult.
func (c *DragResultClient) QuerySession(dr *DragResult) *DragSessionQuery {
	query := (&DragSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dragresult.Table, dragresult.FieldID, id),
			sqlgraph.To(dragsession.Table, dragsession.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, dragresult.SessionTable, dragresult.SessionColumn),
		)
		fromV = sqlgraph.Neighbors(dr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DragResultClient) Hooks() []Hook {
	return c.hooks.DragResult
}

// Interceptors returns the client interceptors.
func (c *DragResultClient) Interceptors() []Interceptor {
	return c.inters.DragResult
}

func (c *DragResultClient) mutate(ctx context.Context, m *DragResultMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DragResultCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DragResultUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DragResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DragResultDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DragResult mutation op: %q", m.Op())
	}
}

// DragSessionClient is a client for the DragSession schema.
type DragSessionClient struct {
	config
}

// NewDragSessionClient returns a client for the DragSession from the given config.
func NewDragSessionClient(c config) *DragSessionClient {
	return &DragSessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dragsession.Hooks(f(g(h())))`.
func (c *DragSessionClient) Use(hooks ...Hook) {
	c.hooks.DragSession = append(c.hooks.DragSession, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dragsession.Intercept(f(g(h())))`.
func (c *DragSessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.DragSession = append(c.inters.DragSession, interceptors...)
}

// Create returns a builder for creating a DragSession entity.
func (c *DragSessionClient) Create() *DragSessionCreate {
	mutation := newDragSessionMutation(c.config, OpCreate)
	return &DragSessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DragSession entities.
func (c *DragSessionClient) CreateBulk(builders ...*DragSessionCreate) *DragSessionCreateBulk {
	return &DragSessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DragSessionClient) MapCreateBulk(slice any, setFunc func(*DragSessionCreate, int)) *DragSessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DragSessionCreateBulk{err: fmt.Errorf("calling to DragSessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DragSessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DragSessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DragSession.
func (c *DragSessionClient) Update() *DragSessionUpdate {
	mutation := newDragSessionMutation(c.config, OpUpdate)
	return &DragSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DragSessionClient) UpdateOne(ds *DragSession) *DragSessionUpdateOne {
	mutation := newDragSessionMutation(c.config, OpUpdateOne, withDragSession(ds))
	return &DragSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DragSessionClient) UpdateOneID(id uuid.UUID) *DragSessionUpdateOne {
	mutation := newDragSessionMutation(c.config, OpUpdateOne, withDragSessionID(id))
	return &DragSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DragSession.
func (c *DragSessionClient) Delete() *DragSessionDelete {
	mutation := newDragSessionMutation(c.config, OpDelete)
	return &DragSessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DragSessionClient) DeleteOne(ds *DragSession) *DragSessionDeleteOne {
	return c.DeleteOneID(ds.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DragSessionClient) DeleteOneID(id uuid.UUID) *DragSessionDeleteOne {
	builder := c.Delete().Where(dragsession.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DragSessionDeleteOne{builder}
}

// Query returns a query builder for DragSession.
func (c *DragSessionClient) Query() *DragSessionQuery {
	return &DragSessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDragSession},
		inters: c.Interceptors(),
	}
}

// Get returns a DragSession entity by its id.
func (c *DragSessionClient) Get(ctx context.Context, id uuid.UUID) (*DragSession, error) {
	return c.Query().Where(dragsession.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DragSessionClient) GetX(ctx context.Context, id uuid.UUID) *DragSession {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCar queries the car edge of a DragSession.
func (c *DragSessionClient) QueryCar(ds *DragSession) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ds.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dragsession.Table, dragsession.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, dragsession.CarTable, dragsession.CarColumn),
		)
		fromV = sqlgraph.Neighbors(ds.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResults queries the results edge of a DragSession.
func (c *DragSessionClient) QueryResults(ds *DragSession) *DragResultQuery {
	query := (&DragResultClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ds.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dragsession.Table, dragsession.FieldID, id),
			sqlgraph.To(dragresult.Table, dragresult.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, dragsession.ResultsTable, dragsession.ResultsColumn),
		)
		fromV = sqlgraph.Neighbors(ds.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DragSessionClient) Hooks() []Hook {
	return c.hooks.DragSession
}

// Interceptors returns the client interceptors.
func (c *DragSessionClient) Interceptors() []Interceptor {
	return c.inters.DragSession
}

func (c *DragSessionClient) mutate(ctx context.Context, m *DragSessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DragSessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DragSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DragSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DragSessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DragSession mutation op: %q", m.Op())
	}
}

// DynoResultClient is a client for the DynoResult schema.
type DynoResultClient struct {
	config
}

// NewDynoResultClient returns a client for the DynoResult from the given config.
func NewDynoResultClient(c config) *DynoResultClient {
	return &DynoResultClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dynoresult.Hooks(f(g(h())))`.
func (c *DynoResultClient) Use(hooks ...Hook) {
	c.hooks.DynoResult = append(c.hooks.DynoResult, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dynoresult.Intercept(f(g(h())))`.
func (c *DynoResultClient) Intercept(interceptors ...Interceptor) {
	c.inters.DynoResult = append(c.inters.DynoResult, interceptors...)
}

// Create returns a builder for creating a DynoResult entity.
func (c *DynoResultClient) Create() *DynoResultCreate {
	mutation := newDynoResultMutation(c.config, OpCreate)
	return &DynoResultCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DynoResult entities.
func (c *DynoResultClient) CreateBulk(builders ...*DynoResultCreate) *DynoResultCreateBulk {
	return &DynoResultCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DynoResultClient) MapCreateBulk(slice any, setFunc func(*DynoResultCreate, int)) *DynoResultCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DynoResultCreateBulk{err: fmt.Errorf("calling to DynoResultClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DynoResultCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DynoResultCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DynoResult.
func (c *DynoResultClient) Update() *DynoResultUpdate {
	mutation := newDynoResultMutation(c.config, OpUpdate)
	return &DynoResultUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DynoResultClient) UpdateOne(dr *DynoResult) *DynoResultUpdateOne {
	mutation := newDynoResultMutation(c.config, OpUpdateOne, withDynoResult(dr))
	return &DynoResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DynoResultClient) UpdateOneID(id uuid.UUID) *DynoResultUpdateOne {
	mutation := newDynoResultMutation(c.config, OpUpdateOne, withDynoResultID(id))
	return &DynoResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DynoResult.
func (c *DynoResultClient) Delete() *DynoResultDelete {
	mutation := newDynoResultMutation(c.config, OpDelete)
	return &DynoResultDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DynoResultClient) DeleteOne(dr *DynoResult) *DynoResultDeleteOne {
	return c.DeleteOneID(dr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DynoResultClient) DeleteOneID(id uuid.UUID) *DynoResultDeleteOne {
	builder := c.Delete().Where(dynoresult.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DynoResultDeleteOne{builder}
}

// Query returns a query builder for DynoResult.
func (c *DynoResultClient) Query() *DynoResultQuery {
	return &DynoResultQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDynoResult},
		inters: c.Interceptors(),
	}
}

// Get returns a DynoResult entity by its id.
func (c *DynoResultClient) Get(ctx context.Context, id uuid.UUID) (*DynoResult, error) {
	return c.Query().Where(dynoresult.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DynoResultClient) GetX(ctx context.Context, id uuid.UUID) *DynoResult {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySession queries the session edge of a DynoResult.
func (c *DynoResultClient) QuerySession(dr *DynoResult) *DynoSessionQuery {
	query := (&DynoSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dynoresult.Table, dynoresult.FieldID, id),
			sqlgraph.To(dynosession.Table, dynosession.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, dynoresult.SessionTable, dynoresult.SessionColumn),
		)
		fromV = sqlgraph.Neighbors(dr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DynoResultClient) Hooks() []Hook {
	return c.hooks.DynoResult
}

// Interceptors returns the client interceptors.
func (c *DynoResultClient) Interceptors() []Interceptor {
	return c.inters.DynoResult
}

func (c *DynoResultClient) mutate(ctx context.Context, m *DynoResultMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DynoResultCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DynoResultUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DynoResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DynoResultDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DynoResult mutation op: %q", m.Op())
	}
}

// DynoSessionClient is a client for the DynoSession schema.
type DynoSessionClient struct {
	config
}

// NewDynoSessionClient returns a client for the DynoSession from the given config.
func NewDynoSessionClient(c config) *DynoSessionClient {
	return &DynoSessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dynosession.Hooks(f(g(h())))`.
func (c *DynoSessionClient) Use(hooks ...Hook) {
	c.hooks.DynoSession = append(c.hooks.DynoSession, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dynosession.Intercept(f(g(h())))`.
func (c *DynoSessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.DynoSession = append(c.inters.DynoSession, interceptors...)
}

// Create returns a builder for creating a DynoSession entity.
func (c *DynoSessionClient) Create() *DynoSessionCreate {
	mutation := newDynoSessionMutation(c.config, OpCreate)
	return &DynoSessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DynoSession entities.
func (c *DynoSessionClient) CreateBulk(builders ...*DynoSessionCreate) *DynoSessionCreateBulk {
	return &DynoSessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DynoSessionClient) MapCreateBulk(slice any, setFunc func(*DynoSessionCreate, int)) *DynoSessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DynoSessionCreateBulk{err: fmt.Errorf("calling to DynoSessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DynoSessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DynoSessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DynoSession.
func (c *DynoSessionClient) Update() *DynoSessionUpdate {
	mutation := newDynoSessionMutation(c.config, OpUpdate)
	return &DynoSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DynoSessionClient) UpdateOne(ds *DynoSession) *DynoSessionUpdateOne {
	mutation := newDynoSessionMutation(c.config, OpUpdateOne, withDynoSession(ds))
	return &DynoSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DynoSessionClient) UpdateOneID(id uuid.UUID) *DynoSessionUpdateOne {
	mutation := newDynoSessionMutation(c.config, OpUpdateOne, withDynoSessionID(id))
	return &DynoSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DynoSession.
func (c *DynoSessionClient) Delete() *DynoSessionDelete {
	mutation := newDynoSessionMutation(c.config, OpDelete)
	return &DynoSessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DynoSessionClient) DeleteOne(ds *DynoSession) *DynoSessionDeleteOne {
	return c.DeleteOneID(ds.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DynoSessionClient) DeleteOneID(id uuid.UUID) *DynoSessionDeleteOne {
	builder := c.Delete().Where(dynosession.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DynoSessionDeleteOne{builder}
}

// Query returns a query builder for DynoSession.
func (c *DynoSessionClient) Query() *DynoSessionQuery {
	return &DynoSessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDynoSession},
		inters: c.Interceptors(),
	}
}

// Get returns a DynoSession entity by its id.
func (c *DynoSessionClient) Get(ctx context.Context, id uuid.UUID) (*DynoSession, error) {
	return c.Query().Where(dynosession.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DynoSessionClient) GetX(ctx context.Context, id uuid.UUID) *DynoSession {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCar queries the car edge of a DynoSession.
func (c *DynoSessionClient) QueryCar(ds *DynoSession) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ds.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dynosession.Table, dynosession.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, dynosession.CarTable, dynosession.CarColumn),
		)
		fromV = sqlgraph.Neighbors(ds.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResults queries the results edge of a DynoSession.
func (c *DynoSessionClient) QueryResults(ds *DynoSession) *DynoResultQuery {
	query := (&DynoResultClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ds.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dynosession.Table, dynosession.FieldID, id),
			sqlgraph.To(dynoresult.Table, dynoresult.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, dynosession.ResultsTable, dynosession.ResultsColumn),
		)
		fromV = sqlgraph.Neighbors(ds.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DynoSessionClient) Hooks() []Hook {
	return c.hooks.DynoSession
}

// Interceptors returns the client interceptors.
func (c *DynoSessionClient) Interceptors() []Interceptor {
	return c.inters.DynoSession
}

func (c *DynoSessionClient) mutate(ctx context.Context, m *DynoSessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DynoSessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DynoSessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DynoSessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DynoSessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DynoSession mutation op: %q", m.Op())
	}
}

// ExpenseClient is a client for the Expense schema.
type ExpenseClient struct {
	config
}

// NewExpenseClient returns a client for the Expense from the given config.
func NewExpenseClient(c config) *ExpenseClient {
	return &ExpenseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `expense.Hooks(f(g(h())))`.
func (c *ExpenseClient) Use(hooks ...Hook) {
	c.hooks.Expense = append(c.hooks.Expense, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `expense.Intercept(f(g(h())))`.
func (c *ExpenseClient) Intercept(interceptors ...Interceptor) {
	c.inters.Expense = append(c.inters.Expense, interceptors...)
}

// Create returns a builder for creating a Expense entity.
func (c *ExpenseClient) Create() *ExpenseCreate {
	mutation := newExpenseMutation(c.config, OpCreate)
	return &ExpenseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Expense entities.
func (c *ExpenseClient) CreateBulk(builders ...*ExpenseCreate) *ExpenseCreateBulk {
	return &ExpenseCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExpenseClient) MapCreateBulk(slice any, setFunc func(*ExpenseCreate, int)) *ExpenseCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExpenseCreateBulk{err: fmt.Errorf("calling to ExpenseClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExpenseCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExpenseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Expense.
func (c *ExpenseClient) Update() *ExpenseUpdate {
	mutation := newExpenseMutation(c.config, OpUpdate)
	return &ExpenseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExpenseClient) UpdateOne(e *Expense) *ExpenseUpdateOne {
	mutation := newExpenseMutation(c.config, OpUpdateOne, withExpense(e))
	return &ExpenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExpenseClient) UpdateOneID(id uuid.UUID) *ExpenseUpdateOne {
	mutation := newExpenseMutation(c.config, OpUpdateOne, withExpenseID(id))
	return &ExpenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Expense.
func (c *ExpenseClient) Delete() *ExpenseDelete {
	mutation := newExpenseMutation(c.config, OpDelete)
	return &ExpenseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExpenseClient) DeleteOne(e *Expense) *ExpenseDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExpenseClient) DeleteOneID(id uuid.UUID) *ExpenseDeleteOne {
	builder := c.Delete().Where(expense.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExpenseDeleteOne{builder}
}

// Query returns a query builder for Expense.
func (c *ExpenseClient) Query() *ExpenseQuery {
	return &ExpenseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExpense},
		inters: c.Interceptors(),
	}
}

// Get returns a Expense entity by its id.
func (c *ExpenseClient) Get(ctx context.Context, id uuid.UUID) (*Expense, error) {
	return c.Query().Where(expense.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExpenseClient) GetX(ctx context.Context, id uuid.UUID) *Expense {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCar queries the car edge of a Expense.
func (c *ExpenseClient) QueryCar(e *Expense) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(expense.Table, expense.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, expense.CarTable, expense.CarColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFuelUp queries the fuel_up edge of a Expense.
func (c *ExpenseClient) QueryFuelUp(e *Expense) *FuelUpQuery {
	query := (&FuelUpClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(expense.Table, expense.FieldID, id),
			sqlgraph.To(fuelup.Table, fuelup.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, expense.FuelUpTable, expense.FuelUpColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceLog queries the service_log edge of a Expense.
func (c *ExpenseClient) QueryServiceLog(e *Expense) *ServiceLogQuery {
	query := (&ServiceLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(expense.Table, expense.FieldID, id),
			sqlgraph.To(servicelog.Table, servicelog.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, expense.ServiceLogTable, expense.ServiceLogColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExpenseClient) Hooks() []Hook {
	return c.hooks.Expense
}

// Interceptors returns the client interceptors.
func (c *ExpenseClient) Interceptors() []Interceptor {
	return c.inters.Expense
}

func (c *ExpenseClient) mutate(ctx context.Context, m *ExpenseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExpenseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExpenseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExpenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExpenseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Expense mutation op: %q", m.Op())
	}
}

// FuelUpClient is a client for the FuelUp schema.
type FuelUpClient struct {
	config
}

// NewFuelUpClient returns a client for the FuelUp from the given config.
func NewFuelUpClient(c config) *FuelUpClient {
	return &FuelUpClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fuelup.Hooks(f(g(h())))`.
func (c *FuelUpClient) Use(hooks ...Hook) {
	c.hooks.FuelUp = append(c.hooks.FuelUp, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fuelup.Intercept(f(g(h())))`.
func (c *FuelUpClient) Intercept(interceptors ...Interceptor) {
	c.inters.FuelUp = append(c.inters.FuelUp, interceptors...)
}

// Create returns a builder for creating a FuelUp entity.
func (c *FuelUpClient) Create() *FuelUpCreate {
	mutation := newFuelUpMutation(c.config, OpCreate)
	return &FuelUpCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FuelUp entities.
func (c *FuelUpClient) CreateBulk(builders ...*FuelUpCreate) *FuelUpCreateBulk {
	return &FuelUpCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FuelUpClient) MapCreateBulk(slice any, setFunc func(*FuelUpCreate, int)) *FuelUpCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FuelUpCreateBulk{err: fmt.Errorf("calling to FuelUpClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FuelUpCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FuelUpCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FuelUp.
func (c *FuelUpClient) Update() *FuelUpUpdate {
	mutation := newFuelUpMutation(c.config, OpUpdate)
	return &FuelUpUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FuelUpClient) UpdateOne(fu *FuelUp) *FuelUpUpdateOne {
	mutation := newFuelUpMutation(c.config, OpUpdateOne, withFuelUp(fu))
	return &FuelUpUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FuelUpClient) UpdateOneID(id uuid.UUID) *FuelUpUpdateOne {
	mutation := newFuelUpMutation(c.config, OpUpdateOne, withFuelUpID(id))
	return &FuelUpUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FuelUp.
func (c *FuelUpClient) Delete() *FuelUpDelete {
	mutation := newFuelUpMutation(c.config, OpDelete)
	return &FuelUpDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FuelUpClient) DeleteOne(fu *FuelUp) *FuelUpDeleteOne {
	return c.DeleteOneID(fu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FuelUpClient) DeleteOneID(id uuid.UUID) *FuelUpDeleteOne {
	builder := c.Delete().Where(fuelup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FuelUpDeleteOne{builder}
}

// Query returns a query builder for FuelUp.
func (c *FuelUpClient) Query() *FuelUpQuery {
	return &FuelUpQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFuelUp},
		inters: c.Interceptors(),
	}
}

// Get returns a FuelUp entity by its id.
func (c *FuelUpClient) Get(ctx context.Context, id uuid.UUID) (*FuelUp, error) {
	return c.Query().Where(fuelup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FuelUpClient) GetX(ctx context.Context, id uuid.UUID) *FuelUp {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCar queries the car edge of a FuelUp.
func (c *FuelUpClient) QueryCar(fu *FuelUp) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fuelup.Table, fuelup.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fuelup.CarTable, fuelup.CarColumn),
		)
		fromV = sqlgraph.Neighbors(fu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOdometerReading queries the odometer_reading edge of a FuelUp.
func (c *FuelUpClient) QueryOdometerReading(fu *FuelUp) *OdometerReadingQuery {
	query := (&OdometerReadingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fuelup.Table, fuelup.FieldID, id),
			sqlgraph.To(odometerreading.Table, odometerreading.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, fuelup.OdometerReadingTable, fuelup.OdometerReadingColumn),
		)
		fromV = sqlgraph.Neighbors(fu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExpense queries the expense edge of a FuelUp.
func (c *FuelUpClient) QueryExpense(fu *FuelUp) *ExpenseQuery {
	query := (&ExpenseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fuelup.Table, fuelup.FieldID, id),
			sqlgraph.To(expense.Table, expense.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, fuelup.ExpenseTable, fuelup.ExpenseColumn),
		)
		fromV = sqlgraph.Neighbors(fu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FuelUpClient) Hooks() []Hook {
	return c.hooks.FuelUp
}

// Interceptors returns the client interceptors.
func (c *FuelUpClient) Interceptors() []Interceptor {
	return c.inters.FuelUp
}

func (c *FuelUpClient) mutate(ctx context.Context, m *FuelUpMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FuelUpCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FuelUpUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FuelUpUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FuelUpDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FuelUp mutation op: %q", m.Op())
	}
}

// MediaClient is a client for the Media schema.
type MediaClient struct {
	config
}

// NewMediaClient returns a client for the Media from the given config.
func NewMediaClient(c config) *MediaClient {
	return &MediaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `media.Hooks(f(g(h())))`.
func (c *MediaClient) Use(hooks ...Hook) {
	c.hooks.Media = append(c.hooks.Media, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `media.Intercept(f(g(h())))`.
func (c *MediaClient) Intercept(interceptors ...Interceptor) {
	c.inters.Media = append(c.inters.Media, interceptors...)
}

// Create returns a builder for creating a Media entity.
func (c *MediaClient) Create() *MediaCreate {
	mutation := newMediaMutation(c.config, OpCreate)
	return &MediaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Media entities.
func (c *MediaClient) CreateBulk(builders ...*MediaCreate) *MediaCreateBulk {
	return &MediaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MediaClient) MapCreateBulk(slice any, setFunc func(*MediaCreate, int)) *MediaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MediaCreateBulk{err: fmt.Errorf("calling to MediaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MediaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MediaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Media.
func (c *MediaClient) Update() *MediaUpdate {
	mutation := newMediaMutation(c.config, OpUpdate)
	return &MediaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MediaClient) UpdateOne(m *Media) *MediaUpdateOne {
	mutation := newMediaMutation(c.config, OpUpdateOne, withMedia(m))
	return &MediaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MediaClient) UpdateOneID(id uuid.UUID) *MediaUpdateOne {
	mutation := newMediaMutation(c.config, OpUpdateOne, withMediaID(id))
	return &MediaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Media.
func (c *MediaClient) Delete() *MediaDelete {
	mutation := newMediaMutation(c.config, OpDelete)
	return &MediaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MediaClient) DeleteOne(m *Media) *MediaDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MediaClient) DeleteOneID(id uuid.UUID) *MediaDeleteOne {
	builder := c.Delete().Where(media.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MediaDeleteOne{builder}
}

// Query returns a query builder for Media.
func (c *MediaClient) Query() *MediaQuery {
	return &MediaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMedia},
		inters: c.Interceptors(),
	}
}

// Get returns a Media entity by its id.
func (c *MediaClient) Get(ctx context.Context, id uuid.UUID) (*Media, error) {
	return c.Query().Where(media.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MediaClient) GetX(ctx context.Context, id uuid.UUID) *Media {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCar queries the car edge of a Media.
func (c *MediaClient) QueryCar(m *Media) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, media.CarTable, media.CarColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAlbums queries the albums edge of a Media.
func (c *MediaClient) QueryAlbums(m *Media) *AlbumQuery {
	query := (&AlbumClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(media.Table, media.FieldID, id),
			sqlgraph.To(album.Table, album.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, media.AlbumsTable, media.AlbumsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MediaClient) Hooks() []Hook {
	return c.hooks.Media
}

// Interceptors returns the client interceptors.
func (c *MediaClient) Interceptors() []Interceptor {
	return c.inters.Media
}

func (c *MediaClient) mutate(ctx context.Context, m *MediaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MediaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MediaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MediaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MediaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Media mutation op: %q", m.Op())
	}
}

// OdometerReadingClient is a client for the OdometerReading schema.
type OdometerReadingClient struct {
	config
}

// NewOdometerReadingClient returns a client for the OdometerReading from the given config.
func NewOdometerReadingClient(c config) *OdometerReadingClient {
	return &OdometerReadingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `odometerreading.Hooks(f(g(h())))`.
func (c *OdometerReadingClient) Use(hooks ...Hook) {
	c.hooks.OdometerReading = append(c.hooks.OdometerReading, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `odometerreading.Intercept(f(g(h())))`.
func (c *OdometerReadingClient) Intercept(interceptors ...Interceptor) {
	c.inters.OdometerReading = append(c.inters.OdometerReading, interceptors...)
}

// Create returns a builder for creating a OdometerReading entity.
func (c *OdometerReadingClient) Create() *OdometerReadingCreate {
	mutation := newOdometerReadingMutation(c.config, OpCreate)
	return &OdometerReadingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OdometerReading entities.
func (c *OdometerReadingClient) CreateBulk(builders ...*OdometerReadingCreate) *OdometerReadingCreateBulk {
	return &OdometerReadingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OdometerReadingClient) MapCreateBulk(slice any, setFunc func(*OdometerReadingCreate, int)) *OdometerReadingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OdometerReadingCreateBulk{err: fmt.Errorf("calling to OdometerReadingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OdometerReadingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OdometerReadingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OdometerReading.
func (c *OdometerReadingClient) Update() *OdometerReadingUpdate {
	mutation := newOdometerReadingMutation(c.config, OpUpdate)
	return &OdometerReadingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OdometerReadingClient) UpdateOne(or *OdometerReading) *OdometerReadingUpdateOne {
	mutation := newOdometerReadingMutation(c.config, OpUpdateOne, withOdometerReading(or))
	return &OdometerReadingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OdometerReadingClient) UpdateOneID(id uuid.UUID) *OdometerReadingUpdateOne {
	mutation := newOdometerReadingMutation(c.config, OpUpdateOne, withOdometerReadingID(id))
	return &OdometerReadingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OdometerReading.
func (c *OdometerReadingClient) Delete() *OdometerReadingDelete {
	mutation := newOdometerReadingMutation(c.config, OpDelete)
	return &OdometerReadingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OdometerReadingClient) DeleteOne(or *OdometerReading) *OdometerReadingDeleteOne {
	return c.DeleteOneID(or.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OdometerReadingClient) DeleteOneID(id uuid.UUID) *OdometerReadingDeleteOne {
	builder := c.Delete().Where(odometerreading.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OdometerReadingDeleteOne{builder}
}

// Query returns a query builder for OdometerReading.
func (c *OdometerReadingClient) Query() *OdometerReadingQuery {
	return &OdometerReadingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOdometerReading},
		inters: c.Interceptors(),
	}
}

// Get returns a OdometerReading entity by its id.
func (c *OdometerReadingClient) Get(ctx context.Context, id uuid.UUID) (*OdometerReading, error) {
	return c.Query().Where(odometerreading.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OdometerReadingClient) GetX(ctx context.Context, id uuid.UUID) *OdometerReading {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCar queries the car edge of a OdometerReading.
func (c *OdometerReadingClient) QueryCar(or *OdometerReading) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := or.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(odometerreading.Table, odometerreading.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, odometerreading.CarTable, odometerreading.CarColumn),
		)
		fromV = sqlgraph.Neighbors(or.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFuelUp queries the fuel_up edge of a OdometerReading.
func (c *OdometerReadingClient) QueryFuelUp(or *OdometerReading) *FuelUpQuery {
	query := (&FuelUpClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := or.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(odometerreading.Table, odometerreading.FieldID, id),
			sqlgraph.To(fuelup.Table, fuelup.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, odometerreading.FuelUpTable, odometerreading.FuelUpColumn),
		)
		fromV = sqlgraph.Neighbors(or.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceLog queries the service_log edge of a OdometerReading.
func (c *OdometerReadingClient) QueryServiceLog(or *OdometerReading) *ServiceLogQuery {
	query := (&ServiceLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := or.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(odometerreading.Table, odometerreading.FieldID, id),
			sqlgraph.To(servicelog.Table, servicelog.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, odometerreading.ServiceLogTable, odometerreading.ServiceLogColumn),
		)
		fromV = sqlgraph.Neighbors(or.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OdometerReadingClient) Hooks() []Hook {
	return c.hooks.OdometerReading
}

// Interceptors returns the client interceptors.
func (c *OdometerReadingClient) Interceptors() []Interceptor {
	return c.inters.OdometerReading
}

func (c *OdometerReadingClient) mutate(ctx context.Context, m *OdometerReadingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OdometerReadingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OdometerReadingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OdometerReadingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OdometerReadingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OdometerReading mutation op: %q", m.Op())
	}
}

// ProfileClient is a client for the Profile schema.
type ProfileClient struct {
	config
}

// NewProfileClient returns a client for the Profile from the given config.
func NewProfileClient(c config) *ProfileClient {
	return &ProfileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `profile.Hooks(f(g(h())))`.
func (c *ProfileClient) Use(hooks ...Hook) {
	c.hooks.Profile = append(c.hooks.Profile, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `profile.Intercept(f(g(h())))`.
func (c *ProfileClient) Intercept(interceptors ...Interceptor) {
	c.inters.Profile = append(c.inters.Profile, interceptors...)
}

// Create returns a builder for creating a Profile entity.
func (c *ProfileClient) Create() *ProfileCreate {
	mutation := newProfileMutation(c.config, OpCreate)
	return &ProfileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Profile entities.
func (c *ProfileClient) CreateBulk(builders ...*ProfileCreate) *ProfileCreateBulk {
	return &ProfileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProfileClient) MapCreateBulk(slice any, setFunc func(*ProfileCreate, int)) *ProfileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProfileCreateBulk{err: fmt.Errorf("calling to ProfileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProfileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProfileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Profile.
func (c *ProfileClient) Update() *ProfileUpdate {
	mutation := newProfileMutation(c.config, OpUpdate)
	return &ProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProfileClient) UpdateOne(pr *Profile) *ProfileUpdateOne {
	mutation := newProfileMutation(c.config, OpUpdateOne, withProfile(pr))
	return &ProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProfileClient) UpdateOneID(id uuid.UUID) *ProfileUpdateOne {
	mutation := newProfileMutation(c.config, OpUpdateOne, withProfileID(id))
	return &ProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Profile.
func (c *ProfileClient) Delete() *ProfileDelete {
	mutation := newProfileMutation(c.config, OpDelete)
	return &ProfileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProfileClient) DeleteOne(pr *Profile) *ProfileDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProfileClient) DeleteOneID(id uuid.UUID) *ProfileDeleteOne {
	builder := c.Delete().Where(profile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProfileDeleteOne{builder}
}

// Query returns a query builder for Profile.
func (c *ProfileClient) Query() *ProfileQuery {
	return &ProfileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProfile},
		inters: c.Interceptors(),
	}
}

// Get returns a Profile entity by its id.
func (c *ProfileClient) Get(ctx context.Context, id uuid.UUID) (*Profile, error) {
	return c.Query().Where(profile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProfileClient) GetX(ctx context.Context, id uuid.UUID) *Profile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Profile.
func (c *ProfileClient) QueryUser(pr *Profile) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, profile.UserTable, profile.UserColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProfileClient) Hooks() []Hook {
	return c.hooks.Profile
}

// Interceptors returns the client interceptors.
func (c *ProfileClient) Interceptors() []Interceptor {
	return c.inters.Profile
}

func (c *ProfileClient) mutate(ctx context.Context, m *ProfileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProfileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProfileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Profile mutation op: %q", m.Op())
	}
}

// ServiceItemClient is a client for the ServiceItem schema.
type ServiceItemClient struct {
	config
}

// NewServiceItemClient returns a client for the ServiceItem from the given config.
func NewServiceItemClient(c config) *ServiceItemClient {
	return &ServiceItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `serviceitem.Hooks(f(g(h())))`.
func (c *ServiceItemClient) Use(hooks ...Hook) {
	c.hooks.ServiceItem = append(c.hooks.ServiceItem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `serviceitem.Intercept(f(g(h())))`.
func (c *ServiceItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.ServiceItem = append(c.inters.ServiceItem, interceptors...)
}

// Create returns a builder for creating a ServiceItem entity.
func (c *ServiceItemClient) Create() *ServiceItemCreate {
	mutation := newServiceItemMutation(c.config, OpCreate)
	return &ServiceItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ServiceItem entities.
func (c *ServiceItemClient) CreateBulk(builders ...*ServiceItemCreate) *ServiceItemCreateBulk {
	return &ServiceItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceItemClient) MapCreateBulk(slice any, setFunc func(*ServiceItemCreate, int)) *ServiceItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceItemCreateBulk{err: fmt.Errorf("calling to ServiceItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ServiceItem.
func (c *ServiceItemClient) Update() *ServiceItemUpdate {
	mutation := newServiceItemMutation(c.config, OpUpdate)
	return &ServiceItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceItemClient) UpdateOne(si *ServiceItem) *ServiceItemUpdateOne {
	mutation := newServiceItemMutation(c.config, OpUpdateOne, withServiceItem(si))
	return &ServiceItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceItemClient) UpdateOneID(id uuid.UUID) *ServiceItemUpdateOne {
	mutation := newServiceItemMutation(c.config, OpUpdateOne, withServiceItemID(id))
	return &ServiceItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ServiceItem.
func (c *ServiceItemClient) Delete() *ServiceItemDelete {
	mutation := newServiceItemMutation(c.config, OpDelete)
	return &ServiceItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceItemClient) DeleteOne(si *ServiceItem) *ServiceItemDeleteOne {
	return c.DeleteOneID(si.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceItemClient) DeleteOneID(id uuid.UUID) *ServiceItemDeleteOne {
	builder := c.Delete().Where(serviceitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceItemDeleteOne{builder}
}

// Query returns a query builder for ServiceItem.
func (c *ServiceItemClient) Query() *ServiceItemQuery {
	return &ServiceItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServiceItem},
		inters: c.Interceptors(),
	}
}

// Get returns a ServiceItem entity by its id.
func (c *ServiceItemClient) Get(ctx context.Context, id uuid.UUID) (*ServiceItem, error) {
	return c.Query().Where(serviceitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceItemClient) GetX(ctx context.Context, id uuid.UUID) *ServiceItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCar queries the car edge of a ServiceItem.
func (c *ServiceItemClient) QueryCar(si *ServiceItem) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := si.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceitem.Table, serviceitem.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, serviceitem.CarTable, serviceitem.CarColumn),
		)
		fromV = sqlgraph.Neighbors(si.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySchedules queries the schedules edge of a ServiceItem.
func (c *ServiceItemClient) QuerySchedules(si *ServiceItem) *ServiceScheduleQuery {
	query := (&ServiceScheduleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := si.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceitem.Table, serviceitem.FieldID, id),
			sqlgraph.To(serviceschedule.Table, serviceschedule.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, serviceitem.SchedulesTable, serviceitem.SchedulesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(si.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLogs queries the logs edge of a ServiceItem.
func (c *ServiceItemClient) QueryLogs(si *ServiceItem) *ServiceLogQuery {
	query := (&ServiceLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := si.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceitem.Table, serviceitem.FieldID, id),
			sqlgraph.To(servicelog.Table, servicelog.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, serviceitem.LogsTable, serviceitem.LogsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(si.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceItemClient) Hooks() []Hook {
	return c.hooks.ServiceItem
}

// Interceptors returns the client interceptors.
func (c *ServiceItemClient) Interceptors() []Interceptor {
	return c.inters.ServiceItem
}

func (c *ServiceItemClient) mutate(ctx context.Context, m *ServiceItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ServiceItem mutation op: %q", m.Op())
	}
}

// ServiceLogClient is a client for the ServiceLog schema.
type ServiceLogClient struct {
	config
}

// NewServiceLogClient returns a client for the ServiceLog from the given config.
func NewServiceLogClient(c config) *ServiceLogClient {
	return &ServiceLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `servicelog.Hooks(f(g(h())))`.
func (c *ServiceLogClient) Use(hooks ...Hook) {
	c.hooks.ServiceLog = append(c.hooks.ServiceLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `servicelog.Intercept(f(g(h())))`.
func (c *ServiceLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.ServiceLog = append(c.inters.ServiceLog, interceptors...)
}

// Create returns a builder for creating a ServiceLog entity.
func (c *ServiceLogClient) Create() *ServiceLogCreate {
	mutation := newServiceLogMutation(c.config, OpCreate)
	return &ServiceLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ServiceLog entities.
func (c *ServiceLogClient) CreateBulk(builders ...*ServiceLogCreate) *ServiceLogCreateBulk {
	return &ServiceLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceLogClient) MapCreateBulk(slice any, setFunc func(*ServiceLogCreate, int)) *ServiceLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceLogCreateBulk{err: fmt.Errorf("calling to ServiceLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ServiceLog.
func (c *ServiceLogClient) Update() *ServiceLogUpdate {
	mutation := newServiceLogMutation(c.config, OpUpdate)
	return &ServiceLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceLogClient) UpdateOne(sl *ServiceLog) *ServiceLogUpdateOne {
	mutation := newServiceLogMutation(c.config, OpUpdateOne, withServiceLog(sl))
	return &ServiceLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceLogClient) UpdateOneID(id uuid.UUID) *ServiceLogUpdateOne {
	mutation := newServiceLogMutation(c.config, OpUpdateOne, withServiceLogID(id))
	return &ServiceLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ServiceLog.
func (c *ServiceLogClient) Delete() *ServiceLogDelete {
	mutation := newServiceLogMutation(c.config, OpDelete)
	return &ServiceLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceLogClient) DeleteOne(sl *ServiceLog) *ServiceLogDeleteOne {
	return c.DeleteOneID(sl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceLogClient) DeleteOneID(id uuid.UUID) *ServiceLogDeleteOne {
	builder := c.Delete().Where(servicelog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceLogDeleteOne{builder}
}

// Query returns a query builder for ServiceLog.
func (c *ServiceLogClient) Query() *ServiceLogQuery {
	return &ServiceLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServiceLog},
		inters: c.Interceptors(),
	}
}

// Get returns a ServiceLog entity by its id.
func (c *ServiceLogClient) Get(ctx context.Context, id uuid.UUID) (*ServiceLog, error) {
	return c.Query().Where(servicelog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceLogClient) GetX(ctx context.Context, id uuid.UUID) *ServiceLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCar queries the car edge of a ServiceLog.
func (c *ServiceLogClient) QueryCar(sl *ServiceLog) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servicelog.Table, servicelog.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, servicelog.CarTable, servicelog.CarColumn),
		)
		fromV = sqlgraph.Neighbors(sl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryItems queries the items edge of a ServiceLog.
func (c *ServiceLogClient) QueryItems(sl *ServiceLog) *ServiceItemQuery {
	query := (&ServiceItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servicelog.Table, servicelog.FieldID, id),
			sqlgraph.To(serviceitem.Table, serviceitem.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, servicelog.ItemsTable, servicelog.ItemsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(sl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySchedule queries the schedule edge of a ServiceLog.
func (c *ServiceLogClient) QuerySchedule(sl *ServiceLog) *ServiceScheduleQuery {
	query := (&ServiceScheduleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servicelog.Table, servicelog.FieldID, id),
			sqlgraph.To(serviceschedule.Table, serviceschedule.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, servicelog.ScheduleTable, servicelog.ScheduleColumn),
		)
		fromV = sqlgraph.Neighbors(sl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOdometerReading queries the odometer_reading edge of a ServiceLog.
func (c *ServiceLogClient) QueryOdometerReading(sl *ServiceLog) *OdometerReadingQuery {
	query := (&OdometerReadingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servicelog.Table, servicelog.FieldID, id),
			sqlgraph.To(odometerreading.Table, odometerreading.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, servicelog.OdometerReadingTable, servicelog.OdometerReadingColumn),
		)
		fromV = sqlgraph.Neighbors(sl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExpense queries the expense edge of a ServiceLog.
func (c *ServiceLogClient) QueryExpense(sl *ServiceLog) *ExpenseQuery {
	query := (&ExpenseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servicelog.Table, servicelog.FieldID, id),
			sqlgraph.To(expense.Table, expense.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, servicelog.ExpenseTable, servicelog.ExpenseColumn),
		)
		fromV = sqlgraph.Neighbors(sl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceLogClient) Hooks() []Hook {
	return c.hooks.ServiceLog
}

// Interceptors returns the client interceptors.
func (c *ServiceLogClient) Interceptors() []Interceptor {
	return c.inters.ServiceLog
}

func (c *ServiceLogClient) mutate(ctx context.Context, m *ServiceLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ServiceLog mutation op: %q", m.Op())
	}
}

// ServiceScheduleClient is a client for the ServiceSchedule schema.
type ServiceScheduleClient struct {
	config
}

// NewServiceScheduleClient returns a client for the ServiceSchedule from the given config.
func NewServiceScheduleClient(c config) *ServiceScheduleClient {
	return &ServiceScheduleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `serviceschedule.Hooks(f(g(h())))`.
func (c *ServiceScheduleClient) Use(hooks ...Hook) {
	c.hooks.ServiceSchedule = append(c.hooks.ServiceSchedule, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `serviceschedule.Intercept(f(g(h())))`.
func (c *ServiceScheduleClient) Intercept(interceptors ...Interceptor) {
	c.inters.ServiceSchedule = append(c.inters.ServiceSchedule, interceptors...)
}

// Create returns a builder for creating a ServiceSchedule entity.
func (c *ServiceScheduleClient) Create() *ServiceScheduleCreate {
	mutation := newServiceScheduleMutation(c.config, OpCreate)
	return &ServiceScheduleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ServiceSchedule entities.
func (c *ServiceScheduleClient) CreateBulk(builders ...*ServiceScheduleCreate) *ServiceScheduleCreateBulk {
	return &ServiceScheduleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServiceScheduleClient) MapCreateBulk(slice any, setFunc func(*ServiceScheduleCreate, int)) *ServiceScheduleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServiceScheduleCreateBulk{err: fmt.Errorf("calling to ServiceScheduleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServiceScheduleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServiceScheduleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ServiceSchedule.
func (c *ServiceScheduleClient) Update() *ServiceScheduleUpdate {
	mutation := newServiceScheduleMutation(c.config, OpUpdate)
	return &ServiceScheduleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceScheduleClient) UpdateOne(ss *ServiceSchedule) *ServiceScheduleUpdateOne {
	mutation := newServiceScheduleMutation(c.config, OpUpdateOne, withServiceSchedule(ss))
	return &ServiceScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceScheduleClient) UpdateOneID(id uuid.UUID) *ServiceScheduleUpdateOne {
	mutation := newServiceScheduleMutation(c.config, OpUpdateOne, withServiceScheduleID(id))
	return &ServiceScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ServiceSchedule.
func (c *ServiceScheduleClient) Delete() *ServiceScheduleDelete {
	mutation := newServiceScheduleMutation(c.config, OpDelete)
	return &ServiceScheduleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServiceScheduleClient) DeleteOne(ss *ServiceSchedule) *ServiceScheduleDeleteOne {
	return c.DeleteOneID(ss.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServiceScheduleClient) DeleteOneID(id uuid.UUID) *ServiceScheduleDeleteOne {
	builder := c.Delete().Where(serviceschedule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceScheduleDeleteOne{builder}
}

// Query returns a query builder for ServiceSchedule.
func (c *ServiceScheduleClient) Query() *ServiceScheduleQuery {
	return &ServiceScheduleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServiceSchedule},
		inters: c.Interceptors(),
	}
}

// Get returns a ServiceSchedule entity by its id.
func (c *ServiceScheduleClient) Get(ctx context.Context, id uuid.UUID) (*ServiceSchedule, error) {
	return c.Query().Where(serviceschedule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceScheduleClient) GetX(ctx context.Context, id uuid.UUID) *ServiceSchedule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCar queries the car edge of a ServiceSchedule.
func (c *ServiceScheduleClient) QueryCar(ss *ServiceSchedule) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ss.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceschedule.Table, serviceschedule.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, serviceschedule.CarTable, serviceschedule.CarColumn),
		)
		fromV = sqlgraph.Neighbors(ss.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryItems queries the items edge of a ServiceSchedule.
func (c *ServiceScheduleClient) QueryItems(ss *ServiceSchedule) *ServiceItemQuery {
	query := (&ServiceItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ss.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceschedule.Table, serviceschedule.FieldID, id),
			sqlgraph.To(serviceitem.Table, serviceitem.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, serviceschedule.ItemsTable, serviceschedule.ItemsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ss.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLogs queries the logs edge of a ServiceSchedule.
func (c *ServiceScheduleClient) QueryLogs(ss *ServiceSchedule) *ServiceLogQuery {
	query := (&ServiceLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ss.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(serviceschedule.Table, serviceschedule.FieldID, id),
			sqlgraph.To(servicelog.Table, servicelog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, serviceschedule.LogsTable, serviceschedule.LogsColumn),
		)
		fromV = sqlgraph.Neighbors(ss.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceScheduleClient) Hooks() []Hook {
	return c.hooks.ServiceSchedule
}

// Interceptors returns the client interceptors.
func (c *ServiceScheduleClient) Interceptors() []Interceptor {
	return c.inters.ServiceSchedule
}

func (c *ServiceScheduleClient) mutate(ctx context.Context, m *ServiceScheduleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServiceScheduleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServiceScheduleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServiceScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServiceScheduleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ServiceSchedule mutation op: %q", m.Op())
	}
}

// SubscriptionClient is a client for the Subscription schema.
type SubscriptionClient struct {
	config
}

// NewSubscriptionClient returns a client for the Subscription from the given config.
func NewSubscriptionClient(c config) *SubscriptionClient {
	return &SubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subscription.Hooks(f(g(h())))`.
func (c *SubscriptionClient) Use(hooks ...Hook) {
	c.hooks.Subscription = append(c.hooks.Subscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subscription.Intercept(f(g(h())))`.
func (c *SubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Subscription = append(c.inters.Subscription, interceptors...)
}

// Create returns a builder for creating a Subscription entity.
func (c *SubscriptionClient) Create() *SubscriptionCreate {
	mutation := newSubscriptionMutation(c.config, OpCreate)
	return &SubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subscription entities.
func (c *SubscriptionClient) CreateBulk(builders ...*SubscriptionCreate) *SubscriptionCreateBulk {
	return &SubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SubscriptionClient) MapCreateBulk(slice any, setFunc func(*SubscriptionCreate, int)) *SubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SubscriptionCreateBulk{err: fmt.Errorf("calling to SubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subscription.
func (c *SubscriptionClient) Update() *SubscriptionUpdate {
	mutation := newSubscriptionMutation(c.config, OpUpdate)
	return &SubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubscriptionClient) UpdateOne(s *Subscription) *SubscriptionUpdateOne {
	mutation := newSubscriptionMutation(c.config, OpUpdateOne, withSubscription(s))
	return &SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubscriptionClient) UpdateOneID(id uuid.UUID) *SubscriptionUpdateOne {
	mutation := newSubscriptionMutation(c.config, OpUpdateOne, withSubscriptionID(id))
	return &SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subscription.
func (c *SubscriptionClient) Delete() *SubscriptionDelete {
	mutation := newSubscriptionMutation(c.config, OpDelete)
	return &SubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubscriptionClient) DeleteOne(s *Subscription) *SubscriptionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubscriptionClient) DeleteOneID(id uuid.UUID) *SubscriptionDeleteOne {
	builder := c.Delete().Where(subscription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubscriptionDeleteOne{builder}
}

// Query returns a query builder for Subscription.
func (c *SubscriptionClient) Query() *SubscriptionQuery {
	return &SubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubscription},
		inters: c.Interceptors(),
	}
}

// Get returns a Subscription entity by its id.
func (c *SubscriptionClient) Get(ctx context.Context, id uuid.UUID) (*Subscription, error) {
	return c.Query().Where(subscription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubscriptionClient) GetX(ctx context.Context, id uuid.UUID) *Subscription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Subscription.
func (c *SubscriptionClient) QueryUser(s *Subscription) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscription.Table, subscription.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, subscription.UserTable, subscription.UserColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCheckoutSession queries the checkout_session edge of a Subscription.
func (c *SubscriptionClient) QueryCheckoutSession(s *Subscription) *CheckoutSessionQuery {
	query := (&CheckoutSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subscription.Table, subscription.FieldID, id),
			sqlgraph.To(checkoutsession.Table, checkoutsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, subscription.CheckoutSessionTable, subscription.CheckoutSessionColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubscriptionClient) Hooks() []Hook {
	return c.hooks.Subscription
}

// Interceptors returns the client interceptors.
func (c *SubscriptionClient) Interceptors() []Interceptor {
	return c.inters.Subscription
}

func (c *SubscriptionClient) mutate(ctx context.Context, m *SubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Subscription mutation op: %q", m.Op())
	}
}

// TaskClient is a client for the Task schema.
type TaskClient struct {
	config
}

// NewTaskClient returns a client for the Task from the given config.
func NewTaskClient(c config) *TaskClient {
	return &TaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `task.Hooks(f(g(h())))`.
func (c *TaskClient) Use(hooks ...Hook) {
	c.hooks.Task = append(c.hooks.Task, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `task.Intercept(f(g(h())))`.
func (c *TaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Task = append(c.inters.Task, interceptors...)
}

// Create returns a builder for creating a Task entity.
func (c *TaskClient) Create() *TaskCreate {
	mutation := newTaskMutation(c.config, OpCreate)
	return &TaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Task entities.
func (c *TaskClient) CreateBulk(builders ...*TaskCreate) *TaskCreateBulk {
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskClient) MapCreateBulk(slice any, setFunc func(*TaskCreate, int)) *TaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskCreateBulk{err: fmt.Errorf("calling to TaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Task.
func (c *TaskClient) Update() *TaskUpdate {
	mutation := newTaskMutation(c.config, OpUpdate)
	return &TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskClient) UpdateOne(t *Task) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTask(t))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskClient) UpdateOneID(id uuid.UUID) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTaskID(id))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Task.
func (c *TaskClient) Delete() *TaskDelete {
	mutation := newTaskMutation(c.config, OpDelete)
	return &TaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskClient) DeleteOne(t *Task) *TaskDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskClient) DeleteOneID(id uuid.UUID) *TaskDeleteOne {
	builder := c.Delete().Where(task.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskDeleteOne{builder}
}

// Query returns a query builder for Task.
func (c *TaskClient) Query() *TaskQuery {
	return &TaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTask},
		inters: c.Interceptors(),
	}
}

// Get returns a Task entity by its id.
func (c *TaskClient) Get(ctx context.Context, id uuid.UUID) (*Task, error) {
	return c.Query().Where(task.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskClient) GetX(ctx context.Context, id uuid.UUID) *Task {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCar queries the car edge of a Task.
func (c *TaskClient) QueryCar(t *Task) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.CarTable, task.CarColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Task.
func (c *TaskClient) QueryParent(t *Task) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.ParentTable, task.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubtasks queries the subtasks edge of a Task.
func (c *TaskClient) QuerySubtasks(t *Task) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, task.SubtasksTable, task.SubtasksColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TaskClient) Hooks() []Hook {
	return c.hooks.Task
}

// Interceptors returns the client interceptors.
func (c *TaskClient) Interceptors() []Interceptor {
	return c.inters.Task
}

func (c *TaskClient) mutate(ctx context.Context, m *TaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Task mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCars queries the cars edge of a User.
func (c *UserClient) QueryCars(u *User) *CarQuery {
	query := (&CarClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(car.Table, car.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CarsTable, user.CarsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfile queries the profile edge of a User.
func (c *UserClient) QueryProfile(u *User) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.ProfileTable, user.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscriptions queries the subscriptions edge of a User.
func (c *UserClient) QuerySubscriptions(u *User) *SubscriptionQuery {
	query := (&SubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(subscription.Table, subscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SubscriptionsTable, user.SubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCheckoutSessions queries the checkout_sessions edge of a User.
func (c *UserClient) QueryCheckoutSessions(u *User) *CheckoutSessionQuery {
	query := (&CheckoutSessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(checkoutsession.Table, checkoutsession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CheckoutSessionsTable, user.CheckoutSessionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Album, Car, CheckoutSession, Document, DragResult, DragSession, DynoResult,
		DynoSession, Expense, FuelUp, Media, OdometerReading, Profile, ServiceItem,
		ServiceLog, ServiceSchedule, Subscription, Task, User []ent.Hook
	}
	inters struct {
		Album, Car, CheckoutSession, Document, DragResult, DragSession, DynoResult,
		DynoSession, Expense, FuelUp, Media, OdometerReading, Profile, ServiceItem,
		ServiceLog, ServiceSchedule, Subscription, Task, User []ent.Interceptor
	}
)

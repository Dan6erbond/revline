package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"net/url"

	"github.com/Dan6erbond/revline/auth"
	"github.com/Dan6erbond/revline/ent"
	"github.com/Dan6erbond/revline/ent/subscription"
	entUser "github.com/Dan6erbond/revline/ent/user"
	"github.com/Dan6erbond/revline/graph/model"
	stripe "github.com/stripe/stripe-go/v82"
	portalsession "github.com/stripe/stripe-go/v82/billingportal/session"
	"github.com/stripe/stripe-go/v82/checkout/session"
)

// CreateCheckoutSession is the resolver for the createCheckoutSession field.
func (r *mutationResolver) CreateCheckoutSession(ctx context.Context, input model.CreateCheckoutSessionInput) (string, error) {
	user := auth.ForContext(ctx)

	baseURL, err := url.Parse(r.config.PublicURL)

	if err != nil {
		return "", err
	}

	var (
		successURL = baseURL.JoinPath("/subscription")
		cancelURL  = baseURL.JoinPath("/subscription")

		price *string
	)

	successURL.RawQuery = "success=true"
	cancelURL.RawQuery = "canceled=true"

	if input.Tier == subscription.TierDiy {
		price = &r.config.Stripe.Products.DIY.Prices.Monthly.ID
	} else {
		price = &r.config.Stripe.Products.Enthusiast.Prices.Monthly.ID
	}

	checkoutSessionCreate := r.entClient.CheckoutSession.Create().
		SetUser(user).
		SetStripePriceID(*price)

	var (
		affiliatePartner *ent.User
	)

	if input.Affiliate != nil {
		affiliatePartner, err = r.entClient.User.Query().Where(
			entUser.Or(
				entUser.Affiliate6moCodeEQ(*input.Affiliate),
				entUser.Affiliate12moCodeEQ(*input.Affiliate),
			),
		).First(ctx)

		if err != nil {
			return "", err
		}

		if *affiliatePartner.Affiliate6moCode == *input.Affiliate {
			checkoutSessionCreate.SetAffiliate6moCode(*affiliatePartner.Affiliate6moCode)
		} else if *affiliatePartner.Affiliate12moCode == *input.Affiliate {
			checkoutSessionCreate.SetAffiliate12moCode(*affiliatePartner.Affiliate12moCode)
		}
	}

	checkoutSession, err := checkoutSessionCreate.Save(ctx)

	if err != nil {
		return "", err
	}

	params := &stripe.CheckoutSessionParams{
		SuccessURL: stripe.String(successURL.String()),
		CancelURL:  stripe.String(cancelURL.String()),
		Mode:       stripe.String(string(stripe.CheckoutSessionModeSubscription)),
		LineItems: []*stripe.CheckoutSessionLineItemParams{{
			Price:    price,
			Quantity: stripe.Int64(1),
		}},
		/* SubscriptionData: &stripe.CheckoutSessionSubscriptionDataParams{
			TrialSettings: &stripe.CheckoutSessionSubscriptionDataTrialSettingsParams{
				EndBehavior: &stripe.CheckoutSessionSubscriptionDataTrialSettingsEndBehaviorParams{
					MissingPaymentMethod: stripe.String("cancel"),
				},
			},
			TrialPeriodDays: stripe.Int64(7),
		}, */
		ClientReferenceID: stripe.String(checkoutSession.ID.String()),
		CustomerEmail:     &user.Email,
	}

	s, err := session.New(params)

	if err != nil {
		return "", nil
	}

	if _, err = checkoutSession.Update().
		SetStripeSessionID(s.ID).
		Save(ctx); err != nil {
		return "", nil
	}

	return s.URL, nil
}

// CreateBillingPortalSession is the resolver for the createBillingPortalSession field.
func (r *mutationResolver) CreateBillingPortalSession(ctx context.Context) (string, error) {
	user := auth.ForContext(ctx)

	baseURL, err := url.Parse(r.config.PublicURL)

	if err != nil {
		return "", err
	}

	returnURL := baseURL.JoinPath("/subscription")

	params := &stripe.BillingPortalSessionParams{
		Customer:  user.StripeCustomerID,
		ReturnURL: stripe.String(returnURL.String()),
	}

	ps, err := portalsession.New(params)

	if err != nil {
		return "", nil
	}

	return ps.URL, nil
}

// Subscription is the resolver for the subscription field.
func (r *userResolver) Subscription(ctx context.Context, obj *ent.User) (*ent.Subscription, error) {
	sub, err := obj.QuerySubscriptions().
		Where(
			subscription.StatusIn("active", "trialing"),
		).
		First(ctx)

	if ent.IsNotFound(err) {
		return nil, nil
	}

	return sub, err
}
